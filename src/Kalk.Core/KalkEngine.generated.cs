//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Date: 21 Nov 2020
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AesIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_aesdec_si128", (Func<object, object, object>)mm_aesdec_si128);
            RegisterFunction("mm_aesdeclast_si128", (Func<object, object, object>)mm_aesdeclast_si128);
            RegisterFunction("mm_aesenc_si128", (Func<object, object, object>)mm_aesenc_si128);
            RegisterFunction("mm_aesenclast_si128", (Func<object, object, object>)mm_aesenclast_si128);
            RegisterFunction("mm_aesimc_si128", (Func<object, object>)mm_aesimc_si128);
            RegisterFunction("mm_aeskeygenassist_si128", (Func<object, byte, object>)mm_aeskeygenassist_si128);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_aesdec_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesdec_si128 (__m128i a, __m128i RoundKey)
    AESDEC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesdeclast_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesdeclast_si128 (__m128i a, __m128i RoundKey)
    AESDECLAST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesenc_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey)
    AESENC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesenclast_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey)
    AESENCLAST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesimc_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesimc_si128 (__m128i a)
    AESIMC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aeskeygenassist_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aeskeygenassist_si128 (__m128i a, const int imm8)
    AESKEYGENASSIST xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Avx2IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_blend_epi32", (Func<object, object, byte, object>)mm_blend_epi32);
            RegisterFunction("mm_broadcastb_epi8", (Func<object, object>)mm_broadcastb_epi8);
            RegisterFunction("mm_broadcastd_epi32", (Func<object, object>)mm_broadcastd_epi32);
            RegisterFunction("mm_broadcastq_epi64", (Func<object, object>)mm_broadcastq_epi64);
            RegisterFunction("mm_broadcastsd_pd", (Func<object, object>)mm_broadcastsd_pd);
            RegisterFunction("mm_broadcastss_ps", (Func<object, object>)mm_broadcastss_ps);
            RegisterFunction("mm_broadcastw_epi16", (Func<object, object>)mm_broadcastw_epi16);
            RegisterFunction("mm_i32gather_epi32", (Func<object, object, byte, object>)mm_i32gather_epi32);
            RegisterFunction("mm_i32gather_epi64", (Func<object, object, byte, object>)mm_i32gather_epi64);
            RegisterFunction("mm_i32gather_pd", (Func<object, object, byte, object>)mm_i32gather_pd);
            RegisterFunction("mm_i32gather_ps", (Func<object, object, byte, object>)mm_i32gather_ps);
            RegisterFunction("mm_i64gather_epi32", (Func<object, object, byte, object>)mm_i64gather_epi32);
            RegisterFunction("mm_i64gather_epi64", (Func<object, object, byte, object>)mm_i64gather_epi64);
            RegisterFunction("mm_i64gather_pd", (Func<object, object, byte, object>)mm_i64gather_pd);
            RegisterFunction("mm_i64gather_ps", (Func<object, object, byte, object>)mm_i64gather_ps);
            RegisterFunction("mm_mask_i32gather_epi32", (Func<object, object, object, object, byte, object>)mm_mask_i32gather_epi32);
            RegisterFunction("mm_mask_i32gather_epi64", (Func<object, object, object, object, byte, object>)mm_mask_i32gather_epi64);
            RegisterFunction("mm_mask_i32gather_pd", (Func<object, object, object, object, byte, object>)mm_mask_i32gather_pd);
            RegisterFunction("mm_mask_i32gather_ps", (Func<object, object, object, object, byte, object>)mm_mask_i32gather_ps);
            RegisterFunction("mm_mask_i64gather_epi32", (Func<object, object, object, object, byte, object>)mm_mask_i64gather_epi32);
            RegisterFunction("mm_mask_i64gather_epi64", (Func<object, object, object, object, byte, object>)mm_mask_i64gather_epi64);
            RegisterFunction("mm_mask_i64gather_pd", (Func<object, object, object, object, byte, object>)mm_mask_i64gather_pd);
            RegisterFunction("mm_mask_i64gather_ps", (Func<object, object, object, object, byte, object>)mm_mask_i64gather_ps);
            RegisterFunction("mm_maskload_epi32", (Func<object, object, object>)mm_maskload_epi32);
            RegisterFunction("mm_maskload_epi64", (Func<object, object, object>)mm_maskload_epi64);
            RegisterAction("mm_maskstore_epi32", (Action<object, object, object>)mm_maskstore_epi32);
            RegisterAction("mm_maskstore_epi64", (Action<object, object, object>)mm_maskstore_epi64);
            RegisterFunction("mm_sllv_epi32", (Func<object, object, object>)mm_sllv_epi32);
            RegisterFunction("mm_sllv_epi64", (Func<object, object, object>)mm_sllv_epi64);
            RegisterFunction("mm_srav_epi32", (Func<object, object, object>)mm_srav_epi32);
            RegisterFunction("mm_srlv_epi32", (Func<object, object, object>)mm_srlv_epi32);
            RegisterFunction("mm_srlv_epi64", (Func<object, object, object>)mm_srlv_epi64);
            RegisterFunction("mm256_abs_epi16", (Func<object, object>)mm256_abs_epi16);
            RegisterFunction("mm256_abs_epi32", (Func<object, object>)mm256_abs_epi32);
            RegisterFunction("mm256_abs_epi8", (Func<object, object>)mm256_abs_epi8);
            RegisterFunction("mm256_add_epi16", (Func<object, object, object>)mm256_add_epi16);
            RegisterFunction("mm256_add_epi32", (Func<object, object, object>)mm256_add_epi32);
            RegisterFunction("mm256_add_epi64", (Func<object, object, object>)mm256_add_epi64);
            RegisterFunction("mm256_add_epi8", (Func<object, object, object>)mm256_add_epi8);
            RegisterFunction("mm256_adds_epi16", (Func<object, object, object>)mm256_adds_epi16);
            RegisterFunction("mm256_adds_epi8", (Func<object, object, object>)mm256_adds_epi8);
            RegisterFunction("mm256_adds_epu16", (Func<object, object, object>)mm256_adds_epu16);
            RegisterFunction("mm256_adds_epu8", (Func<object, object, object>)mm256_adds_epu8);
            RegisterFunction("mm256_alignr_epi8", (Func<object, object, byte, object>)mm256_alignr_epi8);
            RegisterFunction("mm256_and_si256", (Func<object, object, object>)mm256_and_si256);
            RegisterFunction("mm256_andnot_si256", (Func<object, object, object>)mm256_andnot_si256);
            RegisterFunction("mm256_avg_epu16", (Func<object, object, object>)mm256_avg_epu16);
            RegisterFunction("mm256_avg_epu8", (Func<object, object, object>)mm256_avg_epu8);
            RegisterFunction("mm256_blend_epi16", (Func<object, object, byte, object>)mm256_blend_epi16);
            RegisterFunction("mm256_blend_epi32", (Func<object, object, byte, object>)mm256_blend_epi32);
            RegisterFunction("mm256_blendv_epi8", (Func<object, object, object, object>)mm256_blendv_epi8);
            RegisterFunction("mm256_broadcastb_epi8", (Func<object, object>)mm256_broadcastb_epi8);
            RegisterFunction("mm256_broadcastd_epi32", (Func<object, object>)mm256_broadcastd_epi32);
            RegisterFunction("mm256_broadcastq_epi64", (Func<object, object>)mm256_broadcastq_epi64);
            RegisterFunction("mm256_broadcastsd_pd", (Func<object, object>)mm256_broadcastsd_pd);
            RegisterFunction("mm256_broadcastsi128_si256", (Func<object, object>)mm256_broadcastsi128_si256);
            RegisterFunction("mm256_broadcastss_ps", (Func<object, object>)mm256_broadcastss_ps);
            RegisterFunction("mm256_broadcastw_epi16", (Func<object, object>)mm256_broadcastw_epi16);
            RegisterFunction("mm256_bslli_epi128", (Func<object, byte, object>)mm256_bslli_epi128);
            RegisterFunction("mm256_bsrli_epi128", (Func<object, byte, object>)mm256_bsrli_epi128);
            RegisterFunction("mm256_cmpeq_epi16", (Func<object, object, object>)mm256_cmpeq_epi16);
            RegisterFunction("mm256_cmpeq_epi32", (Func<object, object, object>)mm256_cmpeq_epi32);
            RegisterFunction("mm256_cmpeq_epi64", (Func<object, object, object>)mm256_cmpeq_epi64);
            RegisterFunction("mm256_cmpeq_epi8", (Func<object, object, object>)mm256_cmpeq_epi8);
            RegisterFunction("mm256_cmpgt_epi16", (Func<object, object, object>)mm256_cmpgt_epi16);
            RegisterFunction("mm256_cmpgt_epi32", (Func<object, object, object>)mm256_cmpgt_epi32);
            RegisterFunction("mm256_cmpgt_epi64", (Func<object, object, object>)mm256_cmpgt_epi64);
            RegisterFunction("mm256_cmpgt_epi8", (Func<object, object, object>)mm256_cmpgt_epi8);
            RegisterFunction("mm256_cvtepi16_epi32", (Func<object, object>)mm256_cvtepi16_epi32);
            RegisterFunction("mm256_cvtepi16_epi64", (Func<object, object>)mm256_cvtepi16_epi64);
            RegisterFunction("mm256_cvtepi32_epi64", (Func<object, object>)mm256_cvtepi32_epi64);
            RegisterFunction("mm256_cvtepi8_epi16", (Func<object, object>)mm256_cvtepi8_epi16);
            RegisterFunction("mm256_cvtepi8_epi32", (Func<object, object>)mm256_cvtepi8_epi32);
            RegisterFunction("mm256_cvtepi8_epi64", (Func<object, object>)mm256_cvtepi8_epi64);
            RegisterFunction("mm256_cvtepu16_epi32", (Func<object, object>)mm256_cvtepu16_epi32);
            RegisterFunction("mm256_cvtepu16_epi64", (Func<object, object>)mm256_cvtepu16_epi64);
            RegisterFunction("mm256_cvtepu32_epi64", (Func<object, object>)mm256_cvtepu32_epi64);
            RegisterFunction("mm256_cvtepu8_epi16", (Func<object, object>)mm256_cvtepu8_epi16);
            RegisterFunction("mm256_cvtepu8_epi32", (Func<object, object>)mm256_cvtepu8_epi32);
            RegisterFunction("mm256_cvtepu8_epi64", (Func<object, object>)mm256_cvtepu8_epi64);
            RegisterFunction("mm256_cvtsi256_si32", (Func<object, int>)mm256_cvtsi256_si32);
            RegisterFunction("mm256_extracti128_si256", (Func<object, byte, object>)mm256_extracti128_si256);
            RegisterFunction("mm256_hadd_epi16", (Func<object, object, object>)mm256_hadd_epi16);
            RegisterFunction("mm256_hadd_epi32", (Func<object, object, object>)mm256_hadd_epi32);
            RegisterFunction("mm256_hadds_epi16", (Func<object, object, object>)mm256_hadds_epi16);
            RegisterFunction("mm256_hsub_epi16", (Func<object, object, object>)mm256_hsub_epi16);
            RegisterFunction("mm256_hsub_epi32", (Func<object, object, object>)mm256_hsub_epi32);
            RegisterFunction("mm256_hsubs_epi16", (Func<object, object, object>)mm256_hsubs_epi16);
            RegisterFunction("mm256_i32gather_epi32", (Func<object, object, byte, object>)mm256_i32gather_epi32);
            RegisterFunction("mm256_i32gather_epi64", (Func<object, object, byte, object>)mm256_i32gather_epi64);
            RegisterFunction("mm256_i32gather_pd", (Func<object, object, byte, object>)mm256_i32gather_pd);
            RegisterFunction("mm256_i32gather_ps", (Func<object, object, byte, object>)mm256_i32gather_ps);
            RegisterFunction("mm256_i64gather_epi32", (Func<object, object, byte, object>)mm256_i64gather_epi32);
            RegisterFunction("mm256_i64gather_epi64", (Func<object, object, byte, object>)mm256_i64gather_epi64);
            RegisterFunction("mm256_i64gather_pd", (Func<object, object, byte, object>)mm256_i64gather_pd);
            RegisterFunction("mm256_i64gather_ps", (Func<object, object, byte, object>)mm256_i64gather_ps);
            RegisterFunction("mm256_inserti128_si256", (Func<object, object, byte, object>)mm256_inserti128_si256);
            RegisterFunction("mm256_madd_epi16", (Func<object, object, object>)mm256_madd_epi16);
            RegisterFunction("mm256_maddubs_epi16", (Func<object, object, object>)mm256_maddubs_epi16);
            RegisterFunction("mm256_mask_i32gather_epi32", (Func<object, object, object, object, byte, object>)mm256_mask_i32gather_epi32);
            RegisterFunction("mm256_mask_i32gather_epi64", (Func<object, object, object, object, byte, object>)mm256_mask_i32gather_epi64);
            RegisterFunction("mm256_mask_i32gather_pd", (Func<object, object, object, object, byte, object>)mm256_mask_i32gather_pd);
            RegisterFunction("mm256_mask_i32gather_ps", (Func<object, object, object, object, byte, object>)mm256_mask_i32gather_ps);
            RegisterFunction("mm256_mask_i64gather_epi32", (Func<object, object, object, object, byte, object>)mm256_mask_i64gather_epi32);
            RegisterFunction("mm256_mask_i64gather_epi64", (Func<object, object, object, object, byte, object>)mm256_mask_i64gather_epi64);
            RegisterFunction("mm256_mask_i64gather_pd", (Func<object, object, object, object, byte, object>)mm256_mask_i64gather_pd);
            RegisterFunction("mm256_mask_i64gather_ps", (Func<object, object, object, object, byte, object>)mm256_mask_i64gather_ps);
            RegisterFunction("mm256_maskload_epi32", (Func<object, object, object>)mm256_maskload_epi32);
            RegisterFunction("mm256_maskload_epi64", (Func<object, object, object>)mm256_maskload_epi64);
            RegisterAction("mm256_maskstore_epi32", (Action<object, object, object>)mm256_maskstore_epi32);
            RegisterAction("mm256_maskstore_epi64", (Action<object, object, object>)mm256_maskstore_epi64);
            RegisterFunction("mm256_max_epi16", (Func<object, object, object>)mm256_max_epi16);
            RegisterFunction("mm256_max_epi32", (Func<object, object, object>)mm256_max_epi32);
            RegisterFunction("mm256_max_epi8", (Func<object, object, object>)mm256_max_epi8);
            RegisterFunction("mm256_max_epu16", (Func<object, object, object>)mm256_max_epu16);
            RegisterFunction("mm256_max_epu32", (Func<object, object, object>)mm256_max_epu32);
            RegisterFunction("mm256_max_epu8", (Func<object, object, object>)mm256_max_epu8);
            RegisterFunction("mm256_min_epi16", (Func<object, object, object>)mm256_min_epi16);
            RegisterFunction("mm256_min_epi32", (Func<object, object, object>)mm256_min_epi32);
            RegisterFunction("mm256_min_epi8", (Func<object, object, object>)mm256_min_epi8);
            RegisterFunction("mm256_min_epu16", (Func<object, object, object>)mm256_min_epu16);
            RegisterFunction("mm256_min_epu32", (Func<object, object, object>)mm256_min_epu32);
            RegisterFunction("mm256_min_epu8", (Func<object, object, object>)mm256_min_epu8);
            RegisterFunction("mm256_movemask_epi8", (Func<object, int>)mm256_movemask_epi8);
            RegisterFunction("mm256_mpsadbw_epu8", (Func<object, object, byte, object>)mm256_mpsadbw_epu8);
            RegisterFunction("mm256_mul_epi32", (Func<object, object, object>)mm256_mul_epi32);
            RegisterFunction("mm256_mul_epu32", (Func<object, object, object>)mm256_mul_epu32);
            RegisterFunction("mm256_mulhi_epi16", (Func<object, object, object>)mm256_mulhi_epi16);
            RegisterFunction("mm256_mulhi_epu16", (Func<object, object, object>)mm256_mulhi_epu16);
            RegisterFunction("mm256_mulhrs_epi16", (Func<object, object, object>)mm256_mulhrs_epi16);
            RegisterFunction("mm256_mullo_epi16", (Func<object, object, object>)mm256_mullo_epi16);
            RegisterFunction("mm256_mullo_epi32", (Func<object, object, object>)mm256_mullo_epi32);
            RegisterFunction("mm256_or_si256", (Func<object, object, object>)mm256_or_si256);
            RegisterFunction("mm256_packs_epi16", (Func<object, object, object>)mm256_packs_epi16);
            RegisterFunction("mm256_packs_epi32", (Func<object, object, object>)mm256_packs_epi32);
            RegisterFunction("mm256_packus_epi16", (Func<object, object, object>)mm256_packus_epi16);
            RegisterFunction("mm256_packus_epi32", (Func<object, object, object>)mm256_packus_epi32);
            RegisterFunction("mm256_permute2x128_si256", (Func<object, object, byte, object>)mm256_permute2x128_si256);
            RegisterFunction("mm256_permute4x64_epi64", (Func<object, byte, object>)mm256_permute4x64_epi64);
            RegisterFunction("mm256_permute4x64_pd", (Func<object, byte, object>)mm256_permute4x64_pd);
            RegisterFunction("mm256_permutevar8x32_epi32", (Func<object, object, object>)mm256_permutevar8x32_epi32);
            RegisterFunction("mm256_permutevar8x32_ps", (Func<object, object, object>)mm256_permutevar8x32_ps);
            RegisterFunction("mm256_sad_epu8", (Func<object, object, object>)mm256_sad_epu8);
            RegisterFunction("mm256_shuffle_epi32", (Func<object, byte, object>)mm256_shuffle_epi32);
            RegisterFunction("mm256_shuffle_epi8", (Func<object, object, object>)mm256_shuffle_epi8);
            RegisterFunction("mm256_shufflehi_epi16", (Func<object, byte, object>)mm256_shufflehi_epi16);
            RegisterFunction("mm256_shufflelo_epi16", (Func<object, byte, object>)mm256_shufflelo_epi16);
            RegisterFunction("mm256_sign_epi16", (Func<object, object, object>)mm256_sign_epi16);
            RegisterFunction("mm256_sign_epi32", (Func<object, object, object>)mm256_sign_epi32);
            RegisterFunction("mm256_sign_epi8", (Func<object, object, object>)mm256_sign_epi8);
            RegisterFunction("mm256_sll_epi16", (Func<object, object, object>)mm256_sll_epi16);
            RegisterFunction("mm256_sll_epi32", (Func<object, object, object>)mm256_sll_epi32);
            RegisterFunction("mm256_sll_epi64", (Func<object, object, object>)mm256_sll_epi64);
            RegisterFunction("mm256_slli_epi16", (Func<object, byte, object>)mm256_slli_epi16);
            RegisterFunction("mm256_slli_epi32", (Func<object, byte, object>)mm256_slli_epi32);
            RegisterFunction("mm256_slli_epi64", (Func<object, byte, object>)mm256_slli_epi64);
            RegisterFunction("mm256_sllv_epi32", (Func<object, object, object>)mm256_sllv_epi32);
            RegisterFunction("mm256_sllv_epi64", (Func<object, object, object>)mm256_sllv_epi64);
            RegisterFunction("mm256_srai_epi16", (Func<object, byte, object>)mm256_srai_epi16);
            RegisterFunction("mm256_srai_epi32", (Func<object, byte, object>)mm256_srai_epi32);
            RegisterFunction("mm256_srav_epi32", (Func<object, object, object>)mm256_srav_epi32);
            RegisterFunction("mm256_srl_epi16", (Func<object, object, object>)mm256_srl_epi16);
            RegisterFunction("mm256_srl_epi32", (Func<object, object, object>)mm256_srl_epi32);
            RegisterFunction("mm256_srl_epi64", (Func<object, object, object>)mm256_srl_epi64);
            RegisterFunction("mm256_srli_epi16", (Func<object, byte, object>)mm256_srli_epi16);
            RegisterFunction("mm256_srli_epi32", (Func<object, byte, object>)mm256_srli_epi32);
            RegisterFunction("mm256_srli_epi64", (Func<object, byte, object>)mm256_srli_epi64);
            RegisterFunction("mm256_srlv_epi32", (Func<object, object, object>)mm256_srlv_epi32);
            RegisterFunction("mm256_srlv_epi64", (Func<object, object, object>)mm256_srlv_epi64);
            RegisterFunction("mm256_stream_load_si256", (Func<object, object>)mm256_stream_load_si256);
            RegisterFunction("mm256_sub_epi16", (Func<object, object, object>)mm256_sub_epi16);
            RegisterFunction("mm256_sub_epi32", (Func<object, object, object>)mm256_sub_epi32);
            RegisterFunction("mm256_sub_epi64", (Func<object, object, object>)mm256_sub_epi64);
            RegisterFunction("mm256_sub_epi8", (Func<object, object, object>)mm256_sub_epi8);
            RegisterFunction("mm256_subs_epi16", (Func<object, object, object>)mm256_subs_epi16);
            RegisterFunction("mm256_subs_epi8", (Func<object, object, object>)mm256_subs_epi8);
            RegisterFunction("mm256_subs_epu16", (Func<object, object, object>)mm256_subs_epu16);
            RegisterFunction("mm256_subs_epu8", (Func<object, object, object>)mm256_subs_epu8);
            RegisterFunction("mm256_unpackhi_epi16", (Func<object, object, object>)mm256_unpackhi_epi16);
            RegisterFunction("mm256_unpackhi_epi32", (Func<object, object, object>)mm256_unpackhi_epi32);
            RegisterFunction("mm256_unpackhi_epi64", (Func<object, object, object>)mm256_unpackhi_epi64);
            RegisterFunction("mm256_unpackhi_epi8", (Func<object, object, object>)mm256_unpackhi_epi8);
            RegisterFunction("mm256_unpacklo_epi16", (Func<object, object, object>)mm256_unpacklo_epi16);
            RegisterFunction("mm256_unpacklo_epi32", (Func<object, object, object>)mm256_unpacklo_epi32);
            RegisterFunction("mm256_unpacklo_epi64", (Func<object, object, object>)mm256_unpacklo_epi64);
            RegisterFunction("mm256_unpacklo_epi8", (Func<object, object, object>)mm256_unpacklo_epi8);
            RegisterFunction("mm256_xor_si256", (Func<object, object, object>)mm256_xor_si256);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_blend_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Blend packed 32-bit integers from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".
    
    __m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8)
    VPBLENDD xmm, xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_broadcastb_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 8-bit integer from ""a"" to all elements of ""dst"".
    
    __m128i _mm_broadcastb_epi8 (__m128i a)
    VPBROADCASTB xmm, m8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_broadcastd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 32-bit integer from ""a"" to all elements of ""dst"".
    
    __m128i _mm_broadcastd_epi32 (__m128i a)
    VPBROADCASTD xmm, m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_broadcastq_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 64-bit integer from ""a"" to all elements of ""dst"".
    
    __m128i _mm_broadcastq_epi64 (__m128i a)
    VPBROADCASTQ xmm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_broadcastsd_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low double-precision (64-bit) floating-point element from ""a"" to all elements of ""dst"".
    
    __m128d _mm_broadcastsd_pd (__m128d a)
    VMOVDDUP xmm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_broadcastss_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low single-precision (32-bit) floating-point element from ""a"" to all elements of ""dst"".
    
    __m128 _mm_broadcastss_ps (__m128 a)
    VBROADCASTSS xmm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_broadcastw_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 16-bit integer from ""a"" to all elements of ""dst"".
    
    __m128i _mm_broadcastw_epi16 (__m128i a)
    VPBROADCASTW xmm, m16";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_i32gather_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm_i32gather_epi32 (int const* base_addr, __m128i vindex, const int scale)
    VPGATHERDD xmm, vm32x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_i32gather_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
    VPGATHERDQ xmm, vm32x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_i32gather_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128d _mm_i32gather_pd (double const* base_addr, __m128i vindex, const int scale)
    VGATHERDPD xmm, vm32x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_i32gather_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128 _mm_i32gather_ps (float const* base_addr, __m128i vindex, const int scale)
    VGATHERDPS xmm, vm32x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_i64gather_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm_i64gather_epi32 (int const* base_addr, __m128i vindex, const int scale)
    VPGATHERQD xmm, vm64x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_i64gather_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm_i64gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
    VPGATHERQQ xmm, vm64x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_i64gather_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128d _mm_i64gather_pd (double const* base_addr, __m128i vindex, const int scale)
    VGATHERQPD xmm, vm64x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_i64gather_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128 _mm_i64gather_ps (float const* base_addr, __m128i vindex, const int scale)
    VGATHERQPS xmm, vm64x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mask_i32gather_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm_mask_i32gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale)
    VPGATHERDD xmm, vm32x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mask_i32gather_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm_mask_i32gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale)
    VPGATHERDQ xmm, vm32x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mask_i32gather_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128d _mm_mask_i32gather_pd (__m128d src, double const* base_addr, __m128i vindex, __m128d mask, const int scale)
    VGATHERDPD xmm, vm32x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mask_i32gather_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128 _mm_mask_i32gather_ps (__m128 src, float const* base_addr, __m128i vindex, __m128 mask, const int scale)
    VGATHERDPS xmm, vm32x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mask_i64gather_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale)
    VPGATHERQD xmm, vm64x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mask_i64gather_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm_mask_i64gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale)
    VPGATHERQQ xmm, vm64x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mask_i64gather_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128d _mm_mask_i64gather_pd (__m128d src, double const* base_addr, __m128i vindex, __m128d mask, const int scale)
    VGATHERQPD xmm, vm64x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mask_i64gather_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128 _mm_mask_i64gather_ps (__m128 src, float const* base_addr, __m128i vindex, __m128 mask, const int scale)
    VGATHERQPS xmm, vm64x, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_maskload_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Load packed 32-bit integers from memory into ""dst"" using ""mask"" (elements are zeroed out when the highest bit is not set in the corresponding element).
    
    __m128i _mm_maskload_epi32 (int const* mem_addr, __m128i mask)
    VPMASKMOVD xmm, xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_maskload_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Load packed 64-bit integers from memory into ""dst"" using ""mask"" (elements are zeroed out when the highest bit is not set in the corresponding element).
    
    __m128i _mm_maskload_epi64 (__int64 const* mem_addr, __m128i mask)
    VPMASKMOVQ xmm, xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_maskstore_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Store packed 32-bit integers from ""a"" into memory using ""mask"" (elements are not stored when the highest bit is not set in the corresponding element).
    
    void _mm_maskstore_epi32 (int* mem_addr, __m128i mask, __m128i a)
    VPMASKMOVD m128, xmm, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_maskstore_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Store packed 64-bit integers from ""a"" into memory using ""mask"" (elements are not stored when the highest bit is not set in the corresponding element).
    
    void _mm_maskstore_epi64 (__int64* mem_addr, __m128i mask, __m128i a)
    VPMASKMOVQ m128, xmm, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_sllv_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" left by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_sllv_epi32 (__m128i a, __m128i count)
    VPSLLVD xmm, ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sllv_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" left by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_sllv_epi64 (__m128i a, __m128i count)
    VPSLLVQ xmm, ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srav_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by the amount specified by the corresponding element in ""count"" while shifting in sign bits, and store the results in ""dst"".
    
    __m128i _mm_srav_epi32 (__m128i a, __m128i count)
    VPSRAVD xmm, xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srlv_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_srlv_epi32 (__m128i a, __m128i count)
    VPSRLVD xmm, xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srlv_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" right by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_srlv_epi64 (__m128i a, __m128i count)
    VPSRLVQ xmm, xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_abs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the absolute value of packed 16-bit integers in ""a"", and store the unsigned results in ""dst"".
    
    __m256i _mm256_abs_epi16 (__m256i a)
    VPABSW ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_abs_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the absolute value of packed 32-bit integers in ""a"", and store the unsigned results in ""dst"".
    
    __m256i _mm256_abs_epi32 (__m256i a)
    VPABSD ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_abs_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the absolute value of packed 8-bit integers in ""a"", and store the unsigned results in ""dst"".
    
    __m256i _mm256_abs_epi8 (__m256i a)
    VPABSB ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_add_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed 16-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_add_epi16 (__m256i a, __m256i b)
    VPADDW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_add_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed 32-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_add_epi32 (__m256i a, __m256i b)
    VPADDD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_add_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed 64-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_add_epi64 (__m256i a, __m256i b)
    VPADDQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_add_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_add_epi8 (__m256i a, __m256i b)
    VPADDB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_adds_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed 16-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".
    
    __m256i _mm256_adds_epi16 (__m256i a, __m256i b)
    VPADDSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_adds_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".
    
    __m256i _mm256_adds_epi8 (__m256i a, __m256i b)
    VPADDSB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_adds_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed unsigned 16-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".
    
    __m256i _mm256_adds_epu16 (__m256i a, __m256i b)
    VPADDUSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_adds_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed unsigned 8-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".
    
    __m256i _mm256_adds_epu8 (__m256i a, __m256i b)
    VPADDUSB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_alignr_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Concatenate pairs of 16-byte blocks in ""a"" and ""b"" into a 32-byte temporary result, shift the result right by ""count"" bytes, and store the low 16 bytes in ""dst"".
    
    __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)
    VPALIGNR ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_and_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".
    
    __m256i _mm256_and_si256 (__m256i a, __m256i b)
    VPAND ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_andnot_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the bitwise NOT of 256 bits (representing integer data) in ""a"" and then AND with ""b"", and store the result in ""dst"".
    
    __m256i _mm256_andnot_si256 (__m256i a, __m256i b)
    VPANDN ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_avg_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Average packed unsigned 16-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_avg_epu16 (__m256i a, __m256i b)
    VPAVGW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_avg_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Average packed unsigned 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_avg_epu8 (__m256i a, __m256i b)
    VPAVGB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_blend_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Blend packed 16-bit integers from ""a"" and ""b"" within 128-bit lanes using control mask ""imm8"", and store the results in ""dst"".
    
    __m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8)
    VPBLENDW ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_blend_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Blend packed 32-bit integers from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".
    
    __m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8)
    VPBLENDD ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_blendv_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Blend packed 8-bit integers from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".
    
    __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)
    VPBLENDVB ymm, ymm, ymm/m256, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcastb_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 8-bit integer from ""a"" to all elements of ""dst"".
    
    __m256i _mm256_broadcastb_epi8 (__m128i a)
    VPBROADCASTB ymm, m8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcastd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 32-bit integer from ""a"" to all elements of ""dst"".
    
    __m256i _mm256_broadcastd_epi32 (__m128i a)
    VPBROADCASTD ymm, m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcastq_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 64-bit integer from ""a"" to all elements of ""dst"".
    
    __m256i _mm256_broadcastq_epi64 (__m128i a)
    VPBROADCASTQ ymm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcastsd_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low double-precision (64-bit) floating-point element from ""a"" to all elements of ""dst"".
    
    __m256d _mm256_broadcastsd_pd (__m128d a)
    VBROADCASTSD ymm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcastsi128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast 128 bits of integer data from ""a"" to all 128-bit lanes in ""dst"".
    
    __m256i _mm256_broadcastsi128_si256 (__m128i a)
    VBROADCASTI128 ymm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcastss_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low single-precision (32-bit) floating-point element from ""a"" to all elements of ""dst"".
    
    __m256 _mm256_broadcastss_ps (__m128 a)
    VBROADCASTSS ymm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcastw_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 16-bit integer from ""a"" to all elements of ""dst"".
    
    __m256i _mm256_broadcastw_epi16 (__m128i a)
    VPBROADCASTW ymm, m16";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_bslli_epi128"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift 128-bit lanes in ""a"" left by ""imm8"" bytes while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_bslli_epi128 (__m256i a, const int imm8)
    VPSLLDQ ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_bsrli_epi128"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift 128-bit lanes in ""a"" right by ""imm8"" bytes while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8)
    VPSRLDQ ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpeq_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m256i _mm256_cmpeq_epi16 (__m256i a, __m256i b)
    VPCMPEQW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpeq_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)
    VPCMPEQD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpeq_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 64-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m256i _mm256_cmpeq_epi64 (__m256i a, __m256i b)
    VPCMPEQQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpeq_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m256i _mm256_cmpeq_epi8 (__m256i a, __m256i b)
    VPCMPEQB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpgt_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m256i _mm256_cmpgt_epi16 (__m256i a, __m256i b)
    VPCMPGTW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpgt_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)
    VPCMPGTD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpgt_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 64-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b)
    VPCMPGTQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpgt_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m256i _mm256_cmpgt_epi8 (__m256i a, __m256i b)
    VPCMPGTB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepi16_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 16-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepi16_epi32 (__m128i a)
    VPMOVSXWD ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepi16_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 16-bit integers in ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepi16_epi64 (__m128i a)
    VPMOVSXWQ ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepi32_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 32-bit integers in ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepi32_epi64 (__m128i a)
    VPMOVSXDQ ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepi8_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 8-bit integers in ""a"" to packed 16-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepi8_epi16 (__m128i a)
    VPMOVSXBW ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepi8_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 8-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepi8_epi32 (__m128i a)
    VPMOVSXBD ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepi8_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 8-bit integers in the low 8 bytes of ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepi8_epi64 (__m128i a)
    VPMOVSXBQ ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepu16_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Zero extend packed unsigned 16-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepu16_epi32 (__m128i a)
    VPMOVZXWD ymm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepu16_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Zero extend packed unsigned 16-bit integers in ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepu16_epi64 (__m128i a)
    VPMOVZXWQ ymm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepu32_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Zero extend packed unsigned 32-bit integers in ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepu32_epi64 (__m128i a)
    VPMOVZXDQ ymm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepu8_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Zero extend packed unsigned 8-bit integers in ""a"" to packed 16-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepu8_epi16 (__m128i a)
    VPMOVZXBW ymm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepu8_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Zero extend packed unsigned 8-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepu8_epi32 (__m128i a)
    VPMOVZXBD ymm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepu8_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Zero extend packed unsigned 8-bit integers in the low 8 byte sof ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtepu8_epi64 (__m128i a)
    VPMOVZXBQ ymm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtsi256_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Copy the lower 32-bit integer in ""a"" to ""dst"".
    
    int _mm256_cvtsi256_si32 (__m256i a)
    MOVD reg/m32, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_extracti128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Extract 128 bits (composed of integer data) from ""a"", selected with ""imm8"", and store the result in ""dst"".
    
    __m128i _mm256_extracti128_si256 (__m256i a, const int imm8)
    VEXTRACTI128 xmm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hadd_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".
    
    __m256i _mm256_hadd_epi16 (__m256i a, __m256i b)
    VPHADDW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hadd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally add adjacent pairs of 32-bit integers in ""a"" and ""b"", and pack the signed 32-bit results in ""dst"".
    
    __m256i _mm256_hadd_epi32 (__m256i a, __m256i b)
    VPHADDD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hadds_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".
    
    __m256i _mm256_hadds_epi16 (__m256i a, __m256i b)
    VPHADDSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hsub_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".
    
    __m256i _mm256_hsub_epi16 (__m256i a, __m256i b)
    VPHSUBW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hsub_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 32-bit integers in ""a"" and ""b"", and pack the signed 32-bit results in ""dst"".
    
    __m256i _mm256_hsub_epi32 (__m256i a, __m256i b)
    VPHSUBD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hsubs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".
    
    __m256i _mm256_hsubs_epi16 (__m256i a, __m256i b)
    VPHSUBSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_i32gather_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m256i _mm256_i32gather_epi32 (int const* base_addr, __m256i vindex, const int scale)
    VPGATHERDD ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_i32gather_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m256i _mm256_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale)
    VPGATHERDQ ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_i32gather_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m256d _mm256_i32gather_pd (double const* base_addr, __m128i vindex, const int scale)
    VGATHERDPD ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_i32gather_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m256 _mm256_i32gather_ps (float const* base_addr, __m256i vindex, const int scale)
    VGATHERDPS ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_i64gather_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm256_i64gather_epi32 (int const* base_addr, __m256i vindex, const int scale)
    VPGATHERQD xmm, vm64y, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_i64gather_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m256i _mm256_i64gather_epi64 (__int64 const* base_addr, __m256i vindex, const int scale)
    VPGATHERQQ ymm, vm64y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_i64gather_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m256d _mm256_i64gather_pd (double const* base_addr, __m256i vindex, const int scale)
    VGATHERQPD ymm, vm64y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_i64gather_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"". ""scale"" should be 1, 2, 4 or 8.
    
    __m128 _mm256_i64gather_ps (float const* base_addr, __m256i vindex, const int scale)
    VGATHERQPS xmm, vm64y, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_inserti128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Copy ""a"" to ""dst"", then insert 128 bits (composed of integer data) from ""b"" into ""dst"" at the location specified by ""imm8"".
    
    __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8)
    VINSERTI128 ymm, ymm, xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_madd_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply packed signed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in ""dst"".
    
    __m256i _mm256_madd_epi16 (__m256i a, __m256i b)
    VPMADDWD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_maddubs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Vertically multiply each unsigned 8-bit integer from ""a"" with the corresponding signed 8-bit integer from ""b"", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in ""dst"".
    
    __m256i _mm256_maddubs_epi16 (__m256i a, __m256i b)
    VPMADDUBSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mask_i32gather_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 32-bit integers from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m256i _mm256_mask_i32gather_epi32 (__m256i src, int const* base_addr, __m256i vindex, __m256i mask, const int scale)
    VPGATHERDD ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mask_i32gather_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m256i _mm256_mask_i32gather_epi64 (__m256i src, __int64 const* base_addr, __m128i vindex, __m256i mask, const int scale)
    VPGATHERDQ ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mask_i32gather_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather double-precision (64-bit) floating-point elements from memory using 32-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m256d _mm256_mask_i32gather_pd (__m256d src, double const* base_addr, __m128i vindex, __m256d mask, const int scale)
    VPGATHERDPD ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mask_i32gather_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather single-precision (32-bit) floating-point elements from memory using 32-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 32-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m256 _mm256_mask_i32gather_ps (__m256 src, float const* base_addr, __m256i vindex, __m256 mask, const int scale)
    VPGATHERDPS ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mask_i64gather_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 32-bit integers from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128i _mm256_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m256i vindex, __m128i mask, const int scale)
    VPGATHERQD xmm, vm32y, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mask_i64gather_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m256i _mm256_mask_i64gather_epi64 (__m256i src, __int64 const* base_addr, __m256i vindex, __m256i mask, const int scale)
    VPGATHERQQ ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mask_i64gather_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather double-precision (64-bit) floating-point elements from memory using 64-bit indices. 64-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m256d _mm256_mask_i64gather_pd (__m256d src, double const* base_addr, __m256i vindex, __m256d mask, const int scale)
    VGATHERQPD ymm, vm32y, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mask_i64gather_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Gather single-precision (32-bit) floating-point elements from memory using 64-bit indices. 32-bit elements are loaded from addresses starting at ""base_addr"" and offset by each 64-bit element in ""vindex"" (each index is scaled by the factor in ""scale""). Gathered elements are merged into ""dst"" using ""mask"" (elements are copied from ""src"" when the highest bit is not set in the corresponding element). ""scale"" should be 1, 2, 4 or 8.
    
    __m128 _mm256_mask_i64gather_ps (__m128 src, float const* base_addr, __m256i vindex, __m128 mask, const int scale)
    VGATHERQPS xmm, vm32y, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_maskload_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Load packed 32-bit integers from memory into ""dst"" using ""mask"" (elements are zeroed out when the highest bit is not set in the corresponding element).
    
    __m256i _mm256_maskload_epi32 (int const* mem_addr, __m256i mask)
    VPMASKMOVD ymm, ymm, m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_maskload_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Load packed 64-bit integers from memory into ""dst"" using ""mask"" (elements are zeroed out when the highest bit is not set in the corresponding element).
    
    __m256i _mm256_maskload_epi64 (__int64 const* mem_addr, __m256i mask)
    VPMASKMOVQ ymm, ymm, m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_maskstore_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Store packed 32-bit integers from ""a"" into memory using ""mask"" (elements are not stored when the highest bit is not set in the corresponding element).
    
    void _mm256_maskstore_epi32 (int* mem_addr, __m256i mask, __m256i a)
    VPMASKMOVD m256, ymm, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_maskstore_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Store packed 64-bit integers from ""a"" into memory using ""mask"" (elements are not stored when the highest bit is not set in the corresponding element).
    
    void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a)
    VPMASKMOVQ m256, ymm, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_max_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m256i _mm256_max_epi16 (__m256i a, __m256i b)
    VPMAXSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_max_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m256i _mm256_max_epi32 (__m256i a, __m256i b)
    VPMAXSD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_max_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m256i _mm256_max_epi8 (__m256i a, __m256i b)
    VPMAXSB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_max_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed unsigned 16-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m256i _mm256_max_epu16 (__m256i a, __m256i b)
    VPMAXUW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_max_epu32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed unsigned 32-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m256i _mm256_max_epu32 (__m256i a, __m256i b)
    VPMAXUD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_max_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed unsigned 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m256i _mm256_max_epu8 (__m256i a, __m256i b)
    VPMAXUB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_min_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m256i _mm256_min_epi16 (__m256i a, __m256i b)
    VPMINSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_min_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m256i _mm256_min_epi32 (__m256i a, __m256i b)
    VPMINSD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_min_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m256i _mm256_min_epi8 (__m256i a, __m256i b)
    VPMINSB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_min_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed unsigned 16-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m256i _mm256_min_epu16 (__m256i a, __m256i b)
    VPMINUW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_min_epu32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed unsigned 32-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m256i _mm256_min_epu32 (__m256i a, __m256i b)
    VPMINUD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_min_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed unsigned 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m256i _mm256_min_epu8 (__m256i a, __m256i b)
    VPMINUB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_movemask_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Create mask from the most significant bit of each 8-bit element in ""a"", and store the result in ""dst"".
    
    int _mm256_movemask_epi8 (__m256i a)
    VPMOVMSKB reg, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mpsadbw_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in ""a"" compared to those in ""b"", and store the 16-bit results in ""dst"".
    	Eight SADs are performed for each 128-bit lane using one quadruplet from ""b"" and eight quadruplets from ""a"". One quadruplet is selected from ""b"" starting at on the offset specified in ""imm8"". Eight quadruplets are formed from sequential 8-bit integers selected from ""a"" starting at the offset specified in ""imm8"".
    
    __m256i _mm256_mpsadbw_epu8 (__m256i a, __m256i b, const int imm8)
    VMPSADBW ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mul_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the low 32-bit integers from each packed 64-bit element in ""a"" and ""b"", and store the signed 64-bit results in ""dst"".
    
    __m256i _mm256_mul_epi32 (__m256i a, __m256i b)
    VPMULDQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mul_epu32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the low unsigned 32-bit integers from each packed 64-bit element in ""a"" and ""b"", and store the unsigned 64-bit results in ""dst"".
    
    __m256i _mm256_mul_epu32 (__m256i a, __m256i b)
    VPMULUDQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mulhi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in ""dst"".
    
    __m256i _mm256_mulhi_epi16 (__m256i a, __m256i b)
    VPMULHW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mulhi_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the packed unsigned 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in ""dst"".
    
    __m256i _mm256_mulhi_epu16 (__m256i a, __m256i b)
    VPMULHUW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mulhrs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply packed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to ""dst"".
    
    __m256i _mm256_mulhrs_epi16 (__m256i a, __m256i b)
    VPMULHRSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mullo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in ""dst"".
    
    __m256i _mm256_mullo_epi16 (__m256i a, __m256i b)
    VPMULLW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mullo_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the packed 32-bit integers in ""a"" and ""b"", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in ""dst"".
    
    __m256i _mm256_mullo_epi32 (__m256i a, __m256i b)
    VPMULLD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_or_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the bitwise OR of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".
    
    __m256i _mm256_or_si256 (__m256i a, __m256i b)
    VPOR ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_packs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Convert packed 16-bit integers from ""a"" and ""b"" to packed 8-bit integers using signed saturation, and store the results in ""dst"".
    
    __m256i _mm256_packs_epi16 (__m256i a, __m256i b)
    VPACKSSWB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_packs_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Convert packed 32-bit integers from ""a"" and ""b"" to packed 16-bit integers using signed saturation, and store the results in ""dst"".
    
    __m256i _mm256_packs_epi32 (__m256i a, __m256i b)
    VPACKSSDW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_packus_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Convert packed 16-bit integers from ""a"" and ""b"" to packed 8-bit integers using unsigned saturation, and store the results in ""dst"".
    
    __m256i _mm256_packus_epi16 (__m256i a, __m256i b)
    VPACKUSWB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_packus_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Convert packed 32-bit integers from ""a"" and ""b"" to packed 16-bit integers using unsigned saturation, and store the results in ""dst"".
    
    __m256i _mm256_packus_epi32 (__m256i a, __m256i b)
    VPACKUSDW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permute2x128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 128-bits (composed of integer data) selected by ""imm8"" from ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8)
    VPERM2I128 ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permute4x64_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 64-bit integers in ""a"" across lanes using the control in ""imm8"", and store the results in ""dst"".
    
    __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8)
    VPERMQ ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permute4x64_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle double-precision (64-bit) floating-point elements in ""a"" across lanes using the control in ""imm8"", and store the results in ""dst"".
    
    __m256d _mm256_permute4x64_pd (__m256d a, const int imm8)
    VPERMPD ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permutevar8x32_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 32-bit integers in ""a"" across lanes using the corresponding index in ""idx"", and store the results in ""dst"".
    
    __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx)
    VPERMD ymm, ymm/m256, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permutevar8x32_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" across lanes using the corresponding index in ""idx"".
    
    __m256 _mm256_permutevar8x32_ps (__m256 a, __m256i idx)
    VPERMPS ymm, ymm/m256, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sad_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the absolute differences of packed unsigned 8-bit integers in ""a"" and ""b"", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in ""dst"".
    
    __m256i _mm256_sad_epu8 (__m256i a, __m256i b)
    VPSADBW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_shuffle_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 32-bit integers in ""a"" within 128-bit lanes using the control in ""imm8"", and store the results in ""dst"".
    
    __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8)
    VPSHUFD ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_shuffle_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 8-bit integers in ""a"" within 128-bit lanes according to shuffle control mask in the corresponding 8-bit element of ""b"", and store the results in ""dst"".
    
    __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b)
    VPSHUFB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_shufflehi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of ""a"" using the control in ""imm8"". Store the results in the high 64 bits of 128-bit lanes of ""dst"", with the low 64 bits of 128-bit lanes being copied from from ""a"" to ""dst"".
    
    __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8)
    VPSHUFHW ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_shufflelo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of ""a"" using the control in ""imm8"". Store the results in the low 64 bits of 128-bit lanes of ""dst"", with the high 64 bits of 128-bit lanes being copied from from ""a"" to ""dst"".
    
    __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8)
    VPSHUFLW ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sign_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Negate packed 16-bit integers in ""a"" when the corresponding signed 16-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.
    
    __m256i _mm256_sign_epi16 (__m256i a, __m256i b)
    VPSIGNW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sign_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Negate packed 32-bit integers in ""a"" when the corresponding signed 32-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.
    
    __m256i _mm256_sign_epi32 (__m256i a, __m256i b)
    VPSIGND ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sign_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Negate packed 8-bit integers in ""a"" when the corresponding signed 8-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.
    
    __m256i _mm256_sign_epi8 (__m256i a, __m256i b)
    VPSIGNB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sll_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_sll_epi16 (__m256i a, __m128i count)
    VPSLLW ymm, ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sll_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_sll_epi32 (__m256i a, __m128i count)
    VPSLLD ymm, ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sll_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_sll_epi64 (__m256i a, __m128i count)
    VPSLLQ ymm, ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_slli_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" left by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_slli_epi16 (__m256i a, int imm8)
    VPSLLW ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_slli_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" left by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_slli_epi32 (__m256i a, int imm8)
    VPSLLD ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_slli_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" left by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_slli_epi64 (__m256i a, int imm8)
    VPSLLQ ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sllv_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" left by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_sllv_epi32 (__m256i a, __m256i count)
    VPSLLVD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sllv_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" left by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_sllv_epi64 (__m256i a, __m256i count)
    VPSLLVQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srai_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""imm8"" while shifting in sign bits, and store the results in ""dst"".
    
    __m256i _mm256_srai_epi16 (__m256i a, int imm8)
    VPSRAW ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srai_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by ""imm8"" while shifting in sign bits, and store the results in ""dst"".
    
    __m256i _mm256_srai_epi32 (__m256i a, int imm8)
    VPSRAD ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srav_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by the amount specified by the corresponding element in ""count"" while shifting in sign bits, and store the results in ""dst"".
    
    __m256i _mm256_srav_epi32 (__m256i a, __m256i count)
    VPSRAVD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srl_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_srl_epi16 (__m256i a, __m128i count)
    VPSRLW ymm, ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srl_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_srl_epi32 (__m256i a, __m128i count)
    VPSRLD ymm, ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srl_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_srl_epi64 (__m256i a, __m128i count)
    VPSRLQ ymm, ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srli_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_srli_epi16 (__m256i a, int imm8)
    VPSRLW ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srli_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_srli_epi32 (__m256i a, int imm8)
    VPSRLD ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srli_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" right by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_srli_epi64 (__m256i a, int imm8)
    VPSRLQ ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srlv_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_srlv_epi32 (__m256i a, __m256i count)
    VPSRLVD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_srlv_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" right by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m256i _mm256_srlv_epi64 (__m256i a, __m256i count)
    VPSRLVQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_stream_load_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Load 256-bits of integer data from memory into ""dst"" using a non-temporal memory hint.
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    __m256i _mm256_stream_load_si256 (__m256i const* mem_addr)
    VMOVNTDQA ymm, m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sub_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed 16-bit integers in ""b"" from packed 16-bit integers in ""a"", and store the results in ""dst"".
    
    __m256i _mm256_sub_epi16 (__m256i a, __m256i b)
    VPSUBW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sub_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed 32-bit integers in ""b"" from packed 32-bit integers in ""a"", and store the results in ""dst"".
    
    __m256i _mm256_sub_epi32 (__m256i a, __m256i b)
    VPSUBD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sub_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed 64-bit integers in ""b"" from packed 64-bit integers in ""a"", and store the results in ""dst"".
    
    __m256i _mm256_sub_epi64 (__m256i a, __m256i b)
    VPSUBQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sub_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"", and store the results in ""dst"".
    
    __m256i _mm256_sub_epi8 (__m256i a, __m256i b)
    VPSUBB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_subs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed 16-bit integers in ""b"" from packed 16-bit integers in ""a"" using saturation, and store the results in ""dst"".
    
    __m256i _mm256_subs_epi16 (__m256i a, __m256i b)
    VPSUBSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_subs_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"" using saturation, and store the results in ""dst"".
    
    __m256i _mm256_subs_epi8 (__m256i a, __m256i b)
    VPSUBSB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_subs_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed unsigned 16-bit integers in ""b"" from packed unsigned 16-bit integers in ""a"" using saturation, and store the results in ""dst"".
    
    __m256i _mm256_subs_epu16 (__m256i a, __m256i b)
    VPSUBUSW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_subs_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed unsigned 8-bit integers in ""b"" from packed unsigned 8-bit integers in ""a"" using saturation, and store the results in ""dst"".
    
    __m256i _mm256_subs_epu8 (__m256i a, __m256i b)
    VPSUBUSB ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 16-bit integers from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_unpackhi_epi16 (__m256i a, __m256i b)
    VPUNPCKHWD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 32-bit integers from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_unpackhi_epi32 (__m256i a, __m256i b)
    VPUNPCKHDQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 64-bit integers from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_unpackhi_epi64 (__m256i a, __m256i b)
    VPUNPCKHQDQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_unpackhi_epi8 (__m256i a, __m256i b)
    VPUNPCKHBW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 16-bit integers from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_unpacklo_epi16 (__m256i a, __m256i b)
    VPUNPCKLWD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 32-bit integers from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_unpacklo_epi32 (__m256i a, __m256i b)
    VPUNPCKLDQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 64-bit integers from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_unpacklo_epi64 (__m256i a, __m256i b)
    VPUNPCKLQDQ ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_unpacklo_epi8 (__m256i a, __m256i b)
    VPUNPCKLBW ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_xor_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the bitwise XOR of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".
    
    __m256i _mm256_xor_si256 (__m256i a, __m256i b)
    VPXOR ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AvxIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_broadcast_ss", (Func<object, object>)mm_broadcast_ss);
            RegisterFunction("mm_cmp_pd", (Func<object, object, System.Runtime.Intrinsics.X86.FloatComparisonMode, object>)mm_cmp_pd);
            RegisterFunction("mm_cmp_ps", (Func<object, object, System.Runtime.Intrinsics.X86.FloatComparisonMode, object>)mm_cmp_ps);
            RegisterFunction("mm_cmp_sd", (Func<object, object, System.Runtime.Intrinsics.X86.FloatComparisonMode, object>)mm_cmp_sd);
            RegisterFunction("mm_cmp_ss", (Func<object, object, System.Runtime.Intrinsics.X86.FloatComparisonMode, object>)mm_cmp_ss);
            RegisterFunction("mm_maskload_pd", (Func<object, object, object>)mm_maskload_pd);
            RegisterFunction("mm_maskload_ps", (Func<object, object, object>)mm_maskload_ps);
            RegisterAction("mm_maskstore_pd", (Action<object, object, object>)mm_maskstore_pd);
            RegisterAction("mm_maskstore_ps", (Action<object, object, object>)mm_maskstore_ps);
            RegisterFunction("mm_permute_pd", (Func<object, byte, object>)mm_permute_pd);
            RegisterFunction("mm_permute_ps", (Func<object, byte, object>)mm_permute_ps);
            RegisterFunction("mm_permutevar_pd", (Func<object, object, object>)mm_permutevar_pd);
            RegisterFunction("mm_permutevar_ps", (Func<object, object, object>)mm_permutevar_ps);
            RegisterFunction("mm_testc_pd", (Func<object, object, Kalk.Core.KalkBool>)mm_testc_pd);
            RegisterFunction("mm_testc_ps", (Func<object, object, Kalk.Core.KalkBool>)mm_testc_ps);
            RegisterFunction("mm_testnzc_pd", (Func<object, object, Kalk.Core.KalkBool>)mm_testnzc_pd);
            RegisterFunction("mm_testnzc_ps", (Func<object, object, Kalk.Core.KalkBool>)mm_testnzc_ps);
            RegisterFunction("mm_testz_pd", (Func<object, object, Kalk.Core.KalkBool>)mm_testz_pd);
            RegisterFunction("mm_testz_ps", (Func<object, object, Kalk.Core.KalkBool>)mm_testz_ps);
            RegisterFunction("mm256_add_pd", (Func<object, object, object>)mm256_add_pd);
            RegisterFunction("mm256_add_ps", (Func<object, object, object>)mm256_add_ps);
            RegisterFunction("mm256_addsub_pd", (Func<object, object, object>)mm256_addsub_pd);
            RegisterFunction("mm256_addsub_ps", (Func<object, object, object>)mm256_addsub_ps);
            RegisterFunction("mm256_and_pd", (Func<object, object, object>)mm256_and_pd);
            RegisterFunction("mm256_and_ps", (Func<object, object, object>)mm256_and_ps);
            RegisterFunction("mm256_andnot_pd", (Func<object, object, object>)mm256_andnot_pd);
            RegisterFunction("mm256_andnot_ps", (Func<object, object, object>)mm256_andnot_ps);
            RegisterFunction("mm256_blend_pd", (Func<object, object, byte, object>)mm256_blend_pd);
            RegisterFunction("mm256_blend_ps", (Func<object, object, byte, object>)mm256_blend_ps);
            RegisterFunction("mm256_blendv_pd", (Func<object, object, object, object>)mm256_blendv_pd);
            RegisterFunction("mm256_blendv_ps", (Func<object, object, object, object>)mm256_blendv_ps);
            RegisterFunction("mm256_broadcast_pd", (Func<object, object>)mm256_broadcast_pd);
            RegisterFunction("mm256_broadcast_ps", (Func<object, object>)mm256_broadcast_ps);
            RegisterFunction("mm256_broadcast_sd", (Func<object, object>)mm256_broadcast_sd);
            RegisterFunction("mm256_broadcast_ss", (Func<object, object>)mm256_broadcast_ss);
            RegisterFunction("mm256_ceil_pd", (Func<object, object>)mm256_ceil_pd);
            RegisterFunction("mm256_ceil_ps", (Func<object, object>)mm256_ceil_ps);
            RegisterFunction("mm256_cmp_pd", (Func<object, object, System.Runtime.Intrinsics.X86.FloatComparisonMode, object>)mm256_cmp_pd);
            RegisterFunction("mm256_cmp_ps", (Func<object, object, System.Runtime.Intrinsics.X86.FloatComparisonMode, object>)mm256_cmp_ps);
            RegisterFunction("mm256_cmpeq_pd", (Func<object, object, object>)mm256_cmpeq_pd);
            RegisterFunction("mm256_cmpeq_ps", (Func<object, object, object>)mm256_cmpeq_ps);
            RegisterFunction("mm256_cmpge_pd", (Func<object, object, object>)mm256_cmpge_pd);
            RegisterFunction("mm256_cmpge_ps", (Func<object, object, object>)mm256_cmpge_ps);
            RegisterFunction("mm256_cmpgt_pd", (Func<object, object, object>)mm256_cmpgt_pd);
            RegisterFunction("mm256_cmpgt_ps", (Func<object, object, object>)mm256_cmpgt_ps);
            RegisterFunction("mm256_cmple_pd", (Func<object, object, object>)mm256_cmple_pd);
            RegisterFunction("mm256_cmple_ps", (Func<object, object, object>)mm256_cmple_ps);
            RegisterFunction("mm256_cmplt_pd", (Func<object, object, object>)mm256_cmplt_pd);
            RegisterFunction("mm256_cmplt_ps", (Func<object, object, object>)mm256_cmplt_ps);
            RegisterFunction("mm256_cmpneq_pd", (Func<object, object, object>)mm256_cmpneq_pd);
            RegisterFunction("mm256_cmpneq_ps", (Func<object, object, object>)mm256_cmpneq_ps);
            RegisterFunction("mm256_cmpnge_pd", (Func<object, object, object>)mm256_cmpnge_pd);
            RegisterFunction("mm256_cmpnge_ps", (Func<object, object, object>)mm256_cmpnge_ps);
            RegisterFunction("mm256_cmpngt_pd", (Func<object, object, object>)mm256_cmpngt_pd);
            RegisterFunction("mm256_cmpngt_ps", (Func<object, object, object>)mm256_cmpngt_ps);
            RegisterFunction("mm256_cmpnle_pd", (Func<object, object, object>)mm256_cmpnle_pd);
            RegisterFunction("mm256_cmpnle_ps", (Func<object, object, object>)mm256_cmpnle_ps);
            RegisterFunction("mm256_cmpnlt_pd", (Func<object, object, object>)mm256_cmpnlt_pd);
            RegisterFunction("mm256_cmpnlt_ps", (Func<object, object, object>)mm256_cmpnlt_ps);
            RegisterFunction("mm256_cmpord_pd", (Func<object, object, object>)mm256_cmpord_pd);
            RegisterFunction("mm256_cmpord_ps", (Func<object, object, object>)mm256_cmpord_ps);
            RegisterFunction("mm256_cmpunord_pd", (Func<object, object, object>)mm256_cmpunord_pd);
            RegisterFunction("mm256_cmpunord_ps", (Func<object, object, object>)mm256_cmpunord_ps);
            RegisterFunction("mm256_cvtepi32_pd", (Func<object, object>)mm256_cvtepi32_pd);
            RegisterFunction("mm256_cvtepi32_ps", (Func<object, object>)mm256_cvtepi32_ps);
            RegisterFunction("mm256_cvtpd_epi32", (Func<object, object>)mm256_cvtpd_epi32);
            RegisterFunction("mm256_cvtpd_ps", (Func<object, object>)mm256_cvtpd_ps);
            RegisterFunction("mm256_cvtps_epi32", (Func<object, object>)mm256_cvtps_epi32);
            RegisterFunction("mm256_cvtps_pd", (Func<object, object>)mm256_cvtps_pd);
            RegisterFunction("mm256_cvttpd_epi32", (Func<object, object>)mm256_cvttpd_epi32);
            RegisterFunction("mm256_cvttps_epi32", (Func<object, object>)mm256_cvttps_epi32);
            RegisterFunction("mm256_div_pd", (Func<object, object, object>)mm256_div_pd);
            RegisterFunction("mm256_div_ps", (Func<object, object, object>)mm256_div_ps);
            RegisterFunction("mm256_dp_ps", (Func<object, object, byte, object>)mm256_dp_ps);
            RegisterFunction("mm256_extractf128_pd", (Func<object, byte, object>)mm256_extractf128_pd);
            RegisterFunction("mm256_extractf128_ps", (Func<object, byte, object>)mm256_extractf128_ps);
            RegisterFunction("mm256_extractf128_si256", (Func<object, byte, object>)mm256_extractf128_si256);
            RegisterFunction("mm256_floor_pd", (Func<object, object>)mm256_floor_pd);
            RegisterFunction("mm256_floor_ps", (Func<object, object>)mm256_floor_ps);
            RegisterFunction("mm256_hadd_pd", (Func<object, object, object>)mm256_hadd_pd);
            RegisterFunction("mm256_hadd_ps", (Func<object, object, object>)mm256_hadd_ps);
            RegisterFunction("mm256_hsub_pd", (Func<object, object, object>)mm256_hsub_pd);
            RegisterFunction("mm256_hsub_ps", (Func<object, object, object>)mm256_hsub_ps);
            RegisterFunction("mm256_insertf128_pd", (Func<object, object, byte, object>)mm256_insertf128_pd);
            RegisterFunction("mm256_insertf128_ps", (Func<object, object, byte, object>)mm256_insertf128_ps);
            RegisterFunction("mm256_insertf128_si256", (Func<object, object, byte, object>)mm256_insertf128_si256);
            RegisterFunction("mm256_lddqu_si256", (Func<object, object>)mm256_lddqu_si256);
            RegisterFunction("mm256_load_pd", (Func<object, object>)mm256_load_pd);
            RegisterFunction("mm256_load_ps", (Func<object, object>)mm256_load_ps);
            RegisterFunction("mm256_load_si256", (Func<object, object>)mm256_load_si256);
            RegisterFunction("mm256_loadu_pd", (Func<object, object>)mm256_loadu_pd);
            RegisterFunction("mm256_loadu_ps", (Func<object, object>)mm256_loadu_ps);
            RegisterFunction("mm256_loadu_si256", (Func<object, object>)mm256_loadu_si256);
            RegisterFunction("mm256_maskload_pd", (Func<object, object, object>)mm256_maskload_pd);
            RegisterFunction("mm256_maskload_ps", (Func<object, object, object>)mm256_maskload_ps);
            RegisterAction("mm256_maskstore_pd", (Action<object, object, object>)mm256_maskstore_pd);
            RegisterAction("mm256_maskstore_ps", (Action<object, object, object>)mm256_maskstore_ps);
            RegisterFunction("mm256_max_pd", (Func<object, object, object>)mm256_max_pd);
            RegisterFunction("mm256_max_ps", (Func<object, object, object>)mm256_max_ps);
            RegisterFunction("mm256_min_pd", (Func<object, object, object>)mm256_min_pd);
            RegisterFunction("mm256_min_ps", (Func<object, object, object>)mm256_min_ps);
            RegisterFunction("mm256_movedup_pd", (Func<object, object>)mm256_movedup_pd);
            RegisterFunction("mm256_movehdup_ps", (Func<object, object>)mm256_movehdup_ps);
            RegisterFunction("mm256_moveldup_ps", (Func<object, object>)mm256_moveldup_ps);
            RegisterFunction("mm256_movemask_pd", (Func<object, int>)mm256_movemask_pd);
            RegisterFunction("mm256_movemask_ps", (Func<object, int>)mm256_movemask_ps);
            RegisterFunction("mm256_mul_pd", (Func<object, object, object>)mm256_mul_pd);
            RegisterFunction("mm256_mul_ps", (Func<object, object, object>)mm256_mul_ps);
            RegisterFunction("mm256_or_pd", (Func<object, object, object>)mm256_or_pd);
            RegisterFunction("mm256_or_ps", (Func<object, object, object>)mm256_or_ps);
            RegisterFunction("mm256_permute_pd", (Func<object, byte, object>)mm256_permute_pd);
            RegisterFunction("mm256_permute_ps", (Func<object, byte, object>)mm256_permute_ps);
            RegisterFunction("mm256_permute2f128_pd", (Func<object, object, byte, object>)mm256_permute2f128_pd);
            RegisterFunction("mm256_permute2f128_ps", (Func<object, object, byte, object>)mm256_permute2f128_ps);
            RegisterFunction("mm256_permute2f128_si256", (Func<object, object, byte, object>)mm256_permute2f128_si256);
            RegisterFunction("mm256_permutevar_pd", (Func<object, object, object>)mm256_permutevar_pd);
            RegisterFunction("mm256_permutevar_ps", (Func<object, object, object>)mm256_permutevar_ps);
            RegisterFunction("mm256_rcp_ps", (Func<object, object>)mm256_rcp_ps);
            RegisterFunction("mm256_round_pd1", (Func<object, object>)mm256_round_pd1);
            RegisterFunction("mm256_round_pd1_to_nearest_integer", (Func<object, object>)mm256_round_pd1_to_nearest_integer);
            RegisterFunction("mm256_round_pd1_to_negative_infinity", (Func<object, object>)mm256_round_pd1_to_negative_infinity);
            RegisterFunction("mm256_round_pd1_to_positive_infinity", (Func<object, object>)mm256_round_pd1_to_positive_infinity);
            RegisterFunction("mm256_round_pd1_to_zero", (Func<object, object>)mm256_round_pd1_to_zero);
            RegisterFunction("mm256_round_ps", (Func<object, object>)mm256_round_ps);
            RegisterFunction("mm256_round_ps_to_nearest_integer", (Func<object, object>)mm256_round_ps_to_nearest_integer);
            RegisterFunction("mm256_round_ps_to_negative_infinity", (Func<object, object>)mm256_round_ps_to_negative_infinity);
            RegisterFunction("mm256_round_ps_to_positive_infinity", (Func<object, object>)mm256_round_ps_to_positive_infinity);
            RegisterFunction("mm256_round_ps_to_zero", (Func<object, object>)mm256_round_ps_to_zero);
            RegisterFunction("mm256_rsqrt_ps", (Func<object, object>)mm256_rsqrt_ps);
            RegisterFunction("mm256_shuffle_pd", (Func<object, object, byte, object>)mm256_shuffle_pd);
            RegisterFunction("mm256_shuffle_ps", (Func<object, object, byte, object>)mm256_shuffle_ps);
            RegisterFunction("mm256_sqrt_pd", (Func<object, object>)mm256_sqrt_pd);
            RegisterFunction("mm256_sqrt_ps", (Func<object, object>)mm256_sqrt_ps);
            RegisterAction("mm256_store_pd", (Action<object, object>)mm256_store_pd);
            RegisterAction("mm256_store_ps", (Action<object, object>)mm256_store_ps);
            RegisterAction("mm256_store_si256", (Action<object, object>)mm256_store_si256);
            RegisterAction("mm256_storeu_pd", (Action<object, object>)mm256_storeu_pd);
            RegisterAction("mm256_storeu_ps", (Action<object, object>)mm256_storeu_ps);
            RegisterAction("mm256_storeu_si256", (Action<object, object>)mm256_storeu_si256);
            RegisterAction("mm256_stream_pd", (Action<object, object>)mm256_stream_pd);
            RegisterAction("mm256_stream_ps", (Action<object, object>)mm256_stream_ps);
            RegisterAction("mm256_stream_si256", (Action<object, object>)mm256_stream_si256);
            RegisterFunction("mm256_sub_pd", (Func<object, object, object>)mm256_sub_pd);
            RegisterFunction("mm256_sub_ps", (Func<object, object, object>)mm256_sub_ps);
            RegisterFunction("mm256_testc_pd", (Func<object, object, Kalk.Core.KalkBool>)mm256_testc_pd);
            RegisterFunction("mm256_testc_ps", (Func<object, object, Kalk.Core.KalkBool>)mm256_testc_ps);
            RegisterFunction("mm256_testc_si256", (Func<object, object, Kalk.Core.KalkBool>)mm256_testc_si256);
            RegisterFunction("mm256_testnzc_pd", (Func<object, object, Kalk.Core.KalkBool>)mm256_testnzc_pd);
            RegisterFunction("mm256_testnzc_ps", (Func<object, object, Kalk.Core.KalkBool>)mm256_testnzc_ps);
            RegisterFunction("mm256_testnzc_si256", (Func<object, object, Kalk.Core.KalkBool>)mm256_testnzc_si256);
            RegisterFunction("mm256_testz_pd", (Func<object, object, Kalk.Core.KalkBool>)mm256_testz_pd);
            RegisterFunction("mm256_testz_ps", (Func<object, object, Kalk.Core.KalkBool>)mm256_testz_ps);
            RegisterFunction("mm256_testz_si256", (Func<object, object, Kalk.Core.KalkBool>)mm256_testz_si256);
            RegisterFunction("mm256_unpackhi_pd", (Func<object, object, object>)mm256_unpackhi_pd);
            RegisterFunction("mm256_unpackhi_ps", (Func<object, object, object>)mm256_unpackhi_ps);
            RegisterFunction("mm256_unpacklo_pd", (Func<object, object, object>)mm256_unpacklo_pd);
            RegisterFunction("mm256_unpacklo_ps", (Func<object, object, object>)mm256_unpacklo_ps);
            RegisterFunction("mm256_xor_pd", (Func<object, object, object>)mm256_xor_pd);
            RegisterFunction("mm256_xor_ps", (Func<object, object, object>)mm256_xor_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_broadcast_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Broadcast a single-precision (32-bit) floating-point element from memory to all elements of ""dst"".
    
    __m128 _mm_broadcast_ss (float const * mem_addr)
    VBROADCASTSS xmm, m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmp_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" based on the comparison operand specified by ""imm8"", and store the results in ""dst"".
    
    __m128d _mm_cmp_pd (__m128d a, __m128d b, const int imm8)
    VCMPPD xmm, xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" based on the comparison operand specified by ""imm8"", and store the results in ""dst"".
    
    __m128 _mm_cmp_ps (__m128 a, __m128 b, const int imm8)
    VCMPPS xmm, xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmp_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" based on the comparison operand specified by ""imm8"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmp_sd (__m128d a, __m128d b, const int imm8)
    VCMPSS xmm, xmm, xmm/m32, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmp_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" based on the comparison operand specified by ""imm8"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmp_ss (__m128 a, __m128 b, const int imm8)
    VCMPSD xmm, xmm, xmm/m64, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_maskload_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load packed double-precision (64-bit) floating-point elements from memory into ""dst"" using ""mask"" (elements are zeroed out when the high bit of the corresponding element is not set).
    
    __m128d _mm_maskload_pd (double const * mem_addr, __m128i mask)
    VMASKMOVPD xmm, xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_maskload_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load packed single-precision (32-bit) floating-point elements from memory into ""dst"" using ""mask"" (elements are zeroed out when the high bit of the corresponding element is not set).
    
    __m128 _mm_maskload_ps (float const * mem_addr, __m128i mask)
    VMASKMOVPS xmm, xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_maskstore_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store packed double-precision (64-bit) floating-point elements from ""a"" into memory using ""mask"".
    
    void _mm_maskstore_pd (double * mem_addr, __m128i mask, __m128d a)
    VMASKMOVPD m128, xmm, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_maskstore_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store packed single-precision (32-bit) floating-point elements from ""a"" into memory using ""mask"".
    
    void _mm_maskstore_ps (float * mem_addr, __m128i mask, __m128 a)
    VMASKMOVPS m128, xmm, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_permute_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle double-precision (64-bit) floating-point elements in ""a"" using the control in ""imm8"", and store the results in ""dst"".
    
    __m128d _mm_permute_pd (__m128d a, int imm8)
    VPERMILPD xmm, xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_permute_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" using the control in ""imm8"", and store the results in ""dst"".
    
    __m128 _mm_permute_ps (__m128 a, int imm8)
    VPERMILPS xmm, xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_permutevar_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle double-precision (64-bit) floating-point elements in ""a"" using the control in ""b"", and store the results in ""dst"".
    
    __m128d _mm_permutevar_pd (__m128d a, __m128i b)
    VPERMILPD xmm, xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_permutevar_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" using the control in ""b"", and store the results in ""dst"".
    
    __m128 _mm_permutevar_ps (__m128 a, __m128i b)
    VPERMILPS xmm, xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testc_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""CF"" value.
    
    int _mm_testc_pd (__m128d a, __m128d b)
    VTESTPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testc_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""CF"" value.
    
    int _mm_testc_ps (__m128 a, __m128 b)
    VTESTPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testnzc_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return 1 if both the ""ZF"" and ""CF"" values are zero, otherwise return 0.
    
    int _mm_testnzc_pd (__m128d a, __m128d b)
    VTESTPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testnzc_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return 1 if both the ""ZF"" and ""CF"" values are zero, otherwise return 0.
    
    int _mm_testnzc_ps (__m128 a, __m128 b)
    VTESTPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testz_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing double-precision (64-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""ZF"" value.
    
    int _mm_testz_pd (__m128d a, __m128d b)
    VTESTPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testz_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""ZF"" value.
    
    int _mm_testz_ps (__m128 a, __m128 b)
    VTESTPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_add_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Add packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256d _mm256_add_pd (__m256d a, __m256d b)
    VADDPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_add_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Add packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256 _mm256_add_ps (__m256 a, __m256 b)
    VADDPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_addsub_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Alternatively add and subtract packed double-precision (64-bit) floating-point elements in ""a"" to/from packed elements in ""b"", and store the results in ""dst"".
    
    __m256d _mm256_addsub_pd (__m256d a, __m256d b)
    VADDSUBPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_addsub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Alternatively add and subtract packed single-precision (32-bit) floating-point elements in ""a"" to/from packed elements in ""b"", and store the results in ""dst"".
    
    __m256 _mm256_addsub_ps (__m256 a, __m256 b)
    VADDSUBPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_and_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256d _mm256_and_pd (__m256d a, __m256d b)
    VANDPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_and_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256 _mm256_and_ps (__m256 a, __m256 b)
    VANDPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_andnot_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise NOT of packed double-precision (64-bit) floating-point elements in ""a"" and then AND with ""b"", and store the results in ""dst"".
    
    __m256d _mm256_andnot_pd (__m256d a, __m256d b)
    VANDNPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_andnot_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in ""a"" and then AND with ""b"", and store the results in ""dst"".
    
    __m256 _mm256_andnot_ps (__m256 a, __m256 b)
    VANDNPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_blend_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Blend packed double-precision (64-bit) floating-point elements from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".
    
    __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8)
    VBLENDPD ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_blend_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Blend packed single-precision (32-bit) floating-point elements from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".
    
    __m256 _mm256_blend_ps (__m256 a, __m256 b, const int imm8)
    VBLENDPS ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_blendv_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Blend packed double-precision (64-bit) floating-point elements from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".
    
    __m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)
    VBLENDVPD ymm, ymm, ymm/m256, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_blendv_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Blend packed single-precision (32-bit) floating-point elements from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".
    
    __m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask)
    VBLENDVPS ymm, ymm, ymm/m256, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcast_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Broadcast 128 bits from memory (composed of 2 packed double-precision (64-bit) floating-point elements) to all elements of ""dst"".
    
    __m256d _mm256_broadcast_pd (__m128d const * mem_addr)
    VBROADCASTF128, ymm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcast_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Broadcast 128 bits from memory (composed of 4 packed single-precision (32-bit) floating-point elements) to all elements of ""dst"".
    
    __m256 _mm256_broadcast_ps (__m128 const * mem_addr)
    VBROADCASTF128, ymm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcast_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Broadcast a double-precision (64-bit) floating-point element from memory to all elements of ""dst"".
    
    __m256d _mm256_broadcast_sd (double const * mem_addr)
    VBROADCASTSD ymm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_broadcast_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Broadcast a single-precision (32-bit) floating-point element from memory to all elements of ""dst"".
    
    __m256 _mm256_broadcast_ss (float const * mem_addr)
    VBROADCASTSS ymm, m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_ceil_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" up to an integer value, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m256d _mm256_ceil_pd (__m256d a)
    VROUNDPD ymm, ymm/m256, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_ceil_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" up to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m256 _mm256_ceil_ps (__m256 a)
    VROUNDPS ymm, ymm/m256, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmp_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" based on the comparison operand specified by ""imm8"", and store the results in ""dst"".
    
    __m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8)
    VCMPPD ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" based on the comparison operand specified by ""imm8"", and store the results in ""dst"".
    
    __m256 _mm256_cmp_ps (__m256 a, __m256 b, const int imm8)
    VCMPPS ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpeq_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpeq_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(0)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpeq_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpeq_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(0)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpge_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpge_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(13)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpge_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpge_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(13)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpgt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpgt_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(14)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpgt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpgt_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(14)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmple_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmple_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(2)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmple_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmple_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(2)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmplt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmplt_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(1)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmplt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmplt_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(1)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpneq_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpneq_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(4)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpneq_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpneq_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(4)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpnge_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpnge_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(9)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpnge_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpnge_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(9)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpngt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpngt_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(10)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpngt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpngt_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(10)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpnle_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpnle_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(6)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpnle_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpnle_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(6)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpnlt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpnlt_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(5)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpnlt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpnlt_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(5)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpord_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpord_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(7)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpord_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpord_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(7)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpunord_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256d _mm256_cmpunord_pd (__m256d a,  __m256d b) CMPPD ymm, ymm/m256, imm8(3)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cmpunord_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"__m256 _mm256_cmpunord_ps (__m256 a,  __m256 b) CMPPS ymm, ymm/m256, imm8(3)
    The above native signature does not exist. We provide this additional overload for completeness.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepi32_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed 32-bit integers in ""a"" to packed double-precision (64-bit) floating-point elements, and store the results in ""dst"".
    
    __m256d _mm256_cvtepi32_pd (__m128i a)
    VCVTDQ2PD ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtepi32_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed 32-bit integers in ""a"" to packed single-precision (32-bit) floating-point elements, and store the results in ""dst"".
    
    __m256 _mm256_cvtepi32_ps (__m256i a)
    VCVTDQ2PS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtpd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m128i _mm256_cvtpd_epi32 (__m256d a)
    VCVTPD2DQ xmm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtpd_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed single-precision (32-bit) floating-point elements, and store the results in ""dst"".
    
    __m128 _mm256_cvtpd_ps (__m256d a)
    VCVTPD2PS xmm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtps_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m256i _mm256_cvtps_epi32 (__m256 a)
    VCVTPS2DQ ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvtps_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed double-precision (64-bit) floating-point elements, and store the results in ""dst"".
    
    __m256d _mm256_cvtps_pd (__m128 a)
    VCVTPS2PD ymm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvttpd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed 32-bit integers with truncation, and store the results in ""dst"".
    
    __m128i _mm256_cvttpd_epi32 (__m256d a)
    VCVTTPD2DQ xmm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_cvttps_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed 32-bit integers with truncation, and store the results in ""dst"".
    
    __m256i _mm256_cvttps_epi32 (__m256 a)
    VCVTTPS2DQ ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_div_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Divide packed double-precision (64-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".
    
    __m256d _mm256_div_pd (__m256d a, __m256d b)
    VDIVPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_div_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Divide packed single-precision (32-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".
    
    __m256 _mm256_div_ps (__m256 a, __m256 b)
    VDIVPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_dp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Conditionally multiply the packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" using the high 4 bits in ""imm8"", sum the four products, and conditionally store the sum in ""dst"" using the low 4 bits of ""imm8"".
    
    __m256 _mm256_dp_ps (__m256 a, __m256 b, const int imm8)
    VDPPS ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_extractf128_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Extract 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from ""a"", selected with ""imm8"", and store the result in ""dst"".
    
    __m128d _mm256_extractf128_pd (__m256d a, const int imm8)
    VEXTRACTF128 xmm/m128, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_extractf128_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Extract 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from ""a"", selected with ""imm8"", and store the result in ""dst"".
    
    __m128 _mm256_extractf128_ps (__m256 a, const int imm8)
    VEXTRACTF128 xmm/m128, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_extractf128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Extract 128 bits (composed of integer data) from ""a"", selected with ""imm8"", and store the result in ""dst"".
    
    __m128i _mm256_extractf128_si256 (__m256i a, const int imm8)
    VEXTRACTF128 xmm/m128, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_floor_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" down to an integer value, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m256d _mm256_floor_pd (__m256d a)
    VROUNDPS ymm, ymm/m256, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_floor_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" down to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m256 _mm256_floor_ps (__m256 a)
    VROUNDPS ymm, ymm/m256, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hadd_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Horizontally add adjacent pairs of double-precision (64-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".
    
    __m256d _mm256_hadd_pd (__m256d a, __m256d b)
    VHADDPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hadd_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".
    
    __m256 _mm256_hadd_ps (__m256 a, __m256 b)
    VHADDPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hsub_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Horizontally subtract adjacent pairs of double-precision (64-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".
    
    __m256d _mm256_hsub_pd (__m256d a, __m256d b)
    VHSUBPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_hsub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".
    
    __m256 _mm256_hsub_ps (__m256 a, __m256 b)
    VHSUBPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_insertf128_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Copy ""a"" to ""dst"", then insert 128 bits (composed of 2 packed double-precision (64-bit) floating-point elements) from ""b"" into ""dst"" at the location specified by ""imm8"".
    
    __m256d _mm256_insertf128_pd (__m256d a, __m128d b, int imm8)
    VINSERTF128 ymm, ymm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_insertf128_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Copy ""a"" to ""dst"", then insert 128 bits (composed of 4 packed single-precision (32-bit) floating-point elements) from ""b"" into ""dst"" at the location specified by ""imm8"".
    
    __m256 _mm256_insertf128_ps (__m256 a, __m128 b, int imm8)
    VINSERTF128 ymm, ymm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_insertf128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Copy ""a"" to ""dst"", then insert 128 bits from ""b"" into ""dst"" at the location specified by ""imm8"".
    
    __m256i _mm256_insertf128_si256 (__m256i a, __m128i b, int imm8)
    VINSERTF128 ymm, ymm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_lddqu_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load 256-bits of integer data from unaligned memory into ""dst"". This intrinsic may perform better than ""_mm256_loadu_si256"" when the data crosses a cache line boundary.
    
    __m256i _mm256_lddqu_si256 (__m256i const * mem_addr)
    VLDDQU ymm, m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_load_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into ""dst"".
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    __m256d _mm256_load_pd (double const * mem_addr)
    VMOVAPD ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_load_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into ""dst"".
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    __m256 _mm256_load_ps (float const * mem_addr)
    VMOVAPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_load_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load 256-bits of integer data from memory into ""dst"".
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    __m256i _mm256_load_si256 (__m256i const * mem_addr)
    VMOVDQA ymm, m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_loadu_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from memory into ""dst"".
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m256d _mm256_loadu_pd (double const * mem_addr)
    VMOVUPD ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_loadu_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from memory into ""dst"".
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m256 _mm256_loadu_ps (float const * mem_addr)
    VMOVUPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_loadu_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load 256-bits of integer data from memory into ""dst"".
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m256i _mm256_loadu_si256 (__m256i const * mem_addr)
    VMOVDQU ymm, m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_maskload_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load packed double-precision (64-bit) floating-point elements from memory into ""dst"" using ""mask"" (elements are zeroed out when the high bit of the corresponding element is not set).
    
    __m256d _mm256_maskload_pd (double const * mem_addr, __m256i mask)
    VMASKMOVPD ymm, ymm, m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_maskload_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Load packed single-precision (32-bit) floating-point elements from memory into ""dst"" using ""mask"" (elements are zeroed out when the high bit of the corresponding element is not set).
    
    __m256 _mm256_maskload_ps (float const * mem_addr, __m256i mask)
    VMASKMOVPS ymm, ymm, m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_maskstore_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store packed double-precision (64-bit) floating-point elements from ""a"" into memory using ""mask"".
    
    void _mm256_maskstore_pd (double * mem_addr, __m256i mask, __m256d a)
    VMASKMOVPD m256, ymm, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_maskstore_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store packed single-precision (32-bit) floating-point elements from ""a"" into memory using ""mask"".
    
    void _mm256_maskstore_ps (float * mem_addr, __m256i mask, __m256 a)
    VMASKMOVPS m256, ymm, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_max_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m256d _mm256_max_pd (__m256d a, __m256d b)
    VMAXPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_max_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m256 _mm256_max_ps (__m256 a, __m256 b)
    VMAXPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_min_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m256d _mm256_min_pd (__m256d a, __m256d b)
    VMINPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_min_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m256 _mm256_min_ps (__m256 a, __m256 b)
    VMINPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_movedup_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Duplicate even-indexed double-precision (64-bit) floating-point elements from ""a"", and store the results in ""dst"".
    
    __m256d _mm256_movedup_pd (__m256d a)
    VMOVDDUP ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_movehdup_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Duplicate odd-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".
    
    __m256 _mm256_movehdup_ps (__m256 a)
    VMOVSHDUP ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_moveldup_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Duplicate even-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".
    
    __m256 _mm256_moveldup_ps (__m256 a)
    VMOVSLDUP ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_movemask_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Set each bit of mask ""dst"" based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in ""a"".
    
    int _mm256_movemask_pd (__m256d a)
    VMOVMSKPD reg, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_movemask_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Set each bit of mask ""dst"" based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in ""a"".
    
    int _mm256_movemask_ps (__m256 a)
    VMOVMSKPS reg, ymm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mul_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Multiply packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256d _mm256_mul_pd (__m256d a, __m256d b)
    VMULPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_mul_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Multiply packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256 _mm256_mul_ps (__m256 a, __m256 b)
    VMULPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_or_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise OR of packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256d _mm256_or_pd (__m256d a, __m256d b)
    VORPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_or_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256 _mm256_or_ps (__m256 a, __m256 b)
    VORPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permute_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle double-precision (64-bit) floating-point elements in ""a"" within 128-bit lanes using the control in ""imm8"", and store the results in ""dst"".
    
    __m256d _mm256_permute_pd (__m256d a, int imm8)
    VPERMILPD ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permute_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" within 128-bit lanes using the control in ""imm8"", and store the results in ""dst"".
    
    __m256 _mm256_permute_ps (__m256 a, int imm8)
    VPERMILPS ymm, ymm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permute2f128_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) selected by ""imm8"" from ""a"" and ""b"", and store the results in ""dst"".
    
    __m256d _mm256_permute2f128_pd (__m256d a, __m256d b, int imm8)
    VPERM2F128 ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permute2f128_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) selected by ""imm8"" from ""a"" and ""b"", and store the results in ""dst"".
    
    __m256 _mm256_permute2f128_ps (__m256 a, __m256 b, int imm8)
    VPERM2F128 ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permute2f128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle 128-bits (composed of integer data) selected by ""imm8"" from ""a"" and ""b"", and store the results in ""dst"".
    
    __m256i _mm256_permute2f128_si256 (__m256i a, __m256i b, int imm8)
    VPERM2F128 ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permutevar_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle double-precision (64-bit) floating-point elements in ""a"" within 128-bit lanes using the control in ""b"", and store the results in ""dst"".
    
    __m256d _mm256_permutevar_pd (__m256d a, __m256i b)
    VPERMILPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_permutevar_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" within 128-bit lanes using the control in ""b"", and store the results in ""dst"".
    
    __m256 _mm256_permutevar_ps (__m256 a, __m256i b)
    VPERMILPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_rcp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.
    
    __m256 _mm256_rcp_ps (__m256 a)
    VRCPPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_pd1"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m256d _mm256_round_pd (__m256d a, _MM_FROUND_CUR_DIRECTION)
    VROUNDPD ymm, ymm/m256, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_pd1_to_nearest_integer"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
    VROUNDPD ymm, ymm/m256, imm8(8)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_pd1_to_negative_infinity"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
    VROUNDPD ymm, ymm/m256, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_pd1_to_positive_infinity"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
    VROUNDPD ymm, ymm/m256, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_pd1_to_zero"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m256d _mm256_round_pd (__m256d a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
    VROUNDPD ymm, ymm/m256, imm8(11)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m256 _mm256_round_ps (__m256 a, _MM_FROUND_CUR_DIRECTION)
    VROUNDPS ymm, ymm/m256, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_ps_to_nearest_integer"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
    VROUNDPS ymm, ymm/m256, imm8(8)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_ps_to_negative_infinity"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
    VROUNDPS ymm, ymm/m256, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_ps_to_positive_infinity"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
    VROUNDPS ymm, ymm/m256, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_round_ps_to_zero"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m256 _mm256_round_ps (__m256 a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
    VROUNDPS ymm, ymm/m256, imm8(11)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_rsqrt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.
    
    __m256 _mm256_rsqrt_ps (__m256 a)
    VRSQRTPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_shuffle_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle double-precision (64-bit) floating-point elements within 128-bit lanes using the control in ""imm8"", and store the results in ""dst"".
    
    __m256d _mm256_shuffle_pd (__m256d a, __m256d b, const int imm8)
    VSHUFPD ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_shuffle_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" within 128-bit lanes using the control in ""imm8"", and store the results in ""dst"".
    
    __m256 _mm256_shuffle_ps (__m256 a, __m256 b, const int imm8)
    VSHUFPS ymm, ymm, ymm/m256, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sqrt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the square root of packed double-precision (64-bit) floating-point elements in ""a"", and store the results in ""dst"".
    
    __m256d _mm256_sqrt_pd (__m256d a)
    VSQRTPD ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sqrt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".
    
    __m256 _mm256_sqrt_ps (__m256 a)
    VSQRTPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_store_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from ""a"" into memory.
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    void _mm256_store_pd (double * mem_addr, __m256d a)
    VMOVAPD m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_store_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from ""a"" into memory.
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    void _mm256_store_ps (float * mem_addr, __m256 a)
    VMOVAPS m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_store_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits of integer data from ""a"" into memory.
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    void _mm256_store_si256 (__m256i * mem_addr, __m256i a)
    MOVDQA m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_storeu_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from ""a"" into memory.
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm256_storeu_pd (double * mem_addr, __m256d a)
    MOVUPD m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_storeu_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from ""a"" into memory.
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm256_storeu_ps (float * mem_addr, __m256 a)
    MOVUPS m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_storeu_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits of integer data from ""a"" into memory.
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a)
    MOVDQU m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_stream_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits (composed of 4 packed double-precision (64-bit) floating-point elements) from ""a"" into memory using a non-temporal memory hint.
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    void _mm256_stream_pd (double * mem_addr, __m256d a)
    MOVNTPD m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_stream_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits (composed of 8 packed single-precision (32-bit) floating-point elements) from ""a"" into memory using a non-temporal memory hint.
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    void _mm256_stream_ps (float * mem_addr, __m256 a)
    MOVNTPS m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_stream_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Store 256-bits of integer data from ""a"" into memory using a non-temporal memory hint.
    	""mem_addr"" must be aligned on a 32-byte boundary or a general-protection exception may be generated.
    
    void _mm256_stream_si256 (__m256i * mem_addr, __m256i a)
    VMOVNTDQ m256, ymm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm256_sub_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Subtract packed double-precision (64-bit) floating-point elements in ""b"" from packed double-precision (64-bit) floating-point elements in ""a"", and store the results in ""dst"".
    
    __m256d _mm256_sub_pd (__m256d a, __m256d b)
    VSUBPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_sub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Subtract packed single-precision (32-bit) floating-point elements in ""b"" from packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".
    
    __m256 _mm256_sub_ps (__m256 a, __m256 b)
    VSUBPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testc_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 256-bit value, and set ""ZF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""CF"" value.
    
    int _mm256_testc_pd (__m256d a, __m256d b)
    VTESTPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testc_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 256-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""CF"" value.
    
    int _mm256_testc_ps (__m256 a, __m256 b)
    VTESTPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testc_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return the ""CF"" value.
    
    int _mm256_testc_si256 (__m256i a, __m256i b)
    VPTEST ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testnzc_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 256-bit value, and set ""ZF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return 1 if both the ""ZF"" and ""CF"" values are zero, otherwise return 0.
    
    int _mm256_testnzc_pd (__m256d a, __m256d b)
    VTESTPD ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testnzc_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 256-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return 1 if both the ""ZF"" and ""CF"" values are zero, otherwise return 0.
    
    int _mm256_testnzc_ps (__m256 a, __m256 b)
    VTESTPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testnzc_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return 1 if both the ""ZF"" and ""CF"" values are zero, otherwise return 0.
    
    int _mm256_testnzc_si256 (__m256i a, __m256i b)
    VPTEST ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testz_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing double-precision (64-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 256-bit value, and set ""ZF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 64-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""ZF"" value.
    
    int _mm256_testz_pd (__m256d a, __m256d b)
    VTESTPD ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testz_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 256-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""ZF"" value.
    
    int _mm256_testz_ps (__m256 a, __m256 b)
    VTESTPS ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_testz_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return the ""ZF"" value.
    
    int _mm256_testz_si256 (__m256i a, __m256i b)
    VPTEST ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Unpack and interleave double-precision (64-bit) floating-point elements from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256d _mm256_unpackhi_pd (__m256d a, __m256d b)
    VUNPCKHPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256 _mm256_unpackhi_ps (__m256 a, __m256 b)
    VUNPCKHPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Unpack and interleave double-precision (64-bit) floating-point elements from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256d _mm256_unpacklo_pd (__m256d a, __m256d b)
    VUNPCKLPD ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256 _mm256_unpacklo_ps (__m256 a, __m256 b)
    VUNPCKLPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_xor_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise XOR of packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256d _mm256_xor_pd (__m256d a, __m256d b)
    VXORPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm256_xor_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m256 _mm256_xor_ps (__m256 a, __m256 b)
    VXORPS ymm, ymm, ymm/m256";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi1IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("andn_u32", (Func<uint, uint, uint>)andn_u32);
            RegisterFunction("bextr_u32", (Func<uint, byte, byte, uint>)bextr_u32);
            RegisterFunction("bextr2_u32", (Func<uint, ushort, uint>)bextr2_u32);
            RegisterFunction("blsi_u32", (Func<uint, uint>)blsi_u32);
            RegisterFunction("blsmsk_u32", (Func<uint, uint>)blsmsk_u32);
            RegisterFunction("blsr_u32", (Func<uint, uint>)blsr_u32);
            RegisterFunction("mm_tzcnt_32", (Func<uint, uint>)mm_tzcnt_32);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["andn_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _andn_u32 (unsigned int a, unsigned int b)
    ANDN r32a, r32b, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bextr_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _bextr_u32 (unsigned int a, unsigned int start, unsigned int len)
    BEXTR r32a, reg/m32, r32b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bextr2_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _bextr2_u32 (unsigned int a, unsigned int control)
    BEXTR r32a, reg/m32, r32b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsi_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _blsi_u32 (unsigned int a)
    BLSI reg, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsmsk_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _blsmsk_u32 (unsigned int a)
    BLSMSK reg, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsr_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _blsr_u32 (unsigned int a)
    BLSR reg, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_tzcnt_32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"int _mm_tzcnt_32 (unsigned int a)
    TZCNT reg, reg/m32";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi1X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("andn_u64", (Func<ulong, ulong, ulong>)andn_u64);
            RegisterFunction("bextr_u64", (Func<ulong, byte, byte, ulong>)bextr_u64);
            RegisterFunction("bextr2_u64", (Func<ulong, ushort, ulong>)bextr2_u64);
            RegisterFunction("blsi_u64", (Func<ulong, ulong>)blsi_u64);
            RegisterFunction("blsmsk_u64", (Func<ulong, ulong>)blsmsk_u64);
            RegisterFunction("blsr_u64", (Func<ulong, ulong>)blsr_u64);
            RegisterFunction("mm_tzcnt_64", (Func<ulong, ulong>)mm_tzcnt_64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["andn_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _andn_u64 (unsigned __int64 a, unsigned __int64 b)
    ANDN r64a, r64b, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bextr_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _bextr_u64 (unsigned __int64 a, unsigned int start, unsigned int len)
    BEXTR r64a, reg/m64, r64b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bextr2_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _bextr2_u64 (unsigned __int64 a, unsigned __int64 control)
    BEXTR r64a, reg/m64, r64b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsi_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _blsi_u64 (unsigned __int64 a)
    BLSI reg, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsmsk_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _blsmsk_u64 (unsigned __int64 a)
    BLSMSK reg, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsr_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _blsr_u64 (unsigned __int64 a)
    BLSR reg, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_tzcnt_64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"__int64 _mm_tzcnt_64 (unsigned __int64 a)
    TZCNT reg, reg/m64";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi2IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("bzhi_u32", (Func<uint, uint, uint>)bzhi_u32);
            RegisterFunction("mulx_u32", (Func<uint, uint, uint>)mulx_u32);
            RegisterFunction("pdep_u32", (Func<uint, uint, uint>)pdep_u32);
            RegisterFunction("pext_u32", (Func<uint, uint, uint>)pext_u32);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["bzhi_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned int _bzhi_u32 (unsigned int a, unsigned int index)
    BZHI r32a, reg/m32, r32b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mulx_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned int _mulx_u32 (unsigned int a, unsigned int b, unsigned int* hi)
    MULX r32a, r32b, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pdep_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned int _pdep_u32 (unsigned int a, unsigned int mask)
    PDEP r32a, r32b, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pext_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned int _pext_u32 (unsigned int a, unsigned int mask)
    PEXT r32a, r32b, reg/m32";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi2X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("bzhi_u64", (Func<ulong, ulong, ulong>)bzhi_u64);
            RegisterFunction("mulx_u64", (Func<ulong, ulong, ulong>)mulx_u64);
            RegisterFunction("pdep_u64", (Func<ulong, ulong, ulong>)pdep_u64);
            RegisterFunction("pext_u64", (Func<ulong, ulong, ulong>)pext_u64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["bzhi_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned __int64 _bzhi_u64 (unsigned __int64 a, unsigned int index)
    BZHI r64a, reg/m32, r64b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mulx_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned __int64 _mulx_u64 (unsigned __int64 a, unsigned __int64 b, unsigned __int64* hi)
    MULX r64a, r64b, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pdep_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned __int64 _pdep_u64 (unsigned __int64 a, unsigned __int64 mask)
    PDEP r64a, r64b, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pext_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned __int64 _pext_u64 (unsigned __int64 a, unsigned __int64 mask)
    PEXT r64a, r64b, reg/m64";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class CsvModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("parse_csv", (Func<string, bool, Scriban.Runtime.ScriptRange>)ParseCsv);
            RegisterFunction("load_csv", (Func<string, bool, Scriban.Runtime.ScriptRange>)LoadCsv);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["parse_csv"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"Parse the specified text as a CSV, returning each CSV line in an array.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("text", @"The text to parse.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("headers", @"true if the text to parse has CSV headers. Default is fault.")  { IsOptional = true });
                descriptor.Returns = @"An array of CSV columns values.";
                descriptor.Example = @"    >>> items = parse_csv(""a,b,c\n1,2,3\n4,5,6\n"")
    # items = parse_csv(""a,b,c\n1,2,3\n4,5,6\n"")
    items = [[1, 2, 3], [4, 5, 6]]
    >>> items[0].a
    # items[0].a
    out = 1
    >>> items[0].b
    # items[0].b
    out = 2
    >>> items[0].c
    # items[0].c
    out = 3
";
            }
            {
                var descriptor = Descriptors["load_csv"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"Loads the specified file as a CSV, returning each CSV line in an array.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("path", @"The file path to load and parse as CSV.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("headers", @"true if the file to parse has CSV headers. Default is fault.")  { IsOptional = true });
                descriptor.Returns = @"An array of CSV columns values.";
                descriptor.Example = @"    >>> items = load_csv(""test.csv"")
    # items = load_csv(""test.csv"")
    items = [[1, 2, 3], [4, 5, 6]]
    >>> items[0].a
    # items[0].a
    out = 1
    >>> items[1].a
    # items[1].a
    out = 4
    >>> items[1].c
    # items[1].c
    out = 6
";
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class CurrencyModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterConstant("currencies", Currencies);
            RegisterFunction("currency", (Func<Scriban.Syntax.ScriptVariable, decimal?, Kalk.Core.KalkCurrency>)Currency);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["currencies"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["currency"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class FileModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("file_exists", (Func<string, Kalk.Core.KalkBool>)FileExists);
            RegisterFunction("directory_exists", (Func<string, Kalk.Core.KalkBool>)DirectoryExists);
            RegisterFunction("dir", (Func<string, bool, System.Collections.IEnumerable>)DirectoryListing);
            RegisterFunction("load_text", (Func<string, string, string>)LoadText);
            RegisterFunction("load_bytes", (Func<string, Kalk.Core.KalkNativeBuffer>)LoadBytes);
            RegisterFunction("load_lines", (Func<string, string, Scriban.Runtime.ScriptRange>)LoadLines);
            RegisterFunction("save_lines", (Func<System.Collections.IEnumerable, string, string, object>)SaveLines);
            RegisterFunction("save_text", (Func<string, string, string, object>)SaveText);
            RegisterFunction("save_bytes", (Func<System.Collections.IEnumerable, string, object>)SaveBytes);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["file_exists"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["directory_exists"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["dir"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["load_text"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["load_bytes"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["load_lines"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["save_lines"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["save_text"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["save_bytes"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core
{
    public partial class KalkEngine
    {
        protected void RegisterFunctionsAuto()
        {
            RegisterConstant("config", Config);
            RegisterConstant("aliases", Aliases);
            RegisterConstant("units", Units);
            RegisterConstant("shortcuts", Shortcuts);
            RegisterFunction("date", (Func<string[], object>)Date);
            RegisterFunction("clipboard", (Func<object, object>)Clipboard);
            RegisterAction("display", (Action<Scriban.Syntax.ScriptVariable>)Display);
            RegisterAction("echo", (Action<Scriban.Syntax.ScriptVariable>)Echo);
            RegisterAction("print", (Action<object>)Print);
            RegisterAction("printh", (Action<object>)Printh);
            RegisterAction("help", (Action<Scriban.Syntax.ScriptExpression>)Help);
            RegisterAction("reset", (Action)Reset);
            RegisterAction("version", (Action)ShowVersion);
            RegisterAction("list", (Action)List);
            RegisterAction("del", (Action<Scriban.Syntax.ScriptVariable>)DeleteVariable);
            RegisterAction("exit", (Action)Exit);
            RegisterAction("history", (Action<object>)History);
            RegisterFunction("eval", (Func<string, bool, object>)EvaluateText);
            RegisterFunction("load", (Func<string, bool, object>)LoadFile);
            RegisterAction("clear", (Action<Scriban.Syntax.ScriptExpression>)Clear);
            RegisterAction("cls", (Action)Cls);
            RegisterFunction("out", (Func<object>)Last);
            RegisterAction("out2clipboard", (Action)LastToClipboard);
            RegisterAction("shortcut", (Action<Scriban.Syntax.ScriptVariable, Scriban.Syntax.ScriptExpression[]>)Shortcut);
            RegisterAction("alias", (Action<Scriban.Syntax.ScriptVariable, Scriban.Syntax.ScriptVariable[]>)Alias);
            RegisterFunction("kind", (Func<object, string>)Kind);
            RegisterFunction("to", (Func<Kalk.Core.KalkExpression, Kalk.Core.KalkExpression, Kalk.Core.KalkExpression>)ConvertTo);
            RegisterFunction("unit", (Func<Scriban.Syntax.ScriptVariable, string, Scriban.Syntax.ScriptVariable, Kalk.Core.KalkExpression, string, string, Kalk.Core.KalkExpression>)DefineUserUnit);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["config"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets the config object.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["aliases"];
                descriptor.Category = "General";
                descriptor.Description = @"Displays all built-in and user-defined aliases.";
                descriptor.IsCommand = false;
                descriptor.Remarks = @"Aliases are usually used to define equivalent variable names for equivalent mathematical symbols. To create an alias, see the command `alias`.";
            }
            {
                var descriptor = Descriptors["units"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"If used in an expression, returns an object containing all units defined.
    Otherwise it will display units in a friendly format.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["shortcuts"];
                descriptor.Category = "General";
                descriptor.Description = @"Displays all built-in and user-defined keyboard shortcuts.";
                descriptor.IsCommand = false;
                descriptor.Remarks = @"To create an keyboard shortcut, see the command `shortcut`.";
            }
            {
                var descriptor = Descriptors["date"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets the date object";
                descriptor.IsCommand = false;
                descriptor.Returns = @"";
            }
            {
                var descriptor = Descriptors["clipboard"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets or sets the current content of the clipboard.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"Value to set the clipboard to. If not set, this function returns the current content of the clipboard.")  { IsOptional = true });
                descriptor.Returns = @"Returns the content of the clipboard.";
                descriptor.Remarks = @"On Unix platform, if you are running from WSL or from raw console, the clipboard is not supported.";
                descriptor.Example = @"    >>> clipboard ""text""
    # clipboard(""text"")
    out = ""text""
    >>> clipboard
    # clipboard
    out = ""text""
";
            }
            {
                var descriptor = Descriptors["display"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets or sets the display mode.
    
     - `std` for standard mode
     - `dev` for developer mode to display advanced details about integers, vectors and floating point values.
     - `eng` for engineering mode to display floating point values using 3 digits for the exponent.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("name", @"An optional parameter to set the display mode. Default is `std`. If this parameter is not set, this function will display the display mode currently used.")  { IsOptional = true });
                descriptor.Example = @"     >>> display
     # Display mode: std (Standard)
     >>> display dev
     # Display mode: dev (Developer)
     >>> 1.5
     # 1.5
     out = 1.5
         # IEEE 754 - double - 64-bit
         #
         = 0x_3FF80000_00000000
         = 0x____3____F____F____8____0____0____0____0____0____0____0____0____0____0____0____0
         #    seee eeee eeee ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff
         = 0b_0011_1111_1111_1000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000
         #   63                48                  32                  16                   0
         #
         # sign    exponent              |-------------------- fraction --------------------|
         =   1 * 2 ^ (1023 - 1023) * 0b1.1000000000000000000000000000000000000000000000000000
     >>> display invalid
     Invalid display name `invalid`. Expecting `std`, `dev` or `eng`. (Parameter 'name')
";
            }
            {
                var descriptor = Descriptors["echo"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets or sets the current echo mode.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"An optional `true`/`on` or `false`/`off` value to enable or disable the echo. A value of `false` will disable any output generated by a command except for the print commands. If this parameter is not set, this function will display the current display mode.")  { IsOptional = true });
                descriptor.Example = @"    >>> echo
    # Echo is on.
    >>> 1 + 2
    # 1 + 2
    out = 3
    >>> echo off
    >>> 1 + 2
    >>> echo
    >>> echo on
    # Echo is on.
    >>> 1 + 2
    # 1 + 2
    out = 3
";
            }
            {
                var descriptor = Descriptors["print"];
                descriptor.Category = "General";
                descriptor.Description = @"Prints the specified value to the output.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"A value to print to the output.")  { IsOptional = false });
                descriptor.Remarks = @"When the `echo` is off, this method will still output.";
                descriptor.Example = @"    >>> print ""kalk""
    kalk
    >>> echo off
    >>> print ""kalk2""
    kalk2
";
            }
            {
                var descriptor = Descriptors["printh"];
                descriptor.Category = "General";
                descriptor.Description = @"Prints the specified value to the output formatted with kalk syntax highlighting.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"A value to print to the output.")  { IsOptional = false });
                descriptor.Remarks = @"When the `echo` is off, this method will still output.";
                descriptor.Example = @"    >>> printh ""# This is a kalk comment""
    # This is a kalk comment
";
            }
            {
                var descriptor = Descriptors["help"];
                descriptor.Category = "General";
                descriptor.Description = @"Displays the documentation of the specified topic or function name.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("expression", @"An optional topic or function name. If this parameter is not set, it will display all available topics and functions.")  { IsOptional = true });
                descriptor.Example = @"    >>> help
    ... # Displays a list of function and topic names to get help from.
    >>> help alias
    ... # Displays the help for the `alias` function.
";
            }
            {
                var descriptor = Descriptors["reset"];
                descriptor.Category = "General";
                descriptor.Description = @"Removes all user-defined variables and functions.";
                descriptor.IsCommand = true;
                descriptor.Example = @"    >>> x = 5; y = 2
    # x = 5; y = 2
    x = 5
    y = 2
    >>> list
    # Variables
    x = 5
    y = 2
    >>> reset
    >>> list
    # No variables
";
            }
            {
                var descriptor = Descriptors["version"];
                descriptor.Category = "General";
                descriptor.Description = @"Prints the version of kalk.";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["list"];
                descriptor.Category = "General";
                descriptor.Description = @"Lists all user-defined variables and functions.";
                descriptor.IsCommand = true;
                descriptor.Example = @"    >>> x = 5; y = 2; f(x) = x + 5
    # x = 5; y = 2; f(x) = x + 5
    x = 5
    y = 2
     f(x) = x + 5
    >>> list
    # Variables
    x = 5
    y = 2
    # Functions
     f(x) = x + 5
";
            }
            {
                var descriptor = Descriptors["del"];
                descriptor.Category = "General";
                descriptor.Description = @"Deletes a user defined variable or function.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("variable", @"Name of the variable or function to delete.")  { IsOptional = false });
                descriptor.Example = @"    >>> x = 5; y = 2
    # x = 5; y = 2
    x = 5
    y = 2
    >>> del x
    # Variable `x == 5` deleted.
    >>> list
    # Variables
    y = 2
    >>> del y
    # Variable `y == 2` deleted.
    >>> f(x) = x + 5
    # f(x) = x + 5
    f(x) = x + 5
    >>> list
    # Functions
    f(x) = x + 5
    >>> del f
    # Function `f(x) = x + 5` deleted.
    >>> list
    # No variables
";
            }
            {
                var descriptor = Descriptors["exit"];
                descriptor.Category = "General";
                descriptor.Description = @"Exits kalk.";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["history"];
                descriptor.Category = "General";
                descriptor.Description = @"Displays the command history.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("line", @"An optional parameter that indicates:
    
     - if it is >= 0, the index of the history command to re-run. (e.g `history 1` to re-run the command 1 in the history)
     - if it is < 0, how many recent lines to display. (e.g `history -3` would display the last 3 lines in the history)")  { IsOptional = true });
                descriptor.Example = @"     >>> 1 + 5
     # 1 + 5
     out = 6
     >>> abs(out)
     # abs(out)
     out = 6
     >>> history
     0: 1 + 5
     1: abs(out)
";
            }
            {
                var descriptor = Descriptors["eval"];
                descriptor.Category = "General";
                descriptor.Description = @"Evaluates dynamically the input string as an expression.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("text", @"The text of the expression to evaluate.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("output", @"An optional parameter to output intermediate results of nested expressions. Default is `false`.")  { IsOptional = true });
                descriptor.Returns = @"The result of the evaluation.";
                descriptor.Example = @"    >>> eval ""1+5""
    # eval(""1+5"")
    out = 6
    >>> eval ""eval '1+5'""
    # eval(""eval '1+5'"")
    out = 6
";
            }
            {
                var descriptor = Descriptors["load"];
                descriptor.Category = "General";
                descriptor.Description = @"Loads and evaluates the specified script from a file location on a disk.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("path", @"The file location of the script to load and evaluate.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("output", @"An optional parameter to output intermediate results of nested expressions. Default is `false`.")  { IsOptional = true });
                descriptor.Returns = @"The result of the evaluation.";
            }
            {
                var descriptor = Descriptors["clear"];
                descriptor.Category = "General";
                descriptor.Description = @"Clears the screen (by default) or the history (e.g clear history).";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("what", @"An optional argument specifying what to clear. Can be of the following value:
    * screen: to clear the screen (default if not passed)
    * history: to clear the history")  { IsOptional = true });
            }
            {
                var descriptor = Descriptors["cls"];
                descriptor.Category = "General";
                descriptor.Description = @"Clears the screen.";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["out"];
                descriptor.Category = "General";
                descriptor.Description = @"Returns the last evaluated result.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"The last evaluated result as an object.";
                descriptor.Example = @"    >>> 1 + 2
    # 1 + 2
    out = 3
    >>> out + 1
    # out + 1
    out = 4
";
            }
            {
                var descriptor = Descriptors["out2clipboard"];
                descriptor.Category = "General";
                descriptor.Description = @"Copies the last evaluated content to the clipboard.
    
     This is equivalent to `out |> clipboard`.";
                descriptor.IsCommand = true;
                descriptor.Example = @"     >>> 1 + 2
     # 1 + 2
     out = 3
     >>> out2clipboard
     >>> clipboard
     # clipboard
     out = ""3""
";
            }
            {
                var descriptor = Descriptors["shortcut"];
                descriptor.Category = "General";
                descriptor.Description = @"Creates a keyboard shortcut associated with an expression.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("name", @"Name of the shortcut")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("shortcuts", @"A collection of pair of shortcut description (e.g `CTRL+A`) and associated shortcut expression (e.g `1 + 2`).")  { IsOptional = false });
                descriptor.Remarks = @"See the command `shortcuts` to list the shortcuts currently defined. By default several shortcuts for common mathematical symbols are defined (e.g for the symbol pi: `shortcut(pi, ""CTRL+G P"", ""Π"", ""CTRL+G p"", ""π"")`).";
                descriptor.Example = @"    >>> # Creates a shortcut that will print 3 when pressing CTRL+R.
    >>> shortcut(myshortcut, ""CTRL+R"", 1 + 2)
    >>> # Overrides the previous shortcut that will print the text
    >>> # `kalk` when pressing CTRL+R.
    >>> shortcut(myshortcut, ""CTRL+R"", ""kalk"")
    >>> # Overrides the previous shortcut that will print the text
    >>> # `kalk` when pressing CTRL+R or the text `kalk2` when pressing
    >>> # CTRL+E and r key.
    >>> shortcut(myshortcut, ""CTRL+R"", ""kalk"", ""CTRL+E r"", ""kalk2"")
";
            }
            {
                var descriptor = Descriptors["alias"];
                descriptor.Category = "General";
                descriptor.Description = @"Creates an alias between variable names.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("name", @"Name of the original alias name.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("aliases", @"Variable names that are all equivalent to the alias name.")  { IsOptional = false });
                descriptor.Remarks = @"See the command `aliases` to list the aliases currently defined. Several aliases are defined by default for common mathematical symbols (e.g `alias(pi, Π, π)`).";
                descriptor.Example = @"    >>> alias(var1, var2, var3)
    >>> var1 = 2
    # var1 = 2
    var1 = 2
    >>> var2
    # var2
    out = 2
    >>> var3
    # var3
    out = 2
    >>> list
    # Variables
    var1 = 2
    >>> var2 = 1
    # var2 = 1
    var2 = 1
    >>> list
    # Variables
    var1 = 1
";
            }
            {
                var descriptor = Descriptors["kind"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets the kind of a value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"A value to inspect the kind")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["to"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["unit"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core
{
    public partial class MathModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterConstant("nan", Nan);
            RegisterConstant("inf", Inf);
            RegisterConstant("pi", Pi);
            RegisterConstant("e", E);
            RegisterFunction("fib", (Func<Kalk.Core.KalkIntValue, object>)Fib);
            RegisterFunction("i", (Func<object>)ComplexNumber);
            RegisterFunction("all", (Func<object, Kalk.Core.KalkBool>)All);
            RegisterFunction("any", (Func<object, Kalk.Core.KalkBool>)Any);
            RegisterFunction("abs", (Func<Kalk.Core.KalkCompositeValue, object>)Abs);
            RegisterFunction("rnd", (Func<Kalk.Core.KalkCompositeValue, object>)Rnd);
            RegisterAction("seed", (Action<int?>)Seed);
            RegisterFunction("modf", (Func<Kalk.Core.KalkCompositeValue, Scriban.Runtime.ScriptArray>)Modf);
            RegisterFunction("radians", (Func<Kalk.Core.KalkCompositeValue, object>)Radians);
            RegisterFunction("degrees", (Func<Kalk.Core.KalkCompositeValue, object>)Degrees);
            RegisterFunction("sign", (Func<Kalk.Core.KalkCompositeValue, object>)Sign);
            RegisterFunction("cos", (Func<Kalk.Core.KalkDoubleValue, object>)Cos);
            RegisterFunction("acos", (Func<Kalk.Core.KalkDoubleValue, object>)Acos);
            RegisterFunction("cosh", (Func<Kalk.Core.KalkDoubleValue, object>)Cosh);
            RegisterFunction("acosh", (Func<Kalk.Core.KalkDoubleValue, object>)Acosh);
            RegisterFunction("sin", (Func<Kalk.Core.KalkDoubleValue, object>)Sin);
            RegisterFunction("asin", (Func<Kalk.Core.KalkDoubleValue, object>)Asin);
            RegisterFunction("sinh", (Func<Kalk.Core.KalkDoubleValue, object>)Sinh);
            RegisterFunction("asinh", (Func<Kalk.Core.KalkDoubleValue, object>)Asinh);
            RegisterFunction("tan", (Func<Kalk.Core.KalkDoubleValue, object>)Tan);
            RegisterFunction("atan", (Func<Kalk.Core.KalkDoubleValue, object>)Atan);
            RegisterFunction("tanh", (Func<Kalk.Core.KalkDoubleValue, object>)Tanh);
            RegisterFunction("atanh", (Func<Kalk.Core.KalkDoubleValue, object>)Atanh);
            RegisterFunction("atan2", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Atan2);
            RegisterFunction("fmod", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Fmod);
            RegisterFunction("frac", (Func<Kalk.Core.KalkDoubleValue, object>)Frac);
            RegisterFunction("rsqrt", (Func<Kalk.Core.KalkDoubleValue, object>)Rsqrt);
            RegisterFunction("sqrt", (Func<Kalk.Core.KalkDoubleValue, object>)Sqrt);
            RegisterFunction("log", (Func<Kalk.Core.KalkDoubleValue, object>)Log);
            RegisterFunction("log2", (Func<Kalk.Core.KalkDoubleValue, object>)Log2);
            RegisterFunction("log10", (Func<Kalk.Core.KalkDoubleValue, object>)Log10);
            RegisterFunction("exp", (Func<Kalk.Core.KalkDoubleValue, object>)Exp);
            RegisterFunction("exp2", (Func<Kalk.Core.KalkDoubleValue, object>)Exp2);
            RegisterFunction("pow", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Pow);
            RegisterFunction("round", (Func<Kalk.Core.KalkDoubleValue, object>)Round);
            RegisterFunction("floor", (Func<Kalk.Core.KalkDoubleValue, object>)Floor);
            RegisterFunction("ceil", (Func<Kalk.Core.KalkDoubleValue, object>)Ceiling);
            RegisterFunction("trunc", (Func<Kalk.Core.KalkDoubleValue, object>)Trunc);
            RegisterFunction("saturate", (Func<Kalk.Core.KalkDoubleValue, object>)Saturate);
            RegisterFunction("min", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Min);
            RegisterFunction("max", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Max);
            RegisterFunction("step", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Step);
            RegisterFunction("smoothstep", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Smoothstep);
            RegisterFunction("lerp", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Lerp);
            RegisterFunction("clamp", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Clamp);
            RegisterFunction("real", (Func<Kalk.Core.KalkComplex, double>)Real);
            RegisterFunction("imag", (Func<Kalk.Core.KalkComplex, double>)Imag);
            RegisterFunction("phase", (Func<Kalk.Core.KalkComplex, double>)Phase);
            RegisterFunction("isfinite", (Func<Kalk.Core.KalkCompositeValue, object>)IsFinite);
            RegisterFunction("isinf", (Func<Kalk.Core.KalkCompositeValue, object>)IsInf);
            RegisterFunction("isnan", (Func<Kalk.Core.KalkCompositeValue, object>)IsNan);
            RegisterFunction("sum", (Func<object, object[], object>)Sum);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["nan"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the ""Not a Number"" constant for a double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["inf"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the infinity constant for a double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pi"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the PI constant. pi = 3.14159265358979";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["e"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the natural logarithmic base. e = 2.71828182845905";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["fib"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Calculates the fibonacci number for the specified input.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input number.")  { IsOptional = false });
                descriptor.Returns = @"The fibonacci number.";
                descriptor.Example = @"    >>> fib 50
    # fib(50)
    out = 12586269025
";
            }
            {
                var descriptor = Descriptors["i"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the imaginary part of a complex number.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"A complex number.";
                descriptor.Example = @"    >>> 1 + 2i
    # 1 + 2 * i
    out = 1 + 2i
";
            }
            {
                var descriptor = Descriptors["all"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if all components of the specified value are non-zero.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"true if all components of the x parameter are non-zero; otherwise, false.";
                descriptor.Remarks = @"This function is similar to the `any` function.
    The `any` function determines if any components of the specified value are non-zero, while the `all` function determines if all components of the specified value are non-zero.";
                descriptor.Example = @"    >>> all(bool4(true, false, true, false))
    # all(bool4(true, false, true, false))
    out = false
    >>> all(bool4(true, true, true, true))
    # all(bool4(true, true, true, true))
    out = true
    >>> all([0,1,0,2])
    # all([0,1,0,2])
    out = false
    >>> all([1,1,1,1])
    # all([1,1,1,1])
    out = true
";
            }
            {
                var descriptor = Descriptors["any"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if any components of the specified value are non-zero.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"true if any components of the x parameter are non-zero; otherwise, false.";
                descriptor.Remarks = @"This function is similar to the `all` intrinsic function.
    The `any` function determines if any components of the specified value are non-zero,
    while the `all` function determines if all components of the specified value are non-zero.";
                descriptor.Example = @"    >>> any(bool4(true, false, true, false))
    # any(bool4(true, false, true, false))
    out = true
    >>> any(bool4(false, false, false, false))
    # any(bool4(false, false, false, false))
    out = false
    >>> any([0,1,0,2])
    # any([0,1,0,2])
    out = true
    >>> any([0,0,0,0])
    # any([0,0,0,0])
    out = false
";
            }
            {
                var descriptor = Descriptors["abs"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the absolute value of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The absolute value of the x parameter.";
                descriptor.Example = @"    >>> abs(-1)
    # abs(-1)
    out = 1
    >>> abs(float4(-1, 1, -2, -3))
    # abs(float4(-1, 1, -2, -3))
    out = float4(1, 1, 2, 3)
";
            }
            {
                var descriptor = Descriptors["rnd"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns a random value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A value to create random values for.")  { IsOptional = true });
                descriptor.Returns = @"A random value or a random value of the x parameter.";
                descriptor.Example = @"    >>> seed(0); rnd
    # seed(0); rnd
    out = 0.7262432699679598
    >>> rnd
    # rnd
    out = 0.8173253595909687
    >>> rnd(float4)
    # rnd(float4)
    out = float4(0.7680227, 0.5581612, 0.20603316, 0.5588848)
";
            }
            {
                var descriptor = Descriptors["seed"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Setup the seed function for rnd. The default seed is random.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"An original seed value for the `rnd` function.")  { IsOptional = true });
                descriptor.Remarks = @"The x is not specified, it will generate a random seed automatically.";
                descriptor.Example = @"    >>> seed(0); rnd
    # seed(0); rnd
    out = 0.7262432699679598
    >>> seed(1); rnd
    # seed(1); rnd
    out = 0.24866858415709278
";
            }
            {
                var descriptor = Descriptors["modf"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Splits the value x into fractional and integer parts, each of which has the same sign as x.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The signed-fractional portion of x.";
                descriptor.Example = @"    >>> modf(1.5)
    # modf(1.5)
    out = [1, 0.5]
    >>> modf(float2(-1.2, 3.4))
    # modf(float2(-1.2, 3.4))
    out = [float2(-1, 3), float2(-0.20000005, 0.4000001)]
";
            }
            {
                var descriptor = Descriptors["radians"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Converts the specified value from degrees to radians.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value in degrees.")  { IsOptional = false });
                descriptor.Returns = @"The x parameter converted from degrees to radians.";
                descriptor.Example = @"    >>> radians(90)
    # radians(90)
    out = 1.5707963267948966
    >>> radians(180)
    # radians(180)
    out = 3.141592653589793
";
            }
            {
                var descriptor = Descriptors["degrees"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Converts the specified value from radians to degrees.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"The x parameter converted from radians to degrees.";
                descriptor.Example = @"    >>> degrees(pi/2)
    # degrees(pi / 2)
    out = 90
    >>> degrees(pi)
    # degrees(pi)
    out = 180
";
            }
            {
                var descriptor = Descriptors["sign"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns an integer that indicates the sign of a number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A signed number.")  { IsOptional = false });
                descriptor.Returns = @"A number that indicates the sign of x:
     - -1 if x is less than zero
     - 0 if x is equal to zero
     - 1 if x is greater than zero.";
                descriptor.Example = @"    >>> sign(-5); sign(0); sign(2.3)
    # sign(-5); sign(0); sign(2.3)
    out = -1
    out = 0
    out = 1
    >>> sign float4(-1, 2, 0, 1.5)
    # sign(float4(-1, 2, 0, 1.5))
    out = float4(-1, 1, 0, 1)
";
            }
            {
                var descriptor = Descriptors["cos"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the cosine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The cosine of the x parameter.";
                descriptor.Example = @"    >>> cos 0.5
    # cos(0.5)
    out = 0.8775825618903728
    >>> cos float4(pi, pi/2, 0, 0.5)
    # cos(float4(pi, pi / 2, 0, 0.5))
    out = float4(-1, -4.371139E-08, 1, 0.87758255)
";
            }
            {
                var descriptor = Descriptors["acos"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the arccosine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value. Each component should be a floating-point value within the range of -1 to 1.")  { IsOptional = false });
                descriptor.Returns = @"The arccosine of the x parameter.";
                descriptor.Example = @"    >>> acos(-1)
    # acos(-1)
    out = 3.141592653589793
    >>> acos(0)
    # acos(0)
    out = 1.5707963267948966
    >>> acos(1)
    # acos(1)
    out = 0
    >>> acos(float4(-1,0,1,0.5))
    # acos(float4(-1, 0, 1, 0.5))
    out = float4(3.1415927, 1.5707964, 0, 1.0471976)
";
            }
            {
                var descriptor = Descriptors["cosh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the hyperbolic cosine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The hyperbolic cosine of the x parameter.";
                descriptor.Example = @"    >>> cosh(-1)
    # cosh(-1)
    out = 1.5430806348152437
    >>> cosh(1)
    # cosh(1)
    out = 1.5430806348152437
    >>> cosh(0)
    # cosh(0)
    out = 1
    >>> cosh(float4(-1, 1, 0, 2))
    # cosh(float4(-1, 1, 0, 2))
    out = float4(1.5430807, 1.5430807, 1, 3.7621956)
";
            }
            {
                var descriptor = Descriptors["acosh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the inverse hyperbolic cosine of a number. The number must be greater than or equal to 1.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"Any real number equal to or greater than 1.")  { IsOptional = false });
                descriptor.Returns = @"The inverse hyperbolic cosine of the x parameter";
                descriptor.Example = @"    >>> acosh(1)
    # acosh(1)
    out = 0
    >>> acosh(10)
    # acosh(10)
    out = 2.993222846126381
    >>> acosh(float4(1,2,4,10))
    # acosh(float4(1, 2, 4, 10))
    out = float4(0, 1.316958, 2.063437, 2.993223)
";
            }
            {
                var descriptor = Descriptors["sin"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the sine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The sine of the x parameter.";
                descriptor.Example = @"    >>> sin 0.5
    # sin(0.5)
    out = 0.479425538604203
    >>> sin float4(pi, pi/2, 0, 0.5)
    # sin(float4(pi, pi / 2, 0, 0.5))
    out = float4(-8.742278E-08, 1, 0, 0.47942555)
";
            }
            {
                var descriptor = Descriptors["asin"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the arcsine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value. Each component of the x parameter should be within the range of -π/2 to π/2.")  { IsOptional = false });
                descriptor.Returns = @"The arcsine of the x parameter.";
                descriptor.Example = @"    >>> asin 0.5
    # asin(0.5)
    out = 0.5235987755982989
    >>> asin float4(-1, 0, 1, 0.5)
    # asin(float4(-1, 0, 1, 0.5))
    out = float4(-1.5707964, 0, 1.5707964, 0.5235988)
";
            }
            {
                var descriptor = Descriptors["sinh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the hyperbolic sine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The hyperbolic sine of the x parameter.";
                descriptor.Example = @"    >>> sinh(-1)
    # sinh(-1)
    out = -1.1752011936438014
    >>> sinh(0)
    # sinh(0)
    out = 0
    >>> sinh(1)
    # sinh(1)
    out = 1.1752011936438014
    >>> sinh(float4(-1, 1, 0, 2))
    # sinh(float4(-1, 1, 0, 2))
    out = float4(-1.1752012, 1.1752012, 0, 3.6268604)
";
            }
            {
                var descriptor = Descriptors["asinh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the inverse hyperbolic sine of a number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The inverse hyperbolic sine of the x parameter.";
                descriptor.Example = @"    >>> asinh(-1.1752011936438014)
    # asinh(-1.1752011936438014)
    out = -1
    >>> asinh(0)
    # asinh(0)
    out = 0
    >>> asinh(1.1752011936438014)
    # asinh(1.1752011936438014)
    out = 1
    >>> asinh(float4(-1.1752011936438014, 0, 1.1752011936438014, 2))
    # asinh(float4(-1.1752011936438014, 0, 1.1752011936438014, 2))
    out = float4(-1, 0, 1, 1.4436355)
";
            }
            {
                var descriptor = Descriptors["tan"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the tangent of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The tangent of the x parameter.";
                descriptor.Example = @"    >>> tan(0.5)
    # tan(0.5)
    out = 0.5463024898437905
    >>> tan(1)
    # tan(1)
    out = 1.5574077246549023
    >>> tan float4(1, 2, 3, 4)
    # tan(float4(1, 2, 3, 4))
    out = float4(1.5574077, -2.1850398, -0.14254655, 1.1578213)
";
            }
            {
                var descriptor = Descriptors["atan"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the arctangent of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The arctangent of the x parameter. This value is within the range of -π/2 to π/2.";
                descriptor.Example = @"    >>> atan(0.5)
    # atan(0.5)
    out = 0.4636476090008061
    >>> atan(1)
    # atan(1)
    out = 0.7853981633974483
    >>> atan(0)
    # atan(0)
    out = 0
    >>> atan(float4(0,1,2,3))
    # atan(float4(0, 1, 2, 3))
    out = float4(0, 0.7853982, 1.1071488, 1.2490457)
";
            }
            {
                var descriptor = Descriptors["tanh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the hyperbolic tangent of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The hyperbolic tangent of the x parameter.";
                descriptor.Example = @"    >>> tanh(0)
    # tanh(0)
    out = 0
    >>> tanh(1)
    # tanh(1)
    out = 0.7615941559557649
    >>> tanh(2)
    # tanh(2)
    out = 0.9640275800758169
    >>> tanh(float4(0, 1, 2, 3))
    # tanh(float4(0, 1, 2, 3))
    out = float4(0, 0.7615942, 0.9640276, 0.9950548)
";
            }
            {
                var descriptor = Descriptors["atanh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the inverse hyperbolic tangent of a number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value. Number must be between -1 and 1 (excluding -1 and 1).")  { IsOptional = false });
                descriptor.Returns = @"The inverse hyperbolic tangent of the x parameter";
                descriptor.Example = @"    >>> atanh(0)
    # atanh(0)
    out = 0
    >>> atanh(0.5)
    # atanh(0.5)
    out = 0.5493061443340549
    >>> atanh(float4(-0.5, 0, 0.5, 0.8))
    # atanh(float4(-0.5, 0, 0.5, 0.8))
    out = float4(-0.54930615, 0, 0.54930615, 1.0986123)
";
            }
            {
                var descriptor = Descriptors["atan2"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the arctangent of two values (x,y).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The y value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The x value.")  { IsOptional = false });
                descriptor.Returns = @"The arctangent of (y,x).";
                descriptor.Remarks = @"The signs of the x and y parameters are used to determine the quadrant of the return values within the range of -π to π. The `atan2` function is well-defined for every point other than the origin, even if y equals 0 and x does not equal 0.";
                descriptor.Example = @"    >>> atan2(1,1)
    # atan2(1, 1)
    out = 0.7853981633974483
    >>> atan2(1,0)
    # atan2(1, 0)
    out = 1.5707963267948966
    >>> atan2(0,1)
    # atan2(0, 1)
    out = 0
    >>> atan2(float4(1), float4(0,1,-1,2))
    # atan2(float4(1), float4(0, 1, -1, 2))
    out = float4(1.5707964, 0.7853982, 2.3561945, 0.4636476)
";
            }
            {
                var descriptor = Descriptors["fmod"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the floating-point remainder of x/y.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The floating-point dividend.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The floating-point divisor.")  { IsOptional = false });
                descriptor.Returns = @"The floating-point remainder of the x parameter divided by the y parameter.";
                descriptor.Remarks = @"The floating-point remainder is calculated such that x = i * y + f, where i is an integer, f has the same sign as x, and the absolute value of f is less than the absolute value of y.";
                descriptor.Example = @"    >>> fmod(2.5, 2)
    # fmod(2.5, 2)
    out = 0.5
    >>> fmod(2.5, 3)
    # fmod(2.5, 3)
    out = 2.5
    >>> fmod(-1.5, 1)
    # fmod(-1.5, 1)
    out = -0.5
    >>> fmod(float4(1.5, 1.2, -2.3, -4.6), 0.2)
    # fmod(float4(1.5, 1.2, -2.3, -4.6), 0.2)
    out = float4(0.09999998, 2.9802322E-08, -0.09999992, -0.19999984)
";
            }
            {
                var descriptor = Descriptors["frac"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the fractional (or decimal) part of x; which is greater than or equal to 0 and less than 1.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The fractional part of the x parameter.";
                descriptor.Example = @"    >>> frac(1.25)
    # frac(1.25)
    out = 0.25
    >>> frac(10.5)
    # frac(10.5)
    out = 0.5
    >>> frac(-1.75)
    # frac(-1.75)
    out = 0.25
    >>> frac(-10.25)
    # frac(-10.25)
    out = 0.75
    >>> frac(float4(1.25, 10.5, -1.75, -10.25))
    # frac(float4(1.25, 10.5, -1.75, -10.25))
    out = float4(0.25, 0.5, 0.25, 0.75)
";
            }
            {
                var descriptor = Descriptors["rsqrt"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the reciprocal of the square root of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The reciprocal of the square root of the x parameter.";
                descriptor.Remarks = @"This function uses the following formula: 1 / sqrt(x).";
                descriptor.Example = @"    >>> rsqrt(1)
    # rsqrt(1)
    out = 1
    >>> rsqrt(2)
    # rsqrt(2)
    out = 0.7071067811865475
    >>> rsqrt(float4(1,2,3,4))
    # rsqrt(float4(1, 2, 3, 4))
    out = float4(1, 0.70710677, 0.57735026, 0.5)
";
            }
            {
                var descriptor = Descriptors["sqrt"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the square root of the specified floating-point value, per component.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified floating-point value.")  { IsOptional = false });
                descriptor.Returns = @"The square root of the x parameter, per component.";
                descriptor.Example = @"    >>> sqrt(1)
    # sqrt(1)
    out = 1
    >>> sqrt(2)
    # sqrt(2)
    out = 1.4142135623730951
    >>> sqrt(float4(1,2,3,4))
    # sqrt(float4(1, 2, 3, 4))
    out = float4(1, 1.4142135, 1.7320508, 2)
";
            }
            {
                var descriptor = Descriptors["log"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base-e logarithm of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-e logarithm of the x parameter. If the x parameter is negative, this function returns indefinite. If the x parameter is 0, this function returns `-inf`.";
                descriptor.Example = @"    >>> log 1
    # log(1)
    out = 0
    >>> log 2
    # log(2)
    out = 0.6931471805599453
    >>> log 0
    # log(0)
    out = -inf
    >>> log float4(0,1,2,3)
    # log(float4(0, 1, 2, 3))
    out = float4(-inf, 0, 0.6931472, 1.0986123)
";
            }
            {
                var descriptor = Descriptors["log2"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base-2 logarithm of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-2 logarithm of the x parameter. If the x parameter is negative, this function returns indefinite. If the x parameter is 0, this function returns -inf.";
                descriptor.Example = @"    >>> log2 0
    # log2(0)
    out = -inf
    >>> log2 8
    # log2(8)
    out = 3
    >>> log2 129
    # log2(129)
    out = 7.011227255423254
    >>> log2 float4(0, 2, 16, 257)
    # log2(float4(0, 2, 16, 257))
    out = float4(-inf, 1, 4, 8.005625)
";
            }
            {
                var descriptor = Descriptors["log10"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base-10 logarithm of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-10 logarithm of the x parameter. If the x parameter is negative, this function returns indefinite. If the x is 0, this function returns -inf.";
                descriptor.Example = @"    >>> log10 0
    # log10(0)
    out = -inf
    >>> log10 10
    # log10(10)
    out = 1
    >>> log10 100
    # log10(100)
    out = 2
    >>> log10 1001
    # log10(1001)
    out = 3.000434077479319
    >>> log10(float4(0,10,100,1001))
    # log10(float4(0, 10, 100, 1001))
    out = float4(-inf, 1, 2, 3.0004342)
";
            }
            {
                var descriptor = Descriptors["exp"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base-e exponential, or e^x, of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-e exponential of the x parameter.";
                descriptor.Example = @"    >>> exp(0)
    # exp(0)
    out = 1
    >>> exp(1)
    # exp(1)
    out = 2.718281828459045
    >>> exp(float4(0,1,2,3))
    # exp(float4(0, 1, 2, 3))
    out = float4(1, 2.7182817, 7.389056, 20.085537)
";
            }
            {
                var descriptor = Descriptors["exp2"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base 2 exponential, or 2^x, of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-2 exponential of the x parameter.";
                descriptor.Example = @"    >>> exp2(0)
    # exp2(0)
    out = 1
    >>> exp2(1)
    # exp2(1)
    out = 2
    >>> exp2(4)
    # exp2(4)
    out = 16
    >>> exp2(float4(0,1,2,3))
    # exp2(float4(0, 1, 2, 3))
    out = float4(1, 2, 4, 8)
";
            }
            {
                var descriptor = Descriptors["pow"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the specified value raised to the specified power.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The specified power.")  { IsOptional = false });
                descriptor.Returns = @"The x parameter raised to the power of the y parameter.";
                descriptor.Example = @"    >>> pow(1.5, 3.5)
    # pow(1.5, 3.5)
    out = 4.133513940946613
    >>> pow(2, 4)
    # pow(2, 4)
    out = 16
    >>> pow(float4(1,2,3,4), 4)
    # pow(float4(1, 2, 3, 4), 4)
    out = float4(1, 16, 81, 256)
    >>> pow(float4(1..4), float4(5..8))
    # pow(float4(1..4), float4(5..8))
    out = float4(1, 64, 2187, 65536)
";
            }
            {
                var descriptor = Descriptors["round"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Rounds the specified value to the nearest integer.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The x parameter, rounded to the nearest integer within a floating-point type.";
                descriptor.Example = @"    >>> round(0.2); round(1.5); round(10.7)
    # round(0.2); round(1.5); round(10.7)
    out = 0
    out = 2
    out = 11
    >>> round(-0.2); round(-1.5); round(-10.7)
    # round(-0.2); round(-1.5); round(-10.7)
    out = -0
    out = -2
    out = -11
";
            }
            {
                var descriptor = Descriptors["floor"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the largest integer that is less than or equal to the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The largest integer value (returned as a floating-point type) that is less than or equal to the x parameter.";
                descriptor.Example = @"    >>> floor(0.2); floor(1.5); floor(10.7)
    # floor(0.2); floor(1.5); floor(10.7)
    out = 0
    out = 1
    out = 10
    >>> floor(-0.2); floor(-1.5); floor(-10.7)
    # floor(-0.2); floor(-1.5); floor(-10.7)
    out = -1
    out = -2
    out = -11
";
            }
            {
                var descriptor = Descriptors["ceil"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the smallest integer value that is greater than or equal to the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The smallest integer value (returned as a floating-point type) that is greater than or equal to the x parameter.";
                descriptor.Example = @"    >>> ceil(0.2); ceil(1.5); ceil(10.7)
    # ceil(0.2); ceil(1.5); ceil(10.7)
    out = 1
    out = 2
    out = 11
    >>> ceil(-0.2); ceil(-1.5); ceil(-10.7)
    # ceil(-0.2); ceil(-1.5); ceil(-10.7)
    out = -0
    out = -1
    out = -10
";
            }
            {
                var descriptor = Descriptors["trunc"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Truncates a floating-point value to the integer component.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The input value truncated to an integer component.";
                descriptor.Remarks = @"This function truncates a floating-point value to the integer component. Given a floating-point value of 1.6, the trunc function would return 1.0, where as the round function would return 2.0.";
                descriptor.Example = @"    >>> trunc(0.2); trunc(1.5); trunc(10.7)
    # trunc(0.2); trunc(1.5); trunc(10.7)
    out = 0
    out = 1
    out = 10
    >>> trunc(-0.2); trunc(-1.5); trunc(-10.7)
    # trunc(-0.2); trunc(-1.5); trunc(-10.7)
    out = -0
    out = -1
    out = -10
";
            }
            {
                var descriptor = Descriptors["saturate"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Clamps the specified value within the range of 0 to 1.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The x parameter, clamped within the range of 0 to 1.";
                descriptor.Example = @"    >>> saturate(10)
    # saturate(10)
    out = 1
    >>> saturate(-10)
    # saturate(-10)
    out = 0
    >>> saturate(float4(-1, 0.5, 1, 2))
    # saturate(float4(-1, 0.5, 1, 2))
    out = float4(0, 0.5, 1, 1)
";
            }
            {
                var descriptor = Descriptors["min"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Selects the lesser of x and y.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The x input value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The y input value.")  { IsOptional = false });
                descriptor.Returns = @"The x or y parameter, whichever is the smallest value.";
                descriptor.Example = @"    >>> min(-5, 6)
    # min(-5, 6)
    out = -5
    >>> min(1, 0)
    # min(1, 0)
    out = 0
    >>> min(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    # min(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    out = float4(0, 0, 2, 2)
";
            }
            {
                var descriptor = Descriptors["max"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Selects the greater of x and y.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The x input value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The y input value.")  { IsOptional = false });
                descriptor.Returns = @"The x or y parameter, whichever is the largest value.";
                descriptor.Example = @"    >>> max(-5, 6)
    # max(-5, 6)
    out = 6
    >>> max(1, 0)
    # max(1, 0)
    out = 1
    >>> max(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    # max(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    out = float4(1, 1, 3, 3)
";
            }
            {
                var descriptor = Descriptors["step"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Compares two values, returning 0 or 1 based on which value is greater.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The first floating-point value to compare.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The second floating-point value to compare.")  { IsOptional = false });
                descriptor.Returns = @"1 if the x parameter is greater than or equal to the y parameter; otherwise, 0.";
                descriptor.Remarks = @"This function uses the following formula: (x >= y) ? 1 : 0. The function returns either 0 or 1 depending on whether the x parameter is greater than the y parameter. To compute a smooth interpolation between 0 and 1, use the `smoothstep` function.";
                descriptor.Example = @"    >>> step(1, 5)
    # step(1, 5)
    out = 1
    >>> step(5, 1)
    # step(5, 1)
    out = 0
    >>> step(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    # step(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    out = float4(1, 0, 1, 0)
    >>> step(-10, 5)
    # step(-10, 5)
    out = 1
    >>> step(5.5, -10.5)
    # step(5.5, -10.5)
    out = 0
";
            }
            {
                var descriptor = Descriptors["smoothstep"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns a smooth Hermite interpolation between 0 and 1, if x is in the range [min, max].";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("min", @"The minimum range of the x parameter.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("max", @"The maximum range of the x parameter.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value to be interpolated.")  { IsOptional = false });
                descriptor.Returns = @"Returns 0 if x is less than min; 1 if x is greater than max; otherwise, a value between 0 and 1 if x is in the range [min, max].";
                descriptor.Remarks = @"Use the smoothstep function to create a smooth transition between two values. For example, you can use this function to blend two colors smoothly.";
                descriptor.Example = @"    >>> smoothstep(float4(0), float4(1), float4(-0.5))
    # smoothstep(float4(0), float4(1), float4(-0.5))
    out = float4(0, 0, 0, 0)
    >>> smoothstep(float4(0), float4(1), float4(1.5))
    # smoothstep(float4(0), float4(1), float4(1.5))
    out = float4(1, 1, 1, 1)
    >>> smoothstep(float4(0), float4(1), float4(0.5))
    # smoothstep(float4(0), float4(1), float4(0.5))
    out = float4(0.5, 0.5, 0.5, 0.5)
    >>> smoothstep(float4(0), float4(1), float4(0.9))
    # smoothstep(float4(0), float4(1), float4(0.9))
    out = float4(0.972, 0.972, 0.972, 0.972)
";
            }
            {
                var descriptor = Descriptors["lerp"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Performs a linear interpolation.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The first-floating point value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The second-floating point value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("s", @"A value that linearly interpolates between the x parameter and the y parameter.")  { IsOptional = false });
                descriptor.Returns = @"The result of the linear interpolation.";
                descriptor.Example = @"    >>> lerp(0, 10, 0.5)
    # lerp(0, 10, 0.5)
    out = 5
    >>> lerp(rgb(""AliceBlue"").xyz, rgb(""Green"").xyz, 0.5)
    # lerp(rgb(""AliceBlue"").xyz, rgb(""Green"").xyz, 0.5)
    out = float3(0.47058824, 0.7372549, 0.5)
";
            }
            {
                var descriptor = Descriptors["clamp"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Clamps the specified value to the specified minimum and maximum range.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A value to clamp.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("min", @"The specified minimum range.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("max", @"The specified maximum range.")  { IsOptional = false });
                descriptor.Returns = @"The clamped value for the x parameter.";
                descriptor.Remarks = @"For values of -inf or inf, clamp will behave as expected. However for values of `nan`, the results are undefined.";
                descriptor.Example = @"    >>> clamp(-1, 0, 1)
    # clamp(-1, 0, 1)
    out = 0
    >>> clamp(2, 0, 1)
    # clamp(2, 0, 1)
    out = 1
    >>> clamp(0.5, 0, 1)
    # clamp(0.5, 0, 1)
    out = 0.5
    >>> clamp(float4(0, 1, -2, 3), float4(0, -1, 3, 4), float4(1, 2, 5, 6))
    # clamp(float4(0, 1, -2, 3), float4(0, -1, 3, 4), float4(1, 2, 5, 6))
    out = float4(0, 1, 3, 4)
";
            }
            {
                var descriptor = Descriptors["real"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the real part of the complex number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A complex number.")  { IsOptional = false });
                descriptor.Returns = @"The real part of the parameter x complex number.";
                descriptor.Example = @"    >>> real(1.5 + 2.5i)
    # real(1.5 + 2.5 * i)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["imag"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the imaginary part of the complex number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A complex number.")  { IsOptional = false });
                descriptor.Returns = @"The imaginary part of the parameter x complex number.";
                descriptor.Example = @"    >>> imag(1.5 + 2.5i)
    # imag(1.5 + 2.5 * i)
    out = 2.5
";
            }
            {
                var descriptor = Descriptors["phase"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the phase of the complex number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A complex number.")  { IsOptional = false });
                descriptor.Returns = @"The phase of the parameter x complex number.";
                descriptor.Example = @"    >>> phase(1.5 + 2.5i)
    # phase(1.5 + 2.5 * i)
    out = 1.0303768265243125
";
            }
            {
                var descriptor = Descriptors["isfinite"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if the specified floating-point value is finite.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"Returns a value of the same size as the input, with a value set to `true` if the x parameter is finite; otherwise `false`.";
                descriptor.Example = @"    >>> isfinite(1)
    # isfinite(1)
    out = true
    >>> isfinite(nan)
    # isfinite(nan)
    out = false
    >>> isfinite(inf)
    # isfinite(inf)
    out = false
    >>> isfinite(float4(1, -10.5, inf, nan))
    # isfinite(float4(1, -10.5, inf, nan))
    out = bool4(true, true, false, false)
";
            }
            {
                var descriptor = Descriptors["isinf"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if the specified value is infinite.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"Returns a value of the same size as the input, with a value set to `true` if the x parameter is +inf or -inf. Otherwise, `false`.";
                descriptor.Example = @"    >>> isinf(1)
    # isinf(1)
    out = false
    >>> isinf(inf)
    # isinf(inf)
    out = true
    >>> isinf(float4(1, -10.5, inf, nan))
    # isinf(float4(1, -10.5, inf, nan))
    out = bool4(false, false, true, false)
";
            }
            {
                var descriptor = Descriptors["isnan"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if the specified value is `nan`.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"Returns a value of the same size as the input, with a value set to `true` if the x parameter is `nan`. Otherwise, `false`.";
                descriptor.Example = @"    >>> isnan(1)
    # isnan(1)
    out = false
    >>> isnan(inf)
    # isnan(inf)
    out = false
    >>> isnan(nan)
    # isnan(nan)
    out = true
    >>> isnan(float4(1, -10.5, inf, nan))
    # isnan(float4(1, -10.5, inf, nan))
    out = bool4(false, false, false, true)
";
            }
            {
                var descriptor = Descriptors["sum"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Performs the summation of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The specified value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("values", @"Additional values.")  { IsOptional = false });
                descriptor.Returns = @"The summation of the values.";
                descriptor.Example = @"    >>> sum(1,2,3,4)
    # sum(1, 2, 3, 4)
    out = 10
    >>> sum(float4(1..4))
    # sum(float4(1..4))
    out = 10
    >>> sum(float4(1..4), float4(5..8))
    # sum(float4(1..4), float4(5..8))
    out = float4(15, 16, 17, 18)
    >>> sum(""a"", ""b"", ""c"")
    # sum(""a"", ""b"", ""c"")
    out = ""abc""
    >>> sum([""a"", ""b"", ""c""])
    # sum([""a"", ""b"", ""c""])
    out = ""abc""
";
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class MemoryModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("malloc", (Func<int, Kalk.Core.KalkNativeBuffer>)Malloc);
            RegisterFunction("bitcast", (Func<object, object, object>)Bitcast);
            RegisterFunction("asbytes", (Func<object, Kalk.Core.KalkNativeBuffer>)AsBytes);
            RegisterFunction("countbits", (Func<object, object>)CountBits);
            RegisterFunction("firstbithigh", (Func<object, object>)FirstBitHigh);
            RegisterFunction("firstbitlow", (Func<object, object>)FirstBitLow);
            RegisterFunction("reversebits", (Func<object, object>)ReverseBits);
            RegisterFunction("asdouble", (Func<object, double>)AsDouble);
            RegisterFunction("asfloat", (Func<object, float>)AsFloat);
            RegisterFunction("aslong", (Func<object, long>)AsLong);
            RegisterFunction("asulong", (Func<object, ulong>)AsULong);
            RegisterFunction("asint", (Func<object, int>)AsInt);
            RegisterFunction("asuint", (Func<object, uint>)AsUInt);
            RegisterFunction("bytebuffer", (Func<object[], Kalk.Core.KalkNativeBuffer>)ByteBuffer);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["malloc"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Allocates a `bytebuffer` of the specified size.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("size", @"Size of the bytebuffer.")  { IsOptional = false });
                descriptor.Returns = @"A bytebuffer of the specified size.";
                descriptor.Example = @"    >>> buffer = malloc(16)
    # buffer = malloc(16)
    buffer = bytebuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    >>> buffer[0] = 5
    >>> buffer
    # buffer
    out = bytebuffer([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
";
            }
            {
                var descriptor = Descriptors["bitcast"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Binary cast of a value to a target type.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("type", @"The type to cast to.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The value to cast.")  { IsOptional = false });
                descriptor.Returns = @"The binary cast of the input value.";
                descriptor.Remarks = @"The supported types are `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, `rgb`, `rgba` and all vector and matrix types.";
                descriptor.Example = @"    >>> bitcast(int, 1.5f)
    # bitcast(int, 1.5f)
    out = 1069547520
    >>> bitcast(float, out)
    # bitcast(float, out)
    out = 1.5
    >>> bitcast(long, 2.5)
    # bitcast(long, 2.5)
    out = 4612811918334230528
    >>> bitcast(double, out)
    # bitcast(double, out)
    out = 2.5
    >>> asbytes(float4(1..4))
    # asbytes(float4(1..4))
    out = bytebuffer([0, 0, 128, 63, 0, 0, 0, 64, 0, 0, 64, 64, 0, 0, 128, 64])
    >>> bitcast(float4, out)
    # bitcast(float4, out)
    out = float4(1, 2, 3, 4)
";
            }
            {
                var descriptor = Descriptors["asbytes"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Binary cast the specified value to a bytebuffer.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"An input value.")  { IsOptional = false });
                descriptor.Returns = @"A binary bytebuffer representing the value in binary form. The size of the buffer equals the binary size in memory of the input value.";
                descriptor.Example = @"    >>> asbytes(float4(1..4))
    # asbytes(float4(1..4))
    out = bytebuffer([0, 0, 128, 63, 0, 0, 0, 64, 0, 0, 64, 64, 0, 0, 128, 64])
    >>> asbytes(int(0x01020304))
    # asbytes(int(16909060))
    out = bytebuffer([4, 3, 2, 1])
    >>> asbytes(1.5)
    # asbytes(1.5)
    out = bytebuffer([0, 0, 0, 0, 0, 0, 248, 63])
    >>> asbytes(2.5f)
    # asbytes(2.5f)
    out = bytebuffer([0, 0, 32, 64])
";
            }
            {
                var descriptor = Descriptors["countbits"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Counts the number of bits (per component) of the input value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The number of bits (per component if the input is an int vector).";
                descriptor.Example = @"    >>> for val in 0..7; countbits(val); end;
    # for val in 0..7; countbits(val); end;
    out = 0
    out = 1
    out = 1
    out = 2
    out = 1
    out = 2
    out = 2
    out = 3
    >>> countbits(int4(1,2,3,4))
    # countbits(int4(1, 2, 3, 4))
    out = int4(1, 1, 2, 1)
    >>> countbits(bytebuffer(1..16))
    # countbits(bytebuffer(1..16))
    out = 33
";
            }
            {
                var descriptor = Descriptors["firstbithigh"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Gets the location of the first set bit starting from the highest order bit and working downward, per component.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The location of the first set bit.";
                descriptor.Remarks = @"If no bits are sets, this function will return -1.";
                descriptor.Example = @"    >>> firstbithigh 128
    # firstbithigh(128)
    out = 24
    >>> firstbithigh byte(128)
    # firstbithigh(byte(128))
    out = 0
    >>> firstbithigh 0
    # firstbithigh(0)
    out = -1
    >>> firstbithigh(int4(1, -1, 65536, 1 << 20))
    # firstbithigh(int4(1, -1, 65536, 1 << 20))
    out = int4(31, 0, 15, 11)
";
            }
            {
                var descriptor = Descriptors["firstbitlow"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Returns the location of the first set bit starting from the lowest order bit and working upward, per component.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The location of the first set bit.";
                descriptor.Remarks = @"If no bits are sets, this function will return -1.";
                descriptor.Example = @"    >>> firstbitlow 128
    # firstbitlow(128)
    out = 7
    >>> firstbitlow byte(128)
    # firstbitlow(byte(128))
    out = 7
    >>> firstbitlow 0
    # firstbitlow(0)
    out = -1
    >>> firstbitlow(int4(1, -1, 65536, 1 << 20))
    # firstbitlow(int4(1, -1, 65536, 1 << 20))
    out = int4(0, 0, 16, 20)
";
            }
            {
                var descriptor = Descriptors["reversebits"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reverses the order of the bits, per component";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input value, with the bit order reversed";
                descriptor.Example = @"    >>> reversebits 128
    # reversebits(128)
    out = 16777216
    >>> reversebits out
    # reversebits(out)
    out = 128
    >>> reversebits byte(128)
    # reversebits(byte(128))
    out = 1
    >>> reversebits(out)
    # reversebits(out)
    out = 128
    >>> reversebits(int4(1,2,3,4))
    # reversebits(int4(1, 2, 3, 4))
    out = int4(-2147483648, 1073741824, -1073741824, 536870912)
    >>> reversebits out
    # reversebits(out)
    out = int4(1, 2, 3, 4)
";
            }
            {
                var descriptor = Descriptors["asdouble"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets a 64-bit value into a double.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a double.";
                descriptor.Example = @"    >>> asdouble(1.5)
    # asdouble(1.5)
    out = 1.5
    >>> aslong(1.5)
    # aslong(1.5)
    out = 4609434218613702656
    >>> asdouble(out)
    # asdouble(out)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["asfloat"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets a 32-bit value into a float.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a float.";
                descriptor.Example = @"    >>> asfloat(1.5f)
    # asfloat(1.5f)
    out = 1.5
    >>> asint(1.5f)
    # asint(1.5f)
    out = 1069547520
    >>> asfloat(out)
    # asfloat(out)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["aslong"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets an input value to a 64-bit long.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a 64-bit long.";
                descriptor.Example = @"    >>> aslong(1.5)
    # aslong(1.5)
    out = 4609434218613702656
    >>> asdouble(out)
    # asdouble(out)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["asulong"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets an input value to a 64-bit ulong.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a 64-bit ulong.";
                descriptor.Example = @"    >>> asulong(-1.5)
    # asulong(-1.5)
    out = 13832806255468478464
    >>> asdouble(out)
    # asdouble(out)
    out = -1.5
";
            }
            {
                var descriptor = Descriptors["asint"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets an input value into a 32-bit int.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a 32-bit int.";
                descriptor.Example = @"    >>> asint(1.5f)
    # asint(1.5f)
    out = 1069547520
    >>> asfloat(out)
    # asfloat(out)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["asuint"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets an input value into a 32-bit uint.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a 32-bit uint.";
                descriptor.Example = @"    >>> asuint(-1.5f)
    # asuint(-1.5f)
    out = 3217031168
    >>> asfloat(out)
    # asfloat(out)
    out = -1.5
";
            }
            {
                var descriptor = Descriptors["bytebuffer"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Creates a bytebuffer from the specified input.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("values", @"The input values.")  { IsOptional = false });
                descriptor.Returns = @"A bytebuffer from the specified input.";
                descriptor.Example = @"    >>> bytebuffer
    # bytebuffer
    out = bytebuffer([])
    >>> bytebuffer(0,1,2,3,4)
    # bytebuffer(0, 1, 2, 3, 4)
    out = bytebuffer([0, 1, 2, 3, 4])
    >>> bytebuffer(float4(1))
    # bytebuffer(float4(1))
    out = bytebuffer([0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63])
    >>> bytebuffer([1,2,3,4])
    # bytebuffer([1,2,3,4])
    out = bytebuffer([1, 2, 3, 4])
";
            }
        }        
    }
}
namespace Kalk.Core
{
    public partial class MiscModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterConstant("date", DateObject);
            RegisterFunction("ascii", (Func<object, object>)Ascii);
            RegisterFunction("keys", (Func<object, System.Collections.IEnumerable>)Keys);
            RegisterFunction("guid", (Func<string>)Guid);
            RegisterFunction("size", (Func<object, int>)Size);
            RegisterFunction("values", (Func<object, System.Collections.IEnumerable>)Values);
            RegisterFunction("hex", (Func<object, bool, string, object>)Hexadecimal);
            RegisterFunction("bin", (Func<object, bool, string, object>)Binary);
            RegisterFunction("utf8", (Func<object, object>)GetUtf8);
            RegisterFunction("utf16", (Func<object, object>)GetUtf16);
            RegisterFunction("utf32", (Func<object, object>)GetUtf32);
            RegisterFunction("insert_at", (Func<object, int, object, object>)InsertAt);
            RegisterFunction("remove_at", (Func<object, int, object>)RemoveAt);
            RegisterFunction("contains", (Func<object, object, Kalk.Core.KalkBool>)Contains);
            RegisterFunction("replace", (Func<object, object, object, object>)Replace);
            RegisterFunction("slice", (Func<object, int, int?, object>)Slice);
            RegisterFunction("lines", (Func<string, Scriban.Runtime.ScriptRange>)Lines);
            RegisterFunction("colors", (Func<object>)Colors);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["date"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Gets the date object.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ascii"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Prints the ascii table or convert an input string to an ascii array, or an ascii array to a string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("obj", @"An optional input (string or array of numbers or directly an integer).")  { IsOptional = true });
                descriptor.Returns = @"Depending on the input:
    - If no input, it will display the ascii table
    - If the input is an integer, it will convert it to the equivalent ascii char.
    - If the input is a string, it will convert the string to a byte buffer containing the corresponding ascii bytes.
    - If the input is an array of integer, it will convert each element to the equivalent ascii char.";
                descriptor.Example = @"    >>> ascii 65
    # ascii(65)
    out = ""A""
    >>> ascii 97
    # ascii(97)
    out = ""a""
    >>> ascii ""A""
    # ascii(""A"")
    out = 65
    >>> ascii ""kalk""
    # ascii(""kalk"")
    out = bytebuffer([107, 97, 108, 107])
    >>> ascii out
    # ascii(out)
    out = ""kalk""
";
            }
            {
                var descriptor = Descriptors["keys"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Returns the keys of the specified object.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("obj", @"An object to get the keys from.")  { IsOptional = false });
                descriptor.Returns = @"The keys of the parameter obj.";
                descriptor.Example = @"    >>> obj = {m: 1, n: 2}; keys obj
    # obj = {m: 1, n: 2}; keys(obj)
    obj = {m: 1, n: 2}
    out = [""m"", ""n""]
";
            }
            {
                var descriptor = Descriptors["guid"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Returns a new GUID as a string.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"A new GUID as a string.";
            }
            {
                var descriptor = Descriptors["size"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Returns the size of the specified object.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("obj", @"The object value.")  { IsOptional = false });
                descriptor.Returns = @"The size of the object.";
                descriptor.Example = @"    >>> size 1
    # size(1)
    out = 0
    >>> size ""kalk""
    # size(""kalk"")
    out = 4
    >>> size float4(1,2,3,4)
    # size(float4(1, 2, 3, 4))
    out = 4
    >>> size [1, 2, 3]
    # size([1, 2, 3])
    out = 3
";
            }
            {
                var descriptor = Descriptors["values"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Returns the values of the specified object.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("obj", @"An object to get the values from.")  { IsOptional = false });
                descriptor.Returns = @"The values of the parameter obj.";
                descriptor.Example = @"    >>> obj = {m: 1, n: 2}; values obj
    # obj = {m: 1, n: 2}; values(obj)
    obj = {m: 1, n: 2}
    out = [1, 2]
";
            }
            {
                var descriptor = Descriptors["hex"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts an integral/bytebuffer input to an hexadecimal representation or convert an hexadecimal input string
    to an integral/bytebuffer representation.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("separator", @"The character used to separate hexadecimal bytes when converting
    from integral to hexadecimal.")  { IsOptional = true });
                descriptor.Params.Add(new KalkParamDescriptor("prefix", @"Output the prefix `0x` in front of each hexadecimal bytes when converting
    from integral to hexadecimal.")  { IsOptional = true });
                descriptor.Returns = @"The hexadecimal representation of the input or convert the hexadecimal input string
    to an integral representation.";
                descriptor.Remarks = @"When converting from a hexadecimal string to an integral representation, this method
    will skip any white-space characters, comma `,`, colon `:`, semi-colon `;`, underscore `_` and
    dash `-`.
    When the hexadecimal input string can be converted to an integral less than or equal 8 bytes (64 bits)
    it will convert it to a single integral result, otherwise it will convert to a bytebuffer.
    See the following examples.";
                descriptor.Example = @"    >>> hex 10
    # hex(10)
    out = ""0A""
    >>> hex ""0a""
    # hex(""0a"")
    out = 10
    >>> hex ""0xff030201""
    # hex(""0xff030201"")
    out = 4278387201
    >>> hex out
    # hex(out)
    out = ""01 02 03 FF""
    >>> hex ""01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F""
    # hex(""01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F"")
    out = bytebuffer([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
    >>> hex(out, true, "","")
    # hex(out, true, "","")
    out = ""0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F""
    >>> hex out
    # hex(out)
    out = bytebuffer([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
    >>> hex(""1a,2b;3c 4d-5e_6f"")
    # hex(""1a,2b;3c 4d-5e_6f"")
    out = 103832130169626
    >>> hex out
    # hex(out)
    out = ""1A 2B 3C 4D 6F 5E 00 00""
    >>> hex float4(1,2,3,4)
    # hex(float4(1, 2, 3, 4))
    out = ""00 00 80 3F 00 00 00 40 00 00 40 40 00 00 80 40""
";
            }
            {
                var descriptor = Descriptors["bin"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts an integral/bytebuffer input to a binary representation or convert a binary input string
    to an integral/bytebuffer representation.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("prefix", @"Output the prefix `0x` in front of each binary bytes when converting
        from integral to binary.")  { IsOptional = true });
                descriptor.Params.Add(new KalkParamDescriptor("separator", @"The character used to separate binary bytes when converting
        from integral to binary.")  { IsOptional = true });
                descriptor.Returns = @"The binary representation of the input or convert the binary input string
    to an integral representation.";
                descriptor.Remarks = @"When converting from a binary string to an integral representation, this method
    will skip any white-space characters, comma `,`, colon `:`, semi-colon `;`, underscore `_` and
    dash `-`.
    When the binary input string can be converted to an integral less than or equal 8 bytes (64 bits)
    it will convert it to a single integral result, otherwise it will convert to a bytebuffer.
    See the following examples.";
                descriptor.Example = @"    >>> bin 10
    # bin(10)
    out = ""00001010""
    >>> bin out
    # bin(out)
    out = 10
    >>> bin 0xff030201
    # bin(-16580095)
    out = ""00000001 00000010 00000011 11111111""
    >>> bin out
    # bin(out)
    out = 4278387201
    >>> bin ""11111111000000110000001000000001""
    # bin(""11111111000000110000001000000001"")
    out = 4278387201
";
            }
            {
                var descriptor = Descriptors["utf8"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts a string to an UTF8 bytebuffer or convert a bytebuffer of UTF8 bytes to a string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The UTF8 bytebuffer representation of the input string or the string representation of the input UTF8 bytebuffer.";
                descriptor.Example = @"    >>> utf8 ""kalk""
    # utf8(""kalk"")
    out = bytebuffer([107, 97, 108, 107])
    >>> utf8 out
    # utf8(out)
    out = ""kalk""
";
            }
            {
                var descriptor = Descriptors["utf16"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts a string to an UTF16 bytebuffer or convert a bytebuffer of UTF16 bytes to a string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The UTF16 bytebuffer representation of the input string or the string representation of the input UTF16 bytebuffer.";
                descriptor.Example = @"    >>> utf16 ""kalk""
    # utf16(""kalk"")
    out = bytebuffer([107, 0, 97, 0, 108, 0, 107, 0])
    >>> utf16 out
    # utf16(out)
    out = ""kalk""
";
            }
            {
                var descriptor = Descriptors["utf32"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts a string to an UTF32 bytebuffer or convert a bytebuffer of UTF32 bytes to a string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The UTF32 bytebuffer representation of the input string or the string representation of the input UTF32 bytebuffer.";
                descriptor.Example = @"    >>> utf32 ""kalk""
    # utf32(""kalk"")
    out = bytebuffer([107, 0, 0, 0, 97, 0, 0, 0, 108, 0, 0, 0, 107, 0, 0, 0])
    >>> utf32 out
    # utf32(out)
    out = ""kalk""
";
            }
            {
                var descriptor = Descriptors["insert_at"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Inserts an item into a string or list at the specified index.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"A string or list to insert an item into.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("index", @"The index at which to insert the item.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("item", @"The item to insert.")  { IsOptional = false });
                descriptor.Returns = @"A new string with the item inserted, or a new list with the item inserted at the specified index.";
                descriptor.Remarks = @"The index is adjusted at the modulo of the length of the input value.
    If the index is < 0, then the index starts from the end of the string/list length + 1. A value of -1 for the index would insert the item at the end, after the last element of the string or list.";
                descriptor.Example = @"    >>> insert_at(""kalk"", 0, ""YES"")
    # insert_at(""kalk"", 0, ""YES"")
    out = ""YESkalk""
    >>> insert_at(""kalk"", -1, ""YES"")
    # insert_at(""kalk"", -1, ""YES"")
    out = ""kalkYES""
    >>> insert_at(0..10, 1, 50)
    # insert_at(0..10, 1, 50)
    out = [0, 50, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> insert_at(0..9, 21, 50) # final index is 21 % 10 = 1
    # insert_at(0..9, 21, 50) # final index is 21 % 10 = 1
    out = [0, 50, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> insert_at([], 3, 1)
    # insert_at([], 3, 1)
    out = [1]
";
            }
            {
                var descriptor = Descriptors["remove_at"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Removes an item from a string or list at the specified index.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"A string or list to remove an item from.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("index", @"The index at which to remove the item.")  { IsOptional = false });
                descriptor.Returns = @"A new string/list with the item at the specified index removed.";
                descriptor.Remarks = @"The index is adjusted at the modulo of the length of the input value.
    If the index is < 0, then the index starts from the end of the string/list length. A value of -1 for the index would remove the last element.";
                descriptor.Example = @"    >>> remove_at(""kalk"", 0)
    # remove_at(""kalk"", 0)
    out = ""alk""
    >>> remove_at(""kalk"", -1)
    # remove_at(""kalk"", -1)
    out = ""kal""
    >>> remove_at(0..9, 5)
    # remove_at(0..9, 5)
    out = [0, 1, 2, 3, 4, 6, 7, 8, 9]
    >>> remove_at(0..9, -1)
    # remove_at(0..9, -1)
    out = [0, 1, 2, 3, 4, 5, 6, 7, 8]
    >>> remove_at(asbytes(0x04030201), 1)
    # remove_at(asbytes(67305985), 1)
    out = bytebuffer([1, 3, 4])
";
            }
            {
                var descriptor = Descriptors["contains"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Checks if an object (string, list, vector types, bytebuffer...) is containing the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"The list to search into.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The value to search into the list.")  { IsOptional = false });
                descriptor.Returns = @"true if value was found in the list input; otherwise false.";
                descriptor.Example = @"    >>> contains(""kalk"", ""l"")
    # contains(""kalk"", ""l"")
    out = true
    >>> contains(""kalk"", ""e"")
    # contains(""kalk"", ""e"")
    out = false
    >>> contains([1,2,3,4,5], 3)
    # contains([1,2,3,4,5], 3)
    out = true
    >>> contains([1,2,3,4,5], 6)
    # contains([1,2,3,4,5], 6)
    out = false
    >>> contains(float4(1,2,3,4), 3)
    # contains(float4(1, 2, 3, 4), 3)
    out = true
    >>> contains(float4(1,2,3,4), 6)
    # contains(float4(1, 2, 3, 4), 6)
    out = false
";
            }
            {
                var descriptor = Descriptors["replace"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Replaces in an object (string, list, vector types, bytebuffer...) an item of the specified value by another value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"The list to search into to replace an element.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The item to replace.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("by", @"The value to replace with.")  { IsOptional = false });
                descriptor.Returns = @"The modified object.";
                descriptor.Example = @"    >>> replace(""kalk"", ""k"", ""woo"")
    # replace(""kalk"", ""k"", ""woo"")
    out = ""wooalwoo""
    >>> replace([1,2,3,4], 3, 5)
    # replace([1,2,3,4], 3, 5)
    out = [1, 2, 5, 4]
    >>> replace(float4(1,2,3,4), 3, 5)
    # replace(float4(1, 2, 3, 4), 3, 5)
    out = float4(1, 2, 5, 4)
";
            }
            {
                var descriptor = Descriptors["slice"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Creates a slice of an object (string, list, vector types, bytebuffer...) starting at the specified index and with the specified length;";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"The object to create a slice from.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("index", @"The index into the object.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("length", @"The optional length of the slice. If the length is not defined, the length will start from index with the remaining elements.")  { IsOptional = true });
                descriptor.Returns = @"A slice of the input object.";
                descriptor.Remarks = @"The index is adjusted at the modulo of the specified length of the input object.
    If the index is < 0, then the index starts from the end of the input object length. A value of -1 for the index would take a slice with the only the last element.";
                descriptor.Example = @"    >>> slice(""kalk"", 1)
    # slice(""kalk"", 1)
    out = ""alk""
    >>> slice(""kalk"", -2)
    # slice(""kalk"", -2)
    out = ""lk""
    >>> slice(""kalk"", 1, 2)
    # slice(""kalk"", 1, 2)
    out = ""al""
    >>> slice([1,2,3,4], 1)
    # slice([1,2,3,4], 1)
    out = [2, 3, 4]
    >>> slice([1,2,3,4], -1)
    # slice([1,2,3,4], -1)
    out = [4]
    >>> slice([1,2,3,4], -1, 3) # length is bigger than expected, no errors
    # slice([1,2,3,4], -1, 3) # length is bigger than expected, no errors
    out = [4]
    >>> slice(asbytes(0x04030201), 1, 2)
    # slice(asbytes(67305985), 1, 2)
    out = slice(bytebuffer([2, 3]), 1, 2)
";
            }
            {
                var descriptor = Descriptors["lines"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Extract lines from the specified string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("text", @"A string to extract lines from.")  { IsOptional = false });
                descriptor.Returns = @"Lines extracted from the input string.";
                descriptor.Example = @"    >>> lines(""k\na\nl\nk"")
    # lines(""k\na\nl\nk"")
    out = [""k"", ""a"", ""l"", ""k""]
";
            }
            {
                var descriptor = Descriptors["colors"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Display or returns the known CSS colors.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"Prints known CSS colors or return a list if this function is used in an expression.";
                descriptor.Example = @"    >>> colors[0]
    # colors[0]
    out = rgb(240, 248, 255) ## F0F8FF AliceBlue ##
    >>> mycolor = colors[""AliceBlue""]; mycolor.name
    # mycolor = colors[""AliceBlue""]; mycolor.name
    mycolor = rgb(240, 248, 255) ## F0F8FF AliceBlue ##
    out = ""AliceBlue""
";
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse2IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_add_epi16", (Func<object, object, object>)mm_add_epi16);
            RegisterFunction("mm_add_epi32", (Func<object, object, object>)mm_add_epi32);
            RegisterFunction("mm_add_epi64", (Func<object, object, object>)mm_add_epi64);
            RegisterFunction("mm_add_epi8", (Func<object, object, object>)mm_add_epi8);
            RegisterFunction("mm_add_pd", (Func<object, object, object>)mm_add_pd);
            RegisterFunction("mm_add_sd", (Func<object, object, object>)mm_add_sd);
            RegisterFunction("mm_adds_epi16", (Func<object, object, object>)mm_adds_epi16);
            RegisterFunction("mm_adds_epi8", (Func<object, object, object>)mm_adds_epi8);
            RegisterFunction("mm_adds_epu16", (Func<object, object, object>)mm_adds_epu16);
            RegisterFunction("mm_adds_epu8", (Func<object, object, object>)mm_adds_epu8);
            RegisterFunction("mm_and_pd", (Func<object, object, object>)mm_and_pd);
            RegisterFunction("mm_and_si128", (Func<object, object, object>)mm_and_si128);
            RegisterFunction("mm_andnot_pd", (Func<object, object, object>)mm_andnot_pd);
            RegisterFunction("mm_andnot_si128", (Func<object, object, object>)mm_andnot_si128);
            RegisterFunction("mm_avg_epu16", (Func<object, object, object>)mm_avg_epu16);
            RegisterFunction("mm_avg_epu8", (Func<object, object, object>)mm_avg_epu8);
            RegisterFunction("mm_bslli_si128", (Func<object, byte, object>)mm_bslli_si128);
            RegisterFunction("mm_bsrli_si128", (Func<object, byte, object>)mm_bsrli_si128);
            RegisterFunction("mm_cmpeq_epi16", (Func<object, object, object>)mm_cmpeq_epi16);
            RegisterFunction("mm_cmpeq_epi32", (Func<object, object, object>)mm_cmpeq_epi32);
            RegisterFunction("mm_cmpeq_epi8", (Func<object, object, object>)mm_cmpeq_epi8);
            RegisterFunction("mm_cmpeq_pd", (Func<object, object, object>)mm_cmpeq_pd);
            RegisterFunction("mm_cmpeq_sd", (Func<object, object, object>)mm_cmpeq_sd);
            RegisterFunction("mm_cmpge_pd", (Func<object, object, object>)mm_cmpge_pd);
            RegisterFunction("mm_cmpge_sd", (Func<object, object, object>)mm_cmpge_sd);
            RegisterFunction("mm_cmpgt_epi16", (Func<object, object, object>)mm_cmpgt_epi16);
            RegisterFunction("mm_cmpgt_epi32", (Func<object, object, object>)mm_cmpgt_epi32);
            RegisterFunction("mm_cmpgt_epi8", (Func<object, object, object>)mm_cmpgt_epi8);
            RegisterFunction("mm_cmpgt_pd", (Func<object, object, object>)mm_cmpgt_pd);
            RegisterFunction("mm_cmpgt_sd", (Func<object, object, object>)mm_cmpgt_sd);
            RegisterFunction("mm_cmple_pd", (Func<object, object, object>)mm_cmple_pd);
            RegisterFunction("mm_cmple_sd", (Func<object, object, object>)mm_cmple_sd);
            RegisterFunction("mm_cmplt_epi16", (Func<object, object, object>)mm_cmplt_epi16);
            RegisterFunction("mm_cmplt_epi32", (Func<object, object, object>)mm_cmplt_epi32);
            RegisterFunction("mm_cmplt_epi8", (Func<object, object, object>)mm_cmplt_epi8);
            RegisterFunction("mm_cmplt_pd", (Func<object, object, object>)mm_cmplt_pd);
            RegisterFunction("mm_cmplt_sd", (Func<object, object, object>)mm_cmplt_sd);
            RegisterFunction("mm_cmpneq_pd", (Func<object, object, object>)mm_cmpneq_pd);
            RegisterFunction("mm_cmpneq_sd", (Func<object, object, object>)mm_cmpneq_sd);
            RegisterFunction("mm_cmpnge_pd", (Func<object, object, object>)mm_cmpnge_pd);
            RegisterFunction("mm_cmpnge_sd", (Func<object, object, object>)mm_cmpnge_sd);
            RegisterFunction("mm_cmpngt_pd", (Func<object, object, object>)mm_cmpngt_pd);
            RegisterFunction("mm_cmpngt_sd", (Func<object, object, object>)mm_cmpngt_sd);
            RegisterFunction("mm_cmpnle_pd", (Func<object, object, object>)mm_cmpnle_pd);
            RegisterFunction("mm_cmpnle_sd", (Func<object, object, object>)mm_cmpnle_sd);
            RegisterFunction("mm_cmpnlt_pd", (Func<object, object, object>)mm_cmpnlt_pd);
            RegisterFunction("mm_cmpnlt_sd", (Func<object, object, object>)mm_cmpnlt_sd);
            RegisterFunction("mm_cmpord_pd", (Func<object, object, object>)mm_cmpord_pd);
            RegisterFunction("mm_cmpord_sd", (Func<object, object, object>)mm_cmpord_sd);
            RegisterFunction("mm_cmpunord_pd", (Func<object, object, object>)mm_cmpunord_pd);
            RegisterFunction("mm_cmpunord_sd", (Func<object, object, object>)mm_cmpunord_sd);
            RegisterFunction("mm_comieq_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_comieq_sd);
            RegisterFunction("mm_comige_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_comige_sd);
            RegisterFunction("mm_comigt_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_comigt_sd);
            RegisterFunction("mm_comile_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_comile_sd);
            RegisterFunction("mm_comilt_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_comilt_sd);
            RegisterFunction("mm_comineq_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_comineq_sd);
            RegisterFunction("mm_cvtepi32_pd", (Func<object, object>)mm_cvtepi32_pd);
            RegisterFunction("mm_cvtepi32_ps", (Func<object, object>)mm_cvtepi32_ps);
            RegisterFunction("mm_cvtpd_epi32", (Func<object, object>)mm_cvtpd_epi32);
            RegisterFunction("mm_cvtpd_ps", (Func<object, object>)mm_cvtpd_ps);
            RegisterFunction("mm_cvtps_epi32", (Func<object, object>)mm_cvtps_epi32);
            RegisterFunction("mm_cvtps_pd", (Func<object, object>)mm_cvtps_pd);
            RegisterFunction("mm_cvtsd_si32", (Func<object, int>)mm_cvtsd_si32);
            RegisterFunction("mm_cvtsd_ss", (Func<object, object, object>)mm_cvtsd_ss);
            RegisterFunction("mm_cvtsi128_si32", (Func<object, int>)mm_cvtsi128_si32);
            RegisterFunction("mm_cvtsi32_sd", (Func<object, int, object>)mm_cvtsi32_sd);
            RegisterFunction("mm_cvtsi32_si128", (Func<int, object>)mm_cvtsi32_si128);
            RegisterFunction("mm_cvtss_sd", (Func<object, object, object>)mm_cvtss_sd);
            RegisterFunction("mm_cvttpd_epi32", (Func<object, object>)mm_cvttpd_epi32);
            RegisterFunction("mm_cvttps_epi32", (Func<object, object>)mm_cvttps_epi32);
            RegisterFunction("mm_cvttsd_si32", (Func<object, int>)mm_cvttsd_si32);
            RegisterFunction("mm_div_pd", (Func<object, object, object>)mm_div_pd);
            RegisterFunction("mm_div_sd", (Func<object, object, object>)mm_div_sd);
            RegisterFunction("mm_extract_epi16", (Func<object, byte, ushort>)mm_extract_epi16);
            RegisterFunction("mm_insert_epi16", (Func<object, short, byte, object>)mm_insert_epi16);
            RegisterFunction("mm_load_pd", (Func<object, object>)mm_load_pd);
            RegisterFunction("mm_load_sd", (Func<object, object>)mm_load_sd);
            RegisterFunction("mm_load_si128", (Func<object, object>)mm_load_si128);
            RegisterFunction("mm_loadh_pd", (Func<object, object, object>)mm_loadh_pd);
            RegisterFunction("mm_loadl_epi32", (Func<object, object>)mm_loadl_epi32);
            RegisterFunction("mm_loadl_epi64", (Func<object, object>)mm_loadl_epi64);
            RegisterFunction("mm_loadl_pd", (Func<object, object, object>)mm_loadl_pd);
            RegisterFunction("mm_loadu_pd", (Func<object, object>)mm_loadu_pd);
            RegisterFunction("mm_loadu_si128", (Func<object, object>)mm_loadu_si128);
            RegisterFunction("mm_madd_epi16", (Func<object, object, object>)mm_madd_epi16);
            RegisterAction("mm_maskmoveu_si128", (Action<object, object, object>)mm_maskmoveu_si128);
            RegisterFunction("mm_max_epi16", (Func<object, object, object>)mm_max_epi16);
            RegisterFunction("mm_max_epu8", (Func<object, object, object>)mm_max_epu8);
            RegisterFunction("mm_max_pd", (Func<object, object, object>)mm_max_pd);
            RegisterFunction("mm_max_sd", (Func<object, object, object>)mm_max_sd);
            RegisterFunction("mm_min_epi16", (Func<object, object, object>)mm_min_epi16);
            RegisterFunction("mm_min_epu8", (Func<object, object, object>)mm_min_epu8);
            RegisterFunction("mm_min_pd", (Func<object, object, object>)mm_min_pd);
            RegisterFunction("mm_min_sd", (Func<object, object, object>)mm_min_sd);
            RegisterFunction("mm_move_epi64", (Func<object, object>)mm_move_epi64);
            RegisterFunction("mm_move_sd", (Func<object, object, object>)mm_move_sd);
            RegisterFunction("mm_movemask_epi8", (Func<object, int>)mm_movemask_epi8);
            RegisterFunction("mm_movemask_pd", (Func<object, int>)mm_movemask_pd);
            RegisterFunction("mm_mul_epu32", (Func<object, object, object>)mm_mul_epu32);
            RegisterFunction("mm_mul_pd", (Func<object, object, object>)mm_mul_pd);
            RegisterFunction("mm_mul_sd", (Func<object, object, object>)mm_mul_sd);
            RegisterFunction("mm_mulhi_epi16", (Func<object, object, object>)mm_mulhi_epi16);
            RegisterFunction("mm_mulhi_epu16", (Func<object, object, object>)mm_mulhi_epu16);
            RegisterFunction("mm_mullo_epi16", (Func<object, object, object>)mm_mullo_epi16);
            RegisterFunction("mm_or_pd", (Func<object, object, object>)mm_or_pd);
            RegisterFunction("mm_or_si128", (Func<object, object, object>)mm_or_si128);
            RegisterFunction("mm_packs_epi16", (Func<object, object, object>)mm_packs_epi16);
            RegisterFunction("mm_packs_epi32", (Func<object, object, object>)mm_packs_epi32);
            RegisterFunction("mm_packus_epi16", (Func<object, object, object>)mm_packus_epi16);
            RegisterFunction("mm_sad_epu8", (Func<object, object, object>)mm_sad_epu8);
            RegisterFunction("mm_shuffle_epi32", (Func<object, byte, object>)mm_shuffle_epi32);
            RegisterFunction("mm_shuffle_pd", (Func<object, object, byte, object>)mm_shuffle_pd);
            RegisterFunction("mm_shufflehi_epi16", (Func<object, byte, object>)mm_shufflehi_epi16);
            RegisterFunction("mm_shufflelo_epi16", (Func<object, byte, object>)mm_shufflelo_epi16);
            RegisterFunction("mm_sll_epi16", (Func<object, object, object>)mm_sll_epi16);
            RegisterFunction("mm_sll_epi32", (Func<object, object, object>)mm_sll_epi32);
            RegisterFunction("mm_sll_epi64", (Func<object, object, object>)mm_sll_epi64);
            RegisterFunction("mm_slli_epi16", (Func<object, byte, object>)mm_slli_epi16);
            RegisterFunction("mm_slli_epi32", (Func<object, byte, object>)mm_slli_epi32);
            RegisterFunction("mm_slli_epi64", (Func<object, byte, object>)mm_slli_epi64);
            RegisterFunction("mm_sqrt_pd", (Func<object, object>)mm_sqrt_pd);
            RegisterFunction("mm_sqrt_sd", (Func<object, object, object>)mm_sqrt_sd);
            RegisterFunction("mm_sqrt_sd1", (Func<object, object>)mm_sqrt_sd1);
            RegisterFunction("mm_sra_epi16", (Func<object, object, object>)mm_sra_epi16);
            RegisterFunction("mm_sra_epi32", (Func<object, object, object>)mm_sra_epi32);
            RegisterFunction("mm_srai_epi16", (Func<object, byte, object>)mm_srai_epi16);
            RegisterFunction("mm_srai_epi32", (Func<object, byte, object>)mm_srai_epi32);
            RegisterFunction("mm_srl_epi16", (Func<object, object, object>)mm_srl_epi16);
            RegisterFunction("mm_srl_epi32", (Func<object, object, object>)mm_srl_epi32);
            RegisterFunction("mm_srl_epi64", (Func<object, object, object>)mm_srl_epi64);
            RegisterFunction("mm_srli_epi16", (Func<object, byte, object>)mm_srli_epi16);
            RegisterFunction("mm_srli_epi32", (Func<object, byte, object>)mm_srli_epi32);
            RegisterFunction("mm_srli_epi64", (Func<object, byte, object>)mm_srli_epi64);
            RegisterAction("mm_store_pd", (Action<object, object>)mm_store_pd);
            RegisterAction("mm_store_sd", (Action<object, object>)mm_store_sd);
            RegisterAction("mm_store_si128", (Action<object, object>)mm_store_si128);
            RegisterAction("mm_storeh_pd", (Action<object, object>)mm_storeh_pd);
            RegisterAction("mm_storel_epi64", (Action<object, object>)mm_storel_epi64);
            RegisterAction("mm_storel_pd", (Action<object, object>)mm_storel_pd);
            RegisterAction("mm_storeu_pd", (Action<object, object>)mm_storeu_pd);
            RegisterAction("mm_storeu_si128", (Action<object, object>)mm_storeu_si128);
            RegisterAction("mm_storeu_si32", (Action<object, object>)mm_storeu_si32);
            RegisterAction("mm_stream_pd", (Action<object, object>)mm_stream_pd);
            RegisterAction("mm_stream_si128", (Action<object, object>)mm_stream_si128);
            RegisterAction("mm_stream_si32", (Action<object, int>)mm_stream_si32);
            RegisterFunction("mm_sub_epi16", (Func<object, object, object>)mm_sub_epi16);
            RegisterFunction("mm_sub_epi32", (Func<object, object, object>)mm_sub_epi32);
            RegisterFunction("mm_sub_epi64", (Func<object, object, object>)mm_sub_epi64);
            RegisterFunction("mm_sub_epi8", (Func<object, object, object>)mm_sub_epi8);
            RegisterFunction("mm_sub_pd", (Func<object, object, object>)mm_sub_pd);
            RegisterFunction("mm_sub_sd", (Func<object, object, object>)mm_sub_sd);
            RegisterFunction("mm_subs_epi16", (Func<object, object, object>)mm_subs_epi16);
            RegisterFunction("mm_subs_epi8", (Func<object, object, object>)mm_subs_epi8);
            RegisterFunction("mm_subs_epu16", (Func<object, object, object>)mm_subs_epu16);
            RegisterFunction("mm_subs_epu8", (Func<object, object, object>)mm_subs_epu8);
            RegisterFunction("mm_ucomieq_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomieq_sd);
            RegisterFunction("mm_ucomige_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomige_sd);
            RegisterFunction("mm_ucomigt_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomigt_sd);
            RegisterFunction("mm_ucomile_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomile_sd);
            RegisterFunction("mm_ucomilt_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomilt_sd);
            RegisterFunction("mm_ucomineq_sd", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomineq_sd);
            RegisterFunction("mm_unpackhi_epi16", (Func<object, object, object>)mm_unpackhi_epi16);
            RegisterFunction("mm_unpackhi_epi32", (Func<object, object, object>)mm_unpackhi_epi32);
            RegisterFunction("mm_unpackhi_epi64", (Func<object, object, object>)mm_unpackhi_epi64);
            RegisterFunction("mm_unpackhi_epi8", (Func<object, object, object>)mm_unpackhi_epi8);
            RegisterFunction("mm_unpackhi_pd", (Func<object, object, object>)mm_unpackhi_pd);
            RegisterFunction("mm_unpacklo_epi16", (Func<object, object, object>)mm_unpacklo_epi16);
            RegisterFunction("mm_unpacklo_epi32", (Func<object, object, object>)mm_unpacklo_epi32);
            RegisterFunction("mm_unpacklo_epi64", (Func<object, object, object>)mm_unpacklo_epi64);
            RegisterFunction("mm_unpacklo_epi8", (Func<object, object, object>)mm_unpacklo_epi8);
            RegisterFunction("mm_unpacklo_pd", (Func<object, object, object>)mm_unpacklo_pd);
            RegisterFunction("mm_xor_pd", (Func<object, object, object>)mm_xor_pd);
            RegisterFunction("mm_xor_si128", (Func<object, object, object>)mm_xor_si128);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_add_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed 16-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_add_epi16 (__m128i a,  __m128i b)
    PADDW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_add_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed 32-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_add_epi32 (__m128i a,  __m128i b)
    PADDD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_add_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed 64-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_add_epi64 (__m128i a,  __m128i b)
    PADDQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_add_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_add_epi8 (__m128i a,  __m128i b)
    PADDB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_add_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128d _mm_add_pd (__m128d a,  __m128d b)
    ADDPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_add_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add the lower double-precision (64-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_add_sd (__m128d a,  __m128d b)
    ADDSD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_adds_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed 16-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".
    
    __m128i _mm_adds_epi16 (__m128i a,  __m128i b)
    PADDSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_adds_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".
    
    __m128i _mm_adds_epi8 (__m128i a,  __m128i b)
    PADDSB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_adds_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed unsigned 16-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".
    
    __m128i _mm_adds_epu16 (__m128i a,  __m128i b)
    PADDUSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_adds_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed unsigned 8-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".
    
    __m128i _mm_adds_epu8 (__m128i a,  __m128i b)
    PADDUSB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_and_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise AND of packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128d _mm_and_pd (__m128d a, __m128d b)
    ANDPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_and_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".
    
    __m128i _mm_and_si128 (__m128i a,  __m128i b)
    PAND xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_andnot_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise NOT of packed double-precision (64-bit) floating-point elements in ""a"" and then AND with ""b"", and store the results in ""dst"".
    
    __m128d _mm_andnot_pd (__m128d a, __m128d b)
    ADDNPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_andnot_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise NOT of 128 bits (representing integer data) in ""a"" and then AND with ""b"", and store the result in ""dst"".
    
    __m128i _mm_andnot_si128 (__m128i a,  __m128i b)
    PANDN xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_avg_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Average packed unsigned 16-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_avg_epu16 (__m128i a,  __m128i b)
    PAVGW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_avg_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Average packed unsigned 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_avg_epu8 (__m128i a,  __m128i b)
    PAVGB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_bslli_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift ""a"" left by ""imm8"" bytes while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_bslli_si128 (__m128i a, int imm8)
    PSLLDQ xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_bsrli_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift ""a"" right by ""imm8"" bytes while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_bsrli_si128 (__m128i a, int imm8)
    PSRLDQ xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpeq_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m128i _mm_cmpeq_epi16 (__m128i a,  __m128i b)
    PCMPEQW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpeq_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m128i _mm_cmpeq_epi32 (__m128i a,  __m128i b)
    PCMPEQD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpeq_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m128i _mm_cmpeq_epi8 (__m128i a,  __m128i b)
    PCMPEQB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpeq_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m128d _mm_cmpeq_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(0)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpeq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for equality, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpeq_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(0)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpge_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, and store the results in ""dst"".
    
    __m128d _mm_cmpge_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(5)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpge_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpge_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(5)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpgt_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m128i _mm_cmpgt_epi16 (__m128i a,  __m128i b)
    PCMPGTW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpgt_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m128i _mm_cmpgt_epi32 (__m128i a,  __m128i b)
    PCMPGTD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpgt_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m128i _mm_cmpgt_epi8 (__m128i a,  __m128i b)
    PCMPGTB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpgt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m128d _mm_cmpgt_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(6)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpgt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpgt_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(6)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmple_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, and store the results in ""dst"".
    
    __m128d _mm_cmple_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(2)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmple_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmple_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(2)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmplt_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"" for less-than, and store the results in ""dst"". Note: This intrinsic emits the pcmpgtw instruction with the order of the operands switched.
    
    __m128i _mm_cmplt_epi16 (__m128i a,  __m128i b)
    PCMPGTW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmplt_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"" for less-than, and store the results in ""dst"". Note: This intrinsic emits the pcmpgtd instruction with the order of the operands switched.
    
    __m128i _mm_cmplt_epi32 (__m128i a,  __m128i b)
    PCMPGTD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmplt_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for less-than, and store the results in ""dst"". Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.
    
    __m128i _mm_cmplt_epi8 (__m128i a,  __m128i b)
    PCMPGTB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmplt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than, and store the results in ""dst"".
    
    __m128d _mm_cmplt_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(1)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmplt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmplt_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(1)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpneq_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-equal, and store the results in ""dst"".
    
    __m128d _mm_cmpneq_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpneq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpneq_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnge_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, and store the results in ""dst"".
    
    __m128d _mm_cmpnge_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(1)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnge_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpnge_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(1)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpngt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, and store the results in ""dst"".
    
    __m128d _mm_cmpngt_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(2)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpngt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpngt_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(2)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnle_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, and store the results in ""dst"".
    
    __m128d _mm_cmpnle_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(6)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnle_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpnle_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(6)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than, and store the results in ""dst"".
    
    __m128d _mm_cmpnlt_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(5)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpnlt_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(5)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpord_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, and store the results in ""dst"".
    
    __m128d _mm_cmpord_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(7)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpord_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpord_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(7)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpunord_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, and store the results in ""dst"".
    
    __m128d _mm_cmpunord_pd (__m128d a,  __m128d b)
    CMPPD xmm, xmm/m128, imm8(3)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpunord_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cmpunord_sd (__m128d a,  __m128d b)
    CMPSD xmm, xmm/m64, imm8(3)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comieq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for equality, and return the boolean result (0 or 1).
    
    int _mm_comieq_sd (__m128d a, __m128d b)
    COMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comige_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for greater-than-or-equal, and return the boolean result (0 or 1).
    
    int _mm_comige_sd (__m128d a, __m128d b)
    COMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comigt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for greater-than, and return the boolean result (0 or 1).
    
    int _mm_comigt_sd (__m128d a, __m128d b)
    COMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comile_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for less-than-or-equal, and return the boolean result (0 or 1).
    
    int _mm_comile_sd (__m128d a, __m128d b)
    COMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comilt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for less-than, and return the boolean result (0 or 1).
    
    int _mm_comilt_sd (__m128d a, __m128d b)
    COMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comineq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for not-equal, and return the boolean result (0 or 1).
    
    int _mm_comineq_sd (__m128d a, __m128d b)
    COMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepi32_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 32-bit integers in ""a"" to packed double-precision (64-bit) floating-point elements, and store the results in ""dst"".
    
    __m128d _mm_cvtepi32_pd (__m128i a)
    CVTDQ2PD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepi32_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 32-bit integers in ""a"" to packed single-precision (32-bit) floating-point elements, and store the results in ""dst"".
    
    __m128 _mm_cvtepi32_ps (__m128i a)
    CVTDQ2PS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtpd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtpd_epi32 (__m128d a)
    CVTPD2DQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtpd_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed single-precision (32-bit) floating-point elements, and store the results in ""dst"".
    
    __m128 _mm_cvtpd_ps (__m128d a)
    CVTPD2PS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtps_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtps_epi32 (__m128 a)
    CVTPS2DQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtps_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed double-precision (64-bit) floating-point elements, and store the results in ""dst"".
    
    __m128d _mm_cvtps_pd (__m128 a)
    CVTPS2PD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsd_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""a"" to a 32-bit integer, and store the result in ""dst"".
    
    int _mm_cvtsd_si32 (__m128d a)
    CVTSD2SI r32, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsd_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""b"" to a single-precision (32-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128 _mm_cvtsd_ss (__m128 a, __m128d b)
    CVTSD2SS xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsi128_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy the lower 32-bit integer in ""a"" to ""dst"".
    
    int _mm_cvtsi128_si32 (__m128i a)
    MOVD reg/m32, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsi32_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the 32-bit integer ""b"" to a double-precision (64-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cvtsi32_sd (__m128d a, int b)
    CVTSI2SD xmm, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsi32_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy 32-bit integer ""a"" to the lower elements of ""dst"", and zero the upper elements of ""dst"".
    
    __m128i _mm_cvtsi32_si128 (int a)
    MOVD xmm, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtss_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""b"" to a double-precision (64-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cvtss_sd (__m128d a, __m128 b)
    CVTSS2SD xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvttpd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed 32-bit integers with truncation, and store the results in ""dst"".
    
    __m128i _mm_cvttpd_epi32 (__m128d a)
    CVTTPD2DQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvttps_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed 32-bit integers with truncation, and store the results in ""dst"".
    
    __m128i _mm_cvttps_epi32 (__m128 a)
    CVTTPS2DQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvttsd_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""a"" to a 32-bit integer with truncation, and store the result in ""dst"".
    
    int _mm_cvttsd_si32 (__m128d a)
    CVTTSD2SI reg, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_div_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Divide packed double-precision (64-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".
    
    __m128d _mm_div_pd (__m128d a,  __m128d b)
    DIVPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_div_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Divide the lower double-precision (64-bit) floating-point element in ""a"" by the lower double-precision (64-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_div_sd (__m128d a,  __m128d b)
    DIVSD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_extract_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Extract a 16-bit integer from ""a"", selected with ""imm8"", and store the result in the lower element of ""dst"".
    
    int _mm_extract_epi16 (__m128i a,  int immediate)
    PEXTRW reg, xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_insert_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy ""a"" to ""dst"", and insert the 16-bit integer ""i"" into ""dst"" at the location specified by ""imm8"".
    
    __m128i _mm_insert_epi16 (__m128i a,  int i, int immediate)
    PINSRW xmm, reg/m16, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_load_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into ""dst"".
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    __m128d _mm_load_pd (double const* mem_address)
    MOVAPD xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_load_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Load a double-precision (64-bit) floating-point element from memory into the lower of ""dst"", and zero the upper element. ""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128d _mm_load_sd (double const* mem_address)
    MOVSD xmm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_load_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Load 128-bits of integer data from memory into ""dst"". 
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    __m128i _mm_load_si128 (__m128i const* mem_address)
    MOVDQA xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadh_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Load a double-precision (64-bit) floating-point element from memory into the upper element of ""dst"", and copy the lower element from ""a"" to ""dst"". ""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128d _mm_loadh_pd (__m128d a, double const* mem_addr)
    MOVHPD xmm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadl_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"__m128i _mm_loadl_epi32 (__m128i const* mem_addr)
    MOVD xmm, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadl_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Load 64-bit integer from memory into the first element of ""dst"".
    
    __m128i _mm_loadl_epi64 (__m128i const* mem_addr)
    MOVQ xmm, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadl_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Load a double-precision (64-bit) floating-point element from memory into the lower element of ""dst"", and copy the upper element from ""a"" to ""dst"". ""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128d _mm_loadl_pd (__m128d a, double const* mem_addr)
    MOVLPD xmm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadu_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Load 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from memory into ""dst"".
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128d _mm_loadu_pd (double const* mem_address)
    MOVUPD xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadu_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Load 128-bits of integer data from memory into ""dst"".
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128i _mm_loadu_si128 (__m128i const* mem_address)
    MOVDQU xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_madd_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply packed signed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in ""dst"".
    
    __m128i _mm_madd_epi16 (__m128i a,  __m128i b)
    PMADDWD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_maskmoveu_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Conditionally store 8-bit integer elements from ""a"" into memory using ""mask"" (elements are not stored when the highest bit is not set in the corresponding element) and a non-temporal memory hint. ""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm_maskmoveu_si128 (__m128i a,  __m128i mask, char* mem_address)
    MASKMOVDQU xmm, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_max_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m128i _mm_max_epi16 (__m128i a,  __m128i b)
    PMAXSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed unsigned 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m128i _mm_max_epu8 (__m128i a,  __m128i b)
    PMAXUB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m128d _mm_max_pd (__m128d a,  __m128d b)
    MAXPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"", store the maximum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_max_sd (__m128d a,  __m128d b)
    MAXSD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 16-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m128i _mm_min_epi16 (__m128i a,  __m128i b)
    PMINSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed unsigned 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m128i _mm_min_epu8 (__m128i a,  __m128i b)
    PMINUB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m128d _mm_min_pd (__m128d a,  __m128d b)
    MINPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"", store the minimum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_min_sd (__m128d a,  __m128d b)
    MINSD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_move_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy the lower 64-bit integer in ""a"" to the lower element of ""dst"", and zero the upper element.
    
    __m128i _mm_move_epi64 (__m128i a)
    MOVQ xmm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_move_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Move the lower double-precision (64-bit) floating-point element from ""b"" to the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_move_sd (__m128d a, __m128d b)
    MOVSD xmm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_movemask_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Create mask from the most significant bit of each 8-bit element in ""a"", and store the result in ""dst"".
    
    int _mm_movemask_epi8 (__m128i a)
    PMOVMSKB reg, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_movemask_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Set each bit of mask ""dst"" based on the most significant bit of the corresponding packed double-precision (64-bit) floating-point element in ""a"".
    
    int _mm_movemask_pd (__m128d a)
    MOVMSKPD reg, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mul_epu32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the low unsigned 32-bit integers from each packed 64-bit element in ""a"" and ""b"", and store the unsigned 64-bit results in ""dst"".
    
    __m128i _mm_mul_epu32 (__m128i a,  __m128i b)
    PMULUDQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mul_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128d _mm_mul_pd (__m128d a,  __m128d b)
    MULPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mul_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the lower double-precision (64-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_mul_sd (__m128d a,  __m128d b)
    MULSD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mulhi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in ""dst"".
    
    __m128i _mm_mulhi_epi16 (__m128i a,  __m128i b)
    PMULHW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mulhi_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the packed unsigned 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in ""dst"".
    
    __m128i _mm_mulhi_epu16 (__m128i a,  __m128i b)
    PMULHUW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mullo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in ""dst"".
    
    __m128i _mm_mullo_epi16 (__m128i a,  __m128i b)
    PMULLW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_or_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise OR of packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128d _mm_or_pd (__m128d a,  __m128d b)
    ORPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_or_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise OR of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".
    
    __m128i _mm_or_si128 (__m128i a,  __m128i b)
    POR xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_packs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 16-bit integers from ""a"" and ""b"" to packed 8-bit integers using signed saturation, and store the results in ""dst"".
    
    __m128i _mm_packs_epi16 (__m128i a,  __m128i b)
    PACKSSWB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_packs_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 32-bit integers from ""a"" and ""b"" to packed 16-bit integers using signed saturation, and store the results in ""dst"".
    
    __m128i _mm_packs_epi32 (__m128i a,  __m128i b)
    PACKSSDW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_packus_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 16-bit integers from ""a"" and ""b"" to packed 8-bit integers using unsigned saturation, and store the results in ""dst"".
    
    __m128i _mm_packus_epi16 (__m128i a,  __m128i b)
    PACKUSWB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sad_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the absolute differences of packed unsigned 8-bit integers in ""a"" and ""b"", then horizontally sum each consecutive 8 differences to produce two unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in ""dst"".
    
    __m128i _mm_sad_epu8 (__m128i a,  __m128i b)
    PSADBW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_shuffle_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shuffle 32-bit integers in ""a"" using the control in ""imm8"", and store the results in ""dst"".
    
    __m128i _mm_shuffle_epi32 (__m128i a,  int immediate)
    PSHUFD xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_shuffle_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shuffle double-precision (64-bit) floating-point elements using the control in ""imm8"", and store the results in ""dst"".
    
    __m128d _mm_shuffle_pd (__m128d a,  __m128d b, int immediate)
    SHUFPD xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_shufflehi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shuffle 16-bit integers in the high 64 bits of ""a"" using the control in ""imm8"". Store the results in the high 64 bits of ""dst"", with the low 64 bits being copied from from ""a"" to ""dst"".
    
    __m128i _mm_shufflehi_epi16 (__m128i a,  int immediate)
    PSHUFHW xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_shufflelo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shuffle 16-bit integers in the low 64 bits of ""a"" using the control in ""imm8"". Store the results in the low 64 bits of ""dst"", with the high 64 bits being copied from from ""a"" to ""dst"".
    
    __m128i _mm_shufflelo_epi16 (__m128i a,  int control)
    PSHUFLW xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sll_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_sll_epi16 (__m128i a, __m128i count)
    PSLLW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sll_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_sll_epi32 (__m128i a, __m128i count)
    PSLLD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sll_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_sll_epi64 (__m128i a, __m128i count)
    PSLLQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_slli_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" left by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_slli_epi16 (__m128i a,  int immediate)
    PSLLW xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_slli_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" left by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_slli_epi32 (__m128i a,  int immediate)
    PSLLD xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_slli_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" left by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_slli_epi64 (__m128i a,  int immediate)
    PSLLQ xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sqrt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the square root of packed double-precision (64-bit) floating-point elements in ""a"", and store the results in ""dst"".
    
    __m128d _mm_sqrt_pd (__m128d a)
    SQRTPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sqrt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the square root of the lower double-precision (64-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_sqrt_sd (__m128d a, __m128d b)
    SQRTSD xmm, xmm/64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sqrt_sd1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the square root of the lower double-precision (64-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_sqrt_sd (__m128d a)
    SQRTSD xmm, xmm/64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sra_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""count"" while shifting in sign bits, and store the results in ""dst"".
    
    __m128i _mm_sra_epi16 (__m128i a, __m128i count)
    PSRAW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sra_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by ""count"" while shifting in sign bits, and store the results in ""dst"".
    
    __m128i _mm_sra_epi32 (__m128i a, __m128i count)
    PSRAD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srai_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""imm8"" while shifting in sign bits, and store the results in ""dst"".
    
    __m128i _mm_srai_epi16 (__m128i a,  int immediate)
    PSRAW xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srai_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by ""imm8"" while shifting in sign bits, and store the results in ""dst"".
    
    __m128i _mm_srai_epi32 (__m128i a,  int immediate)
    PSRAD xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srl_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_srl_epi16 (__m128i a, __m128i count)
    PSRLW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srl_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_srl_epi32 (__m128i a, __m128i count)
    PSRLD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srl_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_srl_epi64 (__m128i a, __m128i count)
    PSRLQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srli_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_srli_epi16 (__m128i a,  int immediate)
    PSRLW xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srli_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_srli_epi32 (__m128i a,  int immediate)
    PSRLD xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_srli_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 64-bit integers in ""a"" right by ""imm8"" while shifting in zeros, and store the results in ""dst"".
    
    __m128i _mm_srli_epi64 (__m128i a,  int immediate)
    PSRLQ xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_store_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from ""a"" into memory.
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    void _mm_store_pd (double* mem_addr, __m128d a)
    MOVAPD m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_store_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store the lower double-precision (64-bit) floating-point element from ""a"" into memory. ""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm_store_sd (double* mem_addr, __m128d a)
    MOVSD m64, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_store_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 128-bits of integer data from ""a"" into memory. 
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    void _mm_store_si128 (__m128i* mem_addr, __m128i a)
    MOVDQA m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storeh_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store the upper double-precision (64-bit) floating-point element from ""a"" into memory.
    
    void _mm_storeh_pd (double* mem_addr, __m128d a)
    MOVHPD m64, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storel_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 64-bit integer from the first element of ""a"" into memory.
    
    void _mm_storel_epi64 (__m128i* mem_addr, __m128i a)
    MOVQ m64, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storel_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store the lower double-precision (64-bit) floating-point element from ""a"" into memory.
    
    void _mm_storel_pd (double* mem_addr, __m128d a)
    MOVLPD m64, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storeu_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from ""a"" into memory.
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm_storeu_pd (double* mem_addr, __m128d a)
    MOVUPD m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storeu_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 128-bits of integer data from ""a"" into memory.
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm_storeu_si128 (__m128i* mem_addr, __m128i a)
    MOVDQU m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storeu_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 32-bit integer from the first element of ""a"" into memory. ""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm_storeu_si32 (void* mem_addr, __m128i a) MOVD m32, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_stream_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 128-bits (composed of 2 packed double-precision (64-bit) floating-point elements) from ""a"" into memory using a non-temporal memory hint.
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    void _mm_stream_pd (double* mem_addr, __m128d a)
    MOVNTPD m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_stream_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 128-bits of integer data from ""a"" into memory using a non-temporal memory hint. 
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    void _mm_stream_si128 (__m128i* mem_addr, __m128i a)
    MOVNTDQ m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_stream_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 32-bit integer ""a"" into memory using a non-temporal hint to minimize cache pollution. If the cache line containing address ""mem_addr"" is already in the cache, the cache will be updated.
    
    void _mm_stream_si32(int *p, int a)
    MOVNTI m32, r32";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_sub_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed 16-bit integers in ""b"" from packed 16-bit integers in ""a"", and store the results in ""dst"".
    
    __m128i _mm_sub_epi16 (__m128i a,  __m128i b)
    PSUBW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sub_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed 32-bit integers in ""b"" from packed 32-bit integers in ""a"", and store the results in ""dst"".
    
    __m128i _mm_sub_epi32 (__m128i a,  __m128i b)
    PSUBD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sub_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed 64-bit integers in ""b"" from packed 64-bit integers in ""a"", and store the results in ""dst"".
    
    __m128i _mm_sub_epi64 (__m128i a,  __m128i b)
    PSUBQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sub_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"", and store the results in ""dst"".
    
    __m128i _mm_sub_epi8 (__m128i a,  __m128i b)
    PSUBB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sub_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed double-precision (64-bit) floating-point elements in ""b"" from packed double-precision (64-bit) floating-point elements in ""a"", and store the results in ""dst"".
    
    __m128d _mm_sub_pd (__m128d a, __m128d b)
    SUBPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sub_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract the lower double-precision (64-bit) floating-point element in ""b"" from the lower double-precision (64-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_sub_sd (__m128d a, __m128d b)
    SUBSD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_subs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed 16-bit integers in ""b"" from packed 16-bit integers in ""a"" using saturation, and store the results in ""dst"".
    
    __m128i _mm_subs_epi16 (__m128i a,  __m128i b)
    PSUBSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_subs_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"" using saturation, and store the results in ""dst"".
    
    __m128i _mm_subs_epi8 (__m128i a,  __m128i b)
    PSUBSB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_subs_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed unsigned 16-bit integers in ""b"" from packed unsigned 16-bit integers in ""a"" using saturation, and store the results in ""dst"".
    
    __m128i _mm_subs_epu16 (__m128i a,  __m128i b)
    PSUBUSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_subs_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed unsigned 8-bit integers in ""b"" from packed unsigned 8-bit integers in ""a"" using saturation, and store the results in ""dst"".
    
    __m128i _mm_subs_epu8 (__m128i a,  __m128i b)
    PSUBUSB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomieq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomieq_sd (__m128d a, __m128d b)
    UCOMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomige_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomige_sd (__m128d a, __m128d b)
    UCOMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomigt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomigt_sd (__m128d a, __m128d b)
    UCOMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomile_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomile_sd (__m128d a, __m128d b)
    UCOMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomilt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomilt_sd (__m128d a, __m128d b)
    UCOMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomineq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomineq_sd (__m128d a, __m128d b)
    UCOMISD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpackhi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 16-bit integers from the high half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_unpackhi_epi16 (__m128i a,  __m128i b)
    PUNPCKHWD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpackhi_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 32-bit integers from the high half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_unpackhi_epi32 (__m128i a,  __m128i b)
    PUNPCKHDQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpackhi_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 64-bit integers from the high half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_unpackhi_epi64 (__m128i a,  __m128i b)
    PUNPCKHQDQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpackhi_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the high half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_unpackhi_epi8 (__m128i a,  __m128i b)
    PUNPCKHBW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpackhi_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave double-precision (64-bit) floating-point elements from the high half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128d _mm_unpackhi_pd (__m128d a,  __m128d b)
    UNPCKHPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpacklo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 16-bit integers from the low half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_unpacklo_epi16 (__m128i a,  __m128i b)
    PUNPCKLWD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpacklo_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 32-bit integers from the low half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_unpacklo_epi32 (__m128i a,  __m128i b)
    PUNPCKLDQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpacklo_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 64-bit integers from the low half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_unpacklo_epi64 (__m128i a,  __m128i b)
    PUNPCKLQDQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpacklo_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the low half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128i _mm_unpacklo_epi8 (__m128i a,  __m128i b)
    PUNPCKLBW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpacklo_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave double-precision (64-bit) floating-point elements from the low half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128d _mm_unpacklo_pd (__m128d a,  __m128d b)
    UNPCKLPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_xor_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise XOR of packed double-precision (64-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128d _mm_xor_pd (__m128d a,  __m128d b)
    XORPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_xor_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise XOR of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".
    
    __m128i _mm_xor_si128 (__m128i a,  __m128i b)
    PXOR xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse2X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_cvtsd_si64", (Func<object, long>)mm_cvtsd_si64);
            RegisterFunction("mm_cvtsi128_si64", (Func<object, long>)mm_cvtsi128_si64);
            RegisterFunction("mm_cvtsi64_sd", (Func<object, long, object>)mm_cvtsi64_sd);
            RegisterFunction("mm_cvtsi64_si128", (Func<long, object>)mm_cvtsi64_si128);
            RegisterFunction("mm_cvttsd_si64", (Func<object, long>)mm_cvttsd_si64);
            RegisterAction("mm_stream_si64", (Action<object, long>)mm_stream_si64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_cvtsd_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""a"" to a 64-bit integer, and store the result in ""dst"".
    
    __int64 _mm_cvtsd_si64 (__m128d a)
    CVTSD2SI r64, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsi128_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy the lower 64-bit integer in ""a"" to ""dst"".
    
    __int64 _mm_cvtsi128_si64 (__m128i a)
    MOVQ reg/m64, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsi64_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the 64-bit integer ""b"" to a double-precision (64-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_cvtsi64_sd (__m128d a, __int64 b)
    CVTSI2SD xmm, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsi64_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy 64-bit integer ""a"" to the lower element of ""dst"", and zero the upper element.
    
    __m128i _mm_cvtsi64_si128 (__int64 a)
    MOVQ xmm, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvttsd_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""a"" to a 64-bit integer with truncation, and store the result in ""dst"".
    
    __int64 _mm_cvttsd_si64 (__m128d a)
    CVTTSD2SI reg, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_stream_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Store 64-bit integer ""a"" into memory using a non-temporal hint to minimize cache pollution. If the cache line containing address ""mem_addr"" is already in the cache, the cache will be updated.
    
    void _mm_stream_si64(__int64 *p, __int64 a)
    MOVNTI m64, r64";
                descriptor.IsCommand = true;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse3IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_addsub_pd", (Func<object, object, object>)mm_addsub_pd);
            RegisterFunction("mm_addsub_ps", (Func<object, object, object>)mm_addsub_ps);
            RegisterFunction("mm_hadd_pd", (Func<object, object, object>)mm_hadd_pd);
            RegisterFunction("mm_hadd_ps", (Func<object, object, object>)mm_hadd_ps);
            RegisterFunction("mm_hsub_pd", (Func<object, object, object>)mm_hsub_pd);
            RegisterFunction("mm_hsub_ps", (Func<object, object, object>)mm_hsub_ps);
            RegisterFunction("mm_lddqu_si128", (Func<object, object>)mm_lddqu_si128);
            RegisterFunction("mm_loaddup_pd", (Func<object, object>)mm_loaddup_pd);
            RegisterFunction("mm_movedup_pd", (Func<object, object>)mm_movedup_pd);
            RegisterFunction("mm_movehdup_ps", (Func<object, object>)mm_movehdup_ps);
            RegisterFunction("mm_moveldup_ps", (Func<object, object>)mm_moveldup_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_addsub_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Alternatively add and subtract packed double-precision (64-bit) floating-point elements in ""a"" to/from packed elements in ""b"", and store the results in ""dst"".
    
    __m128d _mm_addsub_pd (__m128d a, __m128d b)
    ADDSUBPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_addsub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Alternatively add and subtract packed single-precision (32-bit) floating-point elements in ""a"" to/from packed elements in ""b"", and store the results in ""dst"".
    
    __m128 _mm_addsub_ps (__m128 a, __m128 b)
    ADDSUBPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hadd_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of double-precision (64-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".
    
    __m128d _mm_hadd_pd (__m128d a, __m128d b)
    HADDPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hadd_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".
    
    __m128 _mm_hadd_ps (__m128 a, __m128 b)
    HADDPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hsub_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Horizontally subtract adjacent pairs of double-precision (64-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".
    
    __m128d _mm_hsub_pd (__m128d a, __m128d b)
    HSUBPD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hsub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".
    
    __m128 _mm_hsub_ps (__m128 a, __m128 b)
    HSUBPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_lddqu_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Load 128-bits of integer data from unaligned memory into ""dst"". This intrinsic may perform better than ""_mm_loadu_si128"" when the data crosses a cache line boundary.
    
    __m128i _mm_lddqu_si128 (__m128i const* mem_addr)
    LDDQU xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loaddup_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Load a double-precision (64-bit) floating-point element from memory into both elements of ""dst"".
    
    __m128d _mm_loaddup_pd (double const* mem_addr)
    MOVDDUP xmm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_movedup_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Duplicate the low double-precision (64-bit) floating-point element from ""a"", and store the results in ""dst"".
    
    __m128d _mm_movedup_pd (__m128d a)
    MOVDDUP xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_movehdup_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Duplicate odd-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".
    
    __m128 _mm_movehdup_ps (__m128 a)
    MOVSHDUP xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_moveldup_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Duplicate even-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".
    
    __m128 _mm_moveldup_ps (__m128 a)
    MOVSLDUP xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse41IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_blend_epi16", (Func<object, object, byte, object>)mm_blend_epi16);
            RegisterFunction("mm_blend_pd", (Func<object, object, byte, object>)mm_blend_pd);
            RegisterFunction("mm_blend_ps", (Func<object, object, byte, object>)mm_blend_ps);
            RegisterFunction("mm_blendv_epi8", (Func<object, object, object, object>)mm_blendv_epi8);
            RegisterFunction("mm_blendv_pd", (Func<object, object, object, object>)mm_blendv_pd);
            RegisterFunction("mm_blendv_ps", (Func<object, object, object, object>)mm_blendv_ps);
            RegisterFunction("mm_ceil_pd", (Func<object, object>)mm_ceil_pd);
            RegisterFunction("mm_ceil_ps", (Func<object, object>)mm_ceil_ps);
            RegisterFunction("mm_ceil_sd", (Func<object, object, object>)mm_ceil_sd);
            RegisterFunction("mm_ceil_sd1", (Func<object, object>)mm_ceil_sd1);
            RegisterFunction("mm_ceil_ss", (Func<object, object, object>)mm_ceil_ss);
            RegisterFunction("mm_cmpeq_epi64", (Func<object, object, object>)mm_cmpeq_epi64);
            RegisterFunction("mm_cvtepi16_epi32", (Func<object, object>)mm_cvtepi16_epi32);
            RegisterFunction("mm_cvtepi16_epi64", (Func<object, object>)mm_cvtepi16_epi64);
            RegisterFunction("mm_cvtepi32_epi64", (Func<object, object>)mm_cvtepi32_epi64);
            RegisterFunction("mm_cvtepi8_epi16", (Func<object, object>)mm_cvtepi8_epi16);
            RegisterFunction("mm_cvtepi8_epi32", (Func<object, object>)mm_cvtepi8_epi32);
            RegisterFunction("mm_cvtepi8_epi64", (Func<object, object>)mm_cvtepi8_epi64);
            RegisterFunction("mm_cvtepu16_epi32", (Func<object, object>)mm_cvtepu16_epi32);
            RegisterFunction("mm_cvtepu16_epi64", (Func<object, object>)mm_cvtepu16_epi64);
            RegisterFunction("mm_cvtepu32_epi64", (Func<object, object>)mm_cvtepu32_epi64);
            RegisterFunction("mm_cvtepu8_epi16", (Func<object, object>)mm_cvtepu8_epi16);
            RegisterFunction("mm_cvtepu8_epi32", (Func<object, object>)mm_cvtepu8_epi32);
            RegisterFunction("mm_cvtepu8_epi64", (Func<object, object>)mm_cvtepu8_epi64);
            RegisterFunction("mm_dp_pd", (Func<object, object, byte, object>)mm_dp_pd);
            RegisterFunction("mm_dp_ps", (Func<object, object, byte, object>)mm_dp_ps);
            RegisterFunction("mm_extract_epi32", (Func<object, byte, int>)mm_extract_epi32);
            RegisterFunction("mm_extract_epi8", (Func<object, byte, byte>)mm_extract_epi8);
            RegisterFunction("mm_extract_ps", (Func<object, byte, float>)mm_extract_ps);
            RegisterFunction("mm_floor_pd", (Func<object, object>)mm_floor_pd);
            RegisterFunction("mm_floor_ps", (Func<object, object>)mm_floor_ps);
            RegisterFunction("mm_floor_sd", (Func<object, object, object>)mm_floor_sd);
            RegisterFunction("mm_floor_sd1", (Func<object, object>)mm_floor_sd1);
            RegisterFunction("mm_floor_ss", (Func<object, object, object>)mm_floor_ss);
            RegisterFunction("mm_insert_epi32", (Func<object, int, byte, object>)mm_insert_epi32);
            RegisterFunction("mm_insert_epi8", (Func<object, byte, byte, object>)mm_insert_epi8);
            RegisterFunction("mm_insert_ps", (Func<object, object, byte, object>)mm_insert_ps);
            RegisterFunction("mm_max_epi32", (Func<object, object, object>)mm_max_epi32);
            RegisterFunction("mm_max_epi8", (Func<object, object, object>)mm_max_epi8);
            RegisterFunction("mm_max_epu16", (Func<object, object, object>)mm_max_epu16);
            RegisterFunction("mm_max_epu32", (Func<object, object, object>)mm_max_epu32);
            RegisterFunction("mm_min_epi32", (Func<object, object, object>)mm_min_epi32);
            RegisterFunction("mm_min_epi8", (Func<object, object, object>)mm_min_epi8);
            RegisterFunction("mm_min_epu16", (Func<object, object, object>)mm_min_epu16);
            RegisterFunction("mm_min_epu32", (Func<object, object, object>)mm_min_epu32);
            RegisterFunction("mm_minpos_epu16", (Func<object, object>)mm_minpos_epu16);
            RegisterFunction("mm_mpsadbw_epu8", (Func<object, object, byte, object>)mm_mpsadbw_epu8);
            RegisterFunction("mm_mul_epi32", (Func<object, object, object>)mm_mul_epi32);
            RegisterFunction("mm_mullo_epi32", (Func<object, object, object>)mm_mullo_epi32);
            RegisterFunction("mm_packus_epi32", (Func<object, object, object>)mm_packus_epi32);
            RegisterFunction("mm_round_pd1", (Func<object, object>)mm_round_pd1);
            RegisterFunction("mm_round_pd1_to_nearest_integer", (Func<object, object>)mm_round_pd1_to_nearest_integer);
            RegisterFunction("mm_round_pd1_to_negative_infinity", (Func<object, object>)mm_round_pd1_to_negative_infinity);
            RegisterFunction("mm_round_pd1_to_positive_infinity", (Func<object, object>)mm_round_pd1_to_positive_infinity);
            RegisterFunction("mm_round_pd1_to_zero", (Func<object, object>)mm_round_pd1_to_zero);
            RegisterFunction("mm_round_ps", (Func<object, object>)mm_round_ps);
            RegisterFunction("mm_round_ps_to_nearest_integer", (Func<object, object>)mm_round_ps_to_nearest_integer);
            RegisterFunction("mm_round_ps_to_negative_infinity", (Func<object, object>)mm_round_ps_to_negative_infinity);
            RegisterFunction("mm_round_ps_to_positive_infinity", (Func<object, object>)mm_round_ps_to_positive_infinity);
            RegisterFunction("mm_round_ps_to_zero", (Func<object, object>)mm_round_ps_to_zero);
            RegisterFunction("mm_round_sd", (Func<object, object, object>)mm_round_sd);
            RegisterFunction("mm_round_sd_to_nearest_integer_scalar", (Func<object, object, object>)mm_round_sd_to_nearest_integer_scalar);
            RegisterFunction("mm_round_sd_to_negative_infinity_scalar", (Func<object, object, object>)mm_round_sd_to_negative_infinity_scalar);
            RegisterFunction("mm_round_sd_to_positive_infinity_scalar", (Func<object, object, object>)mm_round_sd_to_positive_infinity_scalar);
            RegisterFunction("mm_round_sd_to_zero_scalar", (Func<object, object, object>)mm_round_sd_to_zero_scalar);
            RegisterFunction("mm_round_sd1", (Func<object, object>)mm_round_sd1);
            RegisterFunction("mm_round_sd1_to_nearest_integer_scalar", (Func<object, object>)mm_round_sd1_to_nearest_integer_scalar);
            RegisterFunction("mm_round_sd1_to_negative_infinity_scalar", (Func<object, object>)mm_round_sd1_to_negative_infinity_scalar);
            RegisterFunction("mm_round_sd1_to_positive_infinity_scalar", (Func<object, object>)mm_round_sd1_to_positive_infinity_scalar);
            RegisterFunction("mm_round_sd1_to_zero_scalar", (Func<object, object>)mm_round_sd1_to_zero_scalar);
            RegisterFunction("mm_round_ss", (Func<object, object, object>)mm_round_ss);
            RegisterFunction("mm_round_ss_to_nearest_integer_scalar", (Func<object, object, object>)mm_round_ss_to_nearest_integer_scalar);
            RegisterFunction("mm_round_ss_to_negative_infinity_scalar", (Func<object, object, object>)mm_round_ss_to_negative_infinity_scalar);
            RegisterFunction("mm_round_ss_to_positive_infinity_scalar", (Func<object, object, object>)mm_round_ss_to_positive_infinity_scalar);
            RegisterFunction("mm_round_ss_to_zero_scalar", (Func<object, object, object>)mm_round_ss_to_zero_scalar);
            RegisterFunction("mm_round_ss1", (Func<object, object>)mm_round_ss1);
            RegisterFunction("mm_round_ss1_to_nearest_integer_scalar", (Func<object, object>)mm_round_ss1_to_nearest_integer_scalar);
            RegisterFunction("mm_round_ss1_to_negative_infinity_scalar", (Func<object, object>)mm_round_ss1_to_negative_infinity_scalar);
            RegisterFunction("mm_round_ss1_to_positive_infinity_scalar", (Func<object, object>)mm_round_ss1_to_positive_infinity_scalar);
            RegisterFunction("mm_round_ss1_to_zero_scalar", (Func<object, object>)mm_round_ss1_to_zero_scalar);
            RegisterFunction("mm_stream_load_si128", (Func<object, object>)mm_stream_load_si128);
            RegisterFunction("mm_testc_si128", (Func<object, object, Kalk.Core.KalkBool>)mm_testc_si128);
            RegisterFunction("mm_testnzc_si128", (Func<object, object, Kalk.Core.KalkBool>)mm_testnzc_si128);
            RegisterFunction("mm_testz_si128", (Func<object, object, Kalk.Core.KalkBool>)mm_testz_si128);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_blend_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Blend packed 16-bit integers from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".
    
    __m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8)
    PBLENDW xmm, xmm/m128 imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_blend_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Blend packed double-precision (64-bit) floating-point elements from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".
    
    __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8)
    BLENDPD xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_blend_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Blend packed single-precision (32-bit) floating-point elements from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".
    
    __m128 _mm_blend_ps (__m128 a, __m128 b, const int imm8)
    BLENDPS xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_blendv_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Blend packed 8-bit integers from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".
    
    __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)
    PBLENDVB xmm, xmm/m128, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_blendv_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Blend packed double-precision (64-bit) floating-point elements from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".
    
    __m128d _mm_blendv_pd (__m128d a, __m128d b, __m128d mask)
    BLENDVPD xmm, xmm/m128, xmm0";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_blendv_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Blend packed single-precision (32-bit) floating-point elements from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".
    
    __m128 _mm_blendv_ps (__m128 a, __m128 b, __m128 mask)
    BLENDVPS xmm, xmm/m128, xmm0";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ceil_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" up to an integer value, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m128d _mm_ceil_pd (__m128d a)
    ROUNDPD xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ceil_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" up to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m128 _mm_ceil_ps (__m128 a)
    ROUNDPS xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ceil_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" up to an integer value, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_ceil_sd (__m128d a, __m128d b)
    ROUNDSD xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ceil_sd1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" up to an integer value, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_ceil_sd (__m128d a)
    ROUNDSD xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ceil_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" up to an integer value, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_ceil_ss (__m128 a, __m128 b)
    ROUNDSS xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpeq_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed 64-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m128i _mm_cmpeq_epi64 (__m128i a, __m128i b)
    PCMPEQQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepi16_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 16-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepi16_epi32 (__m128i a)
    PMOVSXWD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepi16_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 16-bit integers in ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepi16_epi64 (__m128i a)
    PMOVSXWQ xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepi32_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 32-bit integers in ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepi32_epi64 (__m128i a)
    PMOVSXDQ xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepi8_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 8-bit integers in ""a"" to packed 16-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepi8_epi16 (__m128i a)
    PMOVSXBW xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepi8_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 8-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepi8_epi32 (__m128i a)
    PMOVSXBD xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepi8_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 8-bit integers in the low 8 bytes of ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepi8_epi64 (__m128i a)
    PMOVSXBQ xmm, xmm/m16";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepu16_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Zero extend packed unsigned 16-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepu16_epi32 (__m128i a)
    PMOVZXWD xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepu16_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Zero extend packed unsigned 16-bit integers in ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepu16_epi64 (__m128i a)
    PMOVZXWQ xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepu32_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Zero extend packed unsigned 32-bit integers in ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepu32_epi64 (__m128i a)
    PMOVZXDQ xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepu8_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Zero extend packed unsigned 8-bit integers in ""a"" to packed 16-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepu8_epi16 (__m128i a)
    PMOVZXBW xmm, xmm/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepu8_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Zero extend packed unsigned 8-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepu8_epi32 (__m128i a)
    PMOVZXBD xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtepu8_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Zero extend packed unsigned 8-bit integers in the low 8 byte sof ""a"" to packed 64-bit integers, and store the results in ""dst"".
    
    __m128i _mm_cvtepu8_epi64 (__m128i a)
    PMOVZXBQ xmm, xmm/m16";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_dp_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Conditionally multiply the packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" using the high 4 bits in ""imm8"", sum the four products, and conditionally store the sum in ""dst"" using the low 4 bits of ""imm8"".
    
    __m128d _mm_dp_pd (__m128d a, __m128d b, const int imm8)
    DPPD xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_dp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Conditionally multiply the packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" using the high 4 bits in ""imm8"", sum the four products, and conditionally store the sum in ""dst"" using the low 4 bits of ""imm8"".
    
    __m128 _mm_dp_ps (__m128 a, __m128 b, const int imm8)
    DPPS xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_extract_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Extract a 32-bit integer from ""a"", selected with ""imm8"", and store the result in ""dst"".
    
    int _mm_extract_epi32 (__m128i a, const int imm8)
    PEXTRD reg/m32, xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_extract_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Extract an 8-bit integer from ""a"", selected with ""imm8"", and store the result in the lower element of ""dst"".
    
    int _mm_extract_epi8 (__m128i a, const int imm8)
    PEXTRB reg/m8, xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_extract_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Extract a single-precision (32-bit) floating-point element from ""a"", selected with ""imm8"", and store the result in ""dst"".
    
    int _mm_extract_ps (__m128 a, const int imm8)
    EXTRACTPS xmm, xmm/m32, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_floor_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" down to an integer value, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m128d _mm_floor_pd (__m128d a)
    ROUNDPD xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_floor_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" down to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m128 _mm_floor_ps (__m128 a)
    ROUNDPS xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_floor_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" down to an integer value, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_floor_sd (__m128d a, __m128d b)
    ROUNDSD xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_floor_sd1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" down to an integer value, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_floor_sd (__m128d a)
    ROUNDSD xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_floor_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" down to an integer value, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_floor_ss (__m128 a, __m128 b)
    ROUNDSS xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_insert_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Copy ""a"" to ""dst"", and insert the 32-bit integer ""i"" into ""dst"" at the location specified by ""imm8"".
    
    __m128i _mm_insert_epi32 (__m128i a, int i, const int imm8)
    PINSRD xmm, reg/m32, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_insert_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Copy ""a"" to ""dst"", and insert the lower 8-bit integer from ""i"" into ""dst"" at the location specified by ""imm8"".
    
    __m128i _mm_insert_epi8 (__m128i a, int i, const int imm8)
    PINSRB xmm, reg/m8, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_insert_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Copy ""a"" to ""tmp"", then insert a single-precision (32-bit) floating-point element from ""b"" into ""tmp"" using the control in ""imm8"". Store ""tmp"" to ""dst"" using the mask in ""imm8"" (elements are zeroed out when the corresponding bit is set).
    
    __m128 _mm_insert_ps (__m128 a, __m128 b, const int imm8)
    INSERTPS xmm, xmm/m32, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m128i _mm_max_epi32 (__m128i a, __m128i b)
    PMAXSD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m128i _mm_max_epi8 (__m128i a, __m128i b)
    PMAXSB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed unsigned 16-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m128i _mm_max_epu16 (__m128i a, __m128i b)
    PMAXUW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_epu32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed unsigned 32-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m128i _mm_max_epu32 (__m128i a, __m128i b)
    PMAXUD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed 32-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m128i _mm_min_epi32 (__m128i a, __m128i b)
    PMINSD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m128i _mm_min_epi8 (__m128i a, __m128i b)
    PMINSB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed unsigned 16-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m128i _mm_min_epu16 (__m128i a, __m128i b)
    PMINUW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_epu32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed unsigned 32-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m128i _mm_min_epu32 (__m128i a, __m128i b)
    PMINUD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_minpos_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Horizontally compute the minimum amongst the packed unsigned 16-bit integers in ""a"", store the minimum and index in ""dst"", and zero the remaining bits in ""dst"".
    
    __m128i _mm_minpos_epu16 (__m128i a)
    PHMINPOSUW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mpsadbw_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in ""a"" compared to those in ""b"", and store the 16-bit results in ""dst"".
    	Eight SADs are performed using one quadruplet from ""b"" and eight quadruplets from ""a"". One quadruplet is selected from ""b"" starting at on the offset specified in ""imm8"". Eight quadruplets are formed from sequential 8-bit integers selected from ""a"" starting at the offset specified in ""imm8"".
    
    __m128i _mm_mpsadbw_epu8 (__m128i a, __m128i b, const int imm8)
    MPSADBW xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mul_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Multiply the low 32-bit integers from each packed 64-bit element in ""a"" and ""b"", and store the signed 64-bit results in ""dst"".
    
    __m128i _mm_mul_epi32 (__m128i a, __m128i b)
    PMULDQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mullo_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Multiply the packed 32-bit integers in ""a"" and ""b"", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in ""dst"".
    
    __m128i _mm_mullo_epi32 (__m128i a, __m128i b)
    PMULLD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_packus_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Convert packed 32-bit integers from ""a"" and ""b"" to packed 16-bit integers using unsigned saturation, and store the results in ""dst"".
    
    __m128i _mm_packus_epi32 (__m128i a, __m128i b)
    PACKUSDW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_pd1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m128d _mm_round_pd (__m128d a, _MM_FROUND_CUR_DIRECTION); ROUNDPD xmm, xmm/m128, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_pd1_to_nearest_integer"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m128d _mm_round_pd (__m128d a, int rounding)
    ROUNDPD xmm, xmm/m128, imm8(8)
                _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_pd1_to_negative_infinity"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m128d _mm_round_pd (__m128d a, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC); ROUNDPD xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_pd1_to_positive_infinity"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m128d _mm_round_pd (__m128d a, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC); ROUNDPD xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_pd1_to_zero"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed double-precision (64-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed double-precision floating-point elements in ""dst"".
    
    __m128d _mm_round_pd (__m128d a, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC); ROUNDPD xmm, xmm/m128, imm8(11)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m128 _mm_round_ps (__m128 a, _MM_FROUND_CUR_DIRECTION); ROUNDPS xmm, xmm/m128, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ps_to_nearest_integer"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m128 _mm_round_ps (__m128 a, int rounding)
    ROUNDPS xmm, xmm/m128, imm8(8)
                _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ps_to_negative_infinity"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m128 _mm_round_ps (__m128 a, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC); ROUNDPS xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ps_to_positive_infinity"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m128 _mm_round_ps (__m128 a, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC); ROUNDPS xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ps_to_zero"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".
    
    __m128 _mm_round_ps (__m128 a, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC); ROUNDPS xmm, xmm/m128, imm8(11)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_CUR_DIRECTION)
    ROUNDSD xmm, xmm/m128, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd_to_nearest_integer_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC)
    ROUNDSD xmm, xmm/m128, imm8(8)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd_to_negative_infinity_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)
    ROUNDSD xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd_to_positive_infinity_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)
    ROUNDSD xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd_to_zero_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, __m128d b, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)
    ROUNDSD xmm, xmm/m128, imm8(11)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, _MM_FROUND_CUR_DIRECTION)
    ROUNDSD xmm, xmm/m128, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd1_to_nearest_integer_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC)
    ROUNDSD xmm, xmm/m128, imm8(8)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd1_to_negative_infinity_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)
    ROUNDSD xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd1_to_positive_infinity_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)
    ROUNDSD xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_sd1_to_zero_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128d _mm_round_sd (__m128d a, _MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)
    ROUNDSD xmm, xmm/m128, imm8(11)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_CUR_DIRECTION)
    ROUNDSS xmm, xmm/m128, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss_to_nearest_integer_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
    ROUNDSS xmm, xmm/m128, imm8(8)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss_to_negative_infinity_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
    ROUNDSS xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss_to_positive_infinity_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
    ROUNDSS xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss_to_zero_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, __m128 b, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
    ROUNDSS xmm, xmm/m128, imm8(11)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, _MM_FROUND_CUR_DIRECTION)
    ROUNDSS xmm, xmm/m128, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss1_to_nearest_integer_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC)
    ROUNDSS xmm, xmm/m128, imm8(8)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss1_to_negative_infinity_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_NEG_INF | _MM_FROUND_NO_EXC)
    ROUNDSS xmm, xmm/m128, imm8(9)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss1_to_positive_infinity_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_POS_INF | _MM_FROUND_NO_EXC)
    ROUNDSS xmm, xmm/m128, imm8(10)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_round_ss1_to_zero_scalar"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower single-precision (32-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a single-precision floating-point element in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_round_ss (__m128 a, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC)
    ROUNDSS xmm, xmm/m128, imm8(11)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_stream_load_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Load 128-bits of integer data from memory into ""dst"" using a non-temporal memory hint.
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    __m128i _mm_stream_load_si128 (const __m128i* mem_addr)
    MOVNTDQA xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testc_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return the ""CF"" value.
    
    int _mm_testc_si128 (__m128i a, __m128i b)
    PTEST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testnzc_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return 1 if both the ""ZF"" and ""CF"" values are zero, otherwise return 0.
    
    int _mm_testnzc_si128 (__m128i a, __m128i b)
    PTEST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_testz_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return the ""ZF"" value.
    
    int _mm_testz_si128 (__m128i a, __m128i b)
    PTEST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse41X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_extract_epi64", (Func<object, byte, long>)mm_extract_epi64);
            RegisterFunction("mm_insert_epi64", (Func<object, long, byte, object>)mm_insert_epi64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_extract_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Extract a 64-bit integer from ""a"", selected with ""imm8"", and store the result in ""dst"".
    
    __int64 _mm_extract_epi64 (__m128i a, const int imm8)
    PEXTRQ reg/m64, xmm, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_insert_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Copy ""a"" to ""dst"", and insert the 64-bit integer ""i"" into ""dst"" at the location specified by ""imm8"".
    
    __m128i _mm_insert_epi64 (__m128i a, __int64 i, const int imm8)
    PINSRQ xmm, reg/m64, imm8";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse42IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_cmpgt_epi64", (Func<object, object, object>)mm_cmpgt_epi64);
            RegisterFunction("mm_crc32_u16", (Func<uint, ushort, uint>)mm_crc32_u16);
            RegisterFunction("mm_crc32_u32", (Func<uint, uint, uint>)mm_crc32_u32);
            RegisterFunction("mm_crc32_u8", (Func<uint, byte, uint>)mm_crc32_u8);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_cmpgt_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE42";
                descriptor.Description = @"Compare packed 64-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m128i _mm_cmpgt_epi64 (__m128i a, __m128i b)
    PCMPGTQ xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_crc32_u16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE42";
                descriptor.Description = @"Starting with the initial value in ""crc"", accumulates a CRC32 value for unsigned 16-bit integer ""v"", and stores the result in ""dst"".
    
    unsigned int _mm_crc32_u16 (unsigned int crc, unsigned short v)
    CRC32 reg, reg/m16";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_crc32_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE42";
                descriptor.Description = @"Starting with the initial value in ""crc"", accumulates a CRC32 value for unsigned 32-bit integer ""v"", and stores the result in ""dst"".
    
    unsigned int _mm_crc32_u32 (unsigned int crc, unsigned int v)
    CRC32 reg, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_crc32_u8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE42";
                descriptor.Description = @"Starting with the initial value in ""crc"", accumulates a CRC32 value for unsigned 8-bit integer ""v"", and stores the result in ""dst"".
    
    unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v)
    CRC32 reg, reg/m8";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse42X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_crc32_u64", (Func<ulong, ulong, ulong>)mm_crc32_u64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_crc32_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE42";
                descriptor.Description = @"Starting with the initial value in ""crc"", accumulates a CRC32 value for unsigned 64-bit integer ""v"", and stores the result in ""dst"".
    
    unsigned __int64 _mm_crc32_u64 (unsigned __int64 crc, unsigned __int64 v)
    CRC32 reg, reg/m64";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class SseIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_add_ps", (Func<object, object, object>)mm_add_ps);
            RegisterFunction("mm_add_ss", (Func<object, object, object>)mm_add_ss);
            RegisterFunction("mm_and_ps", (Func<object, object, object>)mm_and_ps);
            RegisterFunction("mm_andnot_ps", (Func<object, object, object>)mm_andnot_ps);
            RegisterFunction("mm_cmpeq_ps", (Func<object, object, object>)mm_cmpeq_ps);
            RegisterFunction("mm_cmpeq_ss", (Func<object, object, object>)mm_cmpeq_ss);
            RegisterFunction("mm_cmpge_ps", (Func<object, object, object>)mm_cmpge_ps);
            RegisterFunction("mm_cmpge_ss", (Func<object, object, object>)mm_cmpge_ss);
            RegisterFunction("mm_cmpgt_ps", (Func<object, object, object>)mm_cmpgt_ps);
            RegisterFunction("mm_cmpgt_ss", (Func<object, object, object>)mm_cmpgt_ss);
            RegisterFunction("mm_cmple_ps", (Func<object, object, object>)mm_cmple_ps);
            RegisterFunction("mm_cmple_ss", (Func<object, object, object>)mm_cmple_ss);
            RegisterFunction("mm_cmplt_ps", (Func<object, object, object>)mm_cmplt_ps);
            RegisterFunction("mm_cmplt_ss", (Func<object, object, object>)mm_cmplt_ss);
            RegisterFunction("mm_cmpneq_ps", (Func<object, object, object>)mm_cmpneq_ps);
            RegisterFunction("mm_cmpneq_ss", (Func<object, object, object>)mm_cmpneq_ss);
            RegisterFunction("mm_cmpnge_ps", (Func<object, object, object>)mm_cmpnge_ps);
            RegisterFunction("mm_cmpnge_ss", (Func<object, object, object>)mm_cmpnge_ss);
            RegisterFunction("mm_cmpngt_ps", (Func<object, object, object>)mm_cmpngt_ps);
            RegisterFunction("mm_cmpngt_ss", (Func<object, object, object>)mm_cmpngt_ss);
            RegisterFunction("mm_cmpnle_ps", (Func<object, object, object>)mm_cmpnle_ps);
            RegisterFunction("mm_cmpnle_ss", (Func<object, object, object>)mm_cmpnle_ss);
            RegisterFunction("mm_cmpnlt_ps", (Func<object, object, object>)mm_cmpnlt_ps);
            RegisterFunction("mm_cmpnlt_ss", (Func<object, object, object>)mm_cmpnlt_ss);
            RegisterFunction("mm_cmpord_ps", (Func<object, object, object>)mm_cmpord_ps);
            RegisterFunction("mm_cmpord_ss", (Func<object, object, object>)mm_cmpord_ss);
            RegisterFunction("mm_cmpunord_ps", (Func<object, object, object>)mm_cmpunord_ps);
            RegisterFunction("mm_cmpunord_ss", (Func<object, object, object>)mm_cmpunord_ss);
            RegisterFunction("mm_comieq_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_comieq_ss);
            RegisterFunction("mm_comige_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_comige_ss);
            RegisterFunction("mm_comigt_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_comigt_ss);
            RegisterFunction("mm_comile_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_comile_ss);
            RegisterFunction("mm_comilt_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_comilt_ss);
            RegisterFunction("mm_comineq_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_comineq_ss);
            RegisterFunction("mm_cvtsi32_ss", (Func<object, int, object>)mm_cvtsi32_ss);
            RegisterFunction("mm_cvtss_si32", (Func<object, int>)mm_cvtss_si32);
            RegisterFunction("mm_cvttss_si32", (Func<object, int>)mm_cvttss_si32);
            RegisterFunction("mm_div_ps", (Func<object, object, object>)mm_div_ps);
            RegisterFunction("mm_div_ss", (Func<object, object, object>)mm_div_ss);
            RegisterFunction("mm_load_ps", (Func<object, object>)mm_load_ps);
            RegisterFunction("mm_load_ss", (Func<object, object>)mm_load_ss);
            RegisterFunction("mm_loadh_pi", (Func<object, object, object>)mm_loadh_pi);
            RegisterFunction("mm_loadl_pi", (Func<object, object, object>)mm_loadl_pi);
            RegisterFunction("mm_loadu_ps", (Func<object, object>)mm_loadu_ps);
            RegisterFunction("mm_max_ps", (Func<object, object, object>)mm_max_ps);
            RegisterFunction("mm_max_ss", (Func<object, object, object>)mm_max_ss);
            RegisterFunction("mm_min_ps", (Func<object, object, object>)mm_min_ps);
            RegisterFunction("mm_min_ss", (Func<object, object, object>)mm_min_ss);
            RegisterFunction("mm_move_ss", (Func<object, object, object>)mm_move_ss);
            RegisterFunction("mm_movehl_ps", (Func<object, object, object>)mm_movehl_ps);
            RegisterFunction("mm_movelh_ps", (Func<object, object, object>)mm_movelh_ps);
            RegisterFunction("mm_movemask_ps", (Func<object, int>)mm_movemask_ps);
            RegisterFunction("mm_mul_ps", (Func<object, object, object>)mm_mul_ps);
            RegisterFunction("mm_mul_ss", (Func<object, object, object>)mm_mul_ss);
            RegisterFunction("mm_or_ps", (Func<object, object, object>)mm_or_ps);
            RegisterAction("mm_prefetch0", (Action<object>)mm_prefetch0);
            RegisterAction("mm_prefetch1", (Action<object>)mm_prefetch1);
            RegisterAction("mm_prefetch2", (Action<object>)mm_prefetch2);
            RegisterAction("mm_prefetchnta", (Action<object>)mm_prefetchnta);
            RegisterFunction("mm_rcp_ps", (Func<object, object>)mm_rcp_ps);
            RegisterFunction("mm_rcp_ss", (Func<object, object, object>)mm_rcp_ss);
            RegisterFunction("mm_rcp_ss1", (Func<object, object>)mm_rcp_ss1);
            RegisterFunction("mm_rsqrt_ps", (Func<object, object>)mm_rsqrt_ps);
            RegisterFunction("mm_rsqrt_ss", (Func<object, object, object>)mm_rsqrt_ss);
            RegisterFunction("mm_rsqrt_ss1", (Func<object, object>)mm_rsqrt_ss1);
            RegisterFunction("mm_shuffle_ps", (Func<object, object, byte, object>)mm_shuffle_ps);
            RegisterFunction("mm_sqrt_ps", (Func<object, object>)mm_sqrt_ps);
            RegisterFunction("mm_sqrt_ss", (Func<object, object, object>)mm_sqrt_ss);
            RegisterFunction("mm_sqrt_ss1", (Func<object, object>)mm_sqrt_ss1);
            RegisterAction("mm_store_ps", (Action<object, object>)mm_store_ps);
            RegisterAction("mm_store_ss", (Action<object, object>)mm_store_ss);
            RegisterAction("mm_storeh_pi", (Action<object, object>)mm_storeh_pi);
            RegisterAction("mm_storel_pi", (Action<object, object>)mm_storel_pi);
            RegisterAction("mm_storeu_ps", (Action<object, object>)mm_storeu_ps);
            RegisterAction("mm_stream_ps", (Action<object, object>)mm_stream_ps);
            RegisterFunction("mm_sub_ps", (Func<object, object, object>)mm_sub_ps);
            RegisterFunction("mm_sub_ss", (Func<object, object, object>)mm_sub_ss);
            RegisterFunction("mm_ucomieq_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomieq_ss);
            RegisterFunction("mm_ucomige_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomige_ss);
            RegisterFunction("mm_ucomigt_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomigt_ss);
            RegisterFunction("mm_ucomile_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomile_ss);
            RegisterFunction("mm_ucomilt_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomilt_ss);
            RegisterFunction("mm_ucomineq_ss", (Func<object, object, Kalk.Core.KalkBool>)mm_ucomineq_ss);
            RegisterFunction("mm_unpackhi_ps", (Func<object, object, object>)mm_unpackhi_ps);
            RegisterFunction("mm_unpacklo_ps", (Func<object, object, object>)mm_unpacklo_ps);
            RegisterFunction("mm_xor_ps", (Func<object, object, object>)mm_xor_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_add_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Add packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128 _mm_add_ps (__m128 a,  __m128 b)
    ADDPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_add_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Add the lower single-precision (32-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_add_ss (__m128 a,  __m128 b)
    ADDSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_and_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128 _mm_and_ps (__m128 a, __m128 b)
    ANDPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_andnot_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in ""a"" and then AND with ""b"", and store the results in ""dst"".
    
    __m128 _mm_andnot_ps (__m128 a, __m128 b)
    ANDNPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpeq_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for equality, and store the results in ""dst"".
    
    __m128 _mm_cmpeq_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(0)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpeq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for equality, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpeq_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(0)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpge_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, and store the results in ""dst"".
    
    __m128 _mm_cmpge_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(5)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpge_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpge_ss (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m32, imm8(5)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpgt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than, and store the results in ""dst"".
    
    __m128 _mm_cmpgt_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(6)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpgt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpgt_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(6)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmple_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, and store the results in ""dst"".
    
    __m128 _mm_cmple_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(2)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmple_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmple_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(2)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmplt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than, and store the results in ""dst"".
    
    __m128 _mm_cmplt_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(1)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmplt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmplt_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(1)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpneq_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-equal, and store the results in ""dst"".
    
    __m128 _mm_cmpneq_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpneq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpneq_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(4)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnge_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, and store the results in ""dst"".
    
    __m128 _mm_cmpnge_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(1)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnge_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpnge_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(1)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpngt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, and store the results in ""dst"".
    
    __m128 _mm_cmpngt_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(2)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpngt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpngt_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(2)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnle_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, and store the results in ""dst"".
    
    __m128 _mm_cmpnle_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(6)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnle_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpnle_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(6)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than, and store the results in ""dst"".
    
    __m128 _mm_cmpnlt_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(5)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpnlt_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(5)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpord_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, and store the results in ""dst"".
    
    __m128 _mm_cmpord_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(7)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpord_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpord_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(7)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpunord_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, and store the results in ""dst"".
    
    __m128 _mm_cmpunord_ps (__m128 a,  __m128 b)
    CMPPS xmm, xmm/m128, imm8(3)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cmpunord_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cmpunord_ss (__m128 a,  __m128 b)
    CMPSS xmm, xmm/m32, imm8(3)";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comieq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for equality, and return the boolean result (0 or 1).
    
    int _mm_comieq_ss (__m128 a, __m128 b)
    COMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comige_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for greater-than-or-equal, and return the boolean result (0 or 1).
    
    int _mm_comige_ss (__m128 a, __m128 b)
    COMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comigt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for greater-than, and return the boolean result (0 or 1).
    
    int _mm_comigt_ss (__m128 a, __m128 b)
    COMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comile_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for less-than-or-equal, and return the boolean result (0 or 1).
    
    int _mm_comile_ss (__m128 a, __m128 b)
    COMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comilt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for less-than, and return the boolean result (0 or 1).
    
    int _mm_comilt_ss (__m128 a, __m128 b)
    COMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_comineq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for not-equal, and return the boolean result (0 or 1).
    
    int _mm_comineq_ss (__m128 a, __m128 b)
    COMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtsi32_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the 32-bit integer ""b"" to a single-precision (32-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cvtsi32_ss (__m128 a, int b)
    CVTSI2SS xmm, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtss_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""a"" to a 32-bit integer, and store the result in ""dst"".
    
    int _mm_cvtss_si32 (__m128 a)
    CVTSS2SI r32, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvttss_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""a"" to a 32-bit integer with truncation, and store the result in ""dst"".
    
    int _mm_cvttss_si32 (__m128 a)
    CVTTSS2SI r32, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_div_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Divide packed single-precision (32-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".
    
    __m128 _mm_div_ps (__m128 a,  __m128 b)
    DIVPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_div_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Divide the lower single-precision (32-bit) floating-point element in ""a"" by the lower single-precision (32-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_div_ss (__m128 a,  __m128 b)
    DIVSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_load_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Load 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from memory into ""dst"".
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    __m128 _mm_load_ps (float const* mem_address)
    MOVAPS xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_load_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Load a single-precision (32-bit) floating-point element from memory into the lower of ""dst"", and zero the upper 3 elements. ""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128 _mm_load_ss (float const* mem_address)
    MOVSS xmm, m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadh_pi"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Load 2 single-precision (32-bit) floating-point elements from memory into the upper 2 elements of ""dst"", and copy the lower 2 elements from ""a"" to ""dst"". ""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128 _mm_loadh_pi (__m128 a, __m64 const* mem_addr)
    MOVHPS xmm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadl_pi"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Load 2 single-precision (32-bit) floating-point elements from memory into the lower 2 elements of ""dst"", and copy the upper 2 elements from ""a"" to ""dst"". ""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128 _mm_loadl_pi (__m128 a, __m64 const* mem_addr)
    MOVLPS xmm, m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_loadu_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Load 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from memory into ""dst"".
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    __m128 _mm_loadu_ps (float const* mem_address)
    MOVUPS xmm, m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed maximum values in ""dst"".
    
    __m128 _mm_max_ps (__m128 a,  __m128 b)
    MAXPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_max_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"", store the maximum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128 _mm_max_ss (__m128 a,  __m128 b)
    MAXSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed minimum values in ""dst"".
    
    __m128 _mm_min_ps (__m128 a,  __m128 b)
    MINPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_min_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"", store the minimum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".
    
    __m128 _mm_min_ss (__m128 a,  __m128 b)
    MINSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_move_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Move the lower single-precision (32-bit) floating-point element from ""b"" to the lower element of ""dst"", and copy the upper 3 elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_move_ss (__m128 a, __m128 b)
    MOVSS xmm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_movehl_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Move the upper 2 single-precision (32-bit) floating-point elements from ""b"" to the lower 2 elements of ""dst"", and copy the upper 2 elements from ""a"" to the upper 2 elements of ""dst"".
    
    __m128 _mm_movehl_ps (__m128 a,  __m128 b)
    MOVHLPS xmm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_movelh_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Move the lower 2 single-precision (32-bit) floating-point elements from ""b"" to the upper 2 elements of ""dst"", and copy the lower 2 elements from ""a"" to the lower 2 elements of ""dst"".
    
    __m128 _mm_movelh_ps (__m128 a,  __m128 b)
    MOVLHPS xmm, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_movemask_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Set each bit of mask ""dst"" based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in ""a"".
    
    int _mm_movemask_ps (__m128 a)
    MOVMSKPS reg, xmm";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mul_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Multiply packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128 _mm_mul_ps (__m128 a, __m128 b)
    MULPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mul_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Multiply the lower single-precision (32-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_mul_ss (__m128 a, __m128 b)
    MULPS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_or_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128 _mm_or_ps (__m128 a,  __m128 b)
    ORPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_prefetch0"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Fetch the line of data from memory that contains address ""p"" to a location in the cache heirarchy specified by the locality hint ""i"".
    
    void _mm_prefetch(char* p, int i)
    PREFETCHT0 m8";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_prefetch1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Fetch the line of data from memory that contains address ""p"" to a location in the cache heirarchy specified by the locality hint ""i"".
    
    void _mm_prefetch(char* p, int i)
    PREFETCHT1 m8";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_prefetch2"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Fetch the line of data from memory that contains address ""p"" to a location in the cache heirarchy specified by the locality hint ""i"".
    
    void _mm_prefetch(char* p, int i)
    PREFETCHT2 m8";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_prefetchnta"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Fetch the line of data from memory that contains address ""p"" to a location in the cache heirarchy specified by the locality hint ""i"".
    
    void _mm_prefetch(char* p, int i)
    PREFETCHNTA m8";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_rcp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.
    
    __m128 _mm_rcp_ps (__m128 a)
    RCPPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_rcp_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.
    
    __m128 _mm_rcp_ss (__m128 a, __m128 b)
    RCPSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_rcp_ss1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.
    
    __m128 _mm_rcp_ss (__m128 a)
    RCPSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_rsqrt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.
    
    __m128 _mm_rsqrt_ps (__m128 a)
    RSQRTPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_rsqrt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.
    
    __m128 _mm_rsqrt_ss (__m128 a, __m128 b)
    RSQRTSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_rsqrt_ss1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.
    
    __m128 _mm_rsqrt_ss (__m128 a)
    RSQRTSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_shuffle_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" using the control in ""imm8"", and store the results in ""dst"".
    
    __m128 _mm_shuffle_ps (__m128 a,  __m128 b, unsigned int control)
    SHUFPS xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sqrt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".
    
    __m128 _mm_sqrt_ps (__m128 a)
    SQRTPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sqrt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the square root of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_sqrt_ss (__m128 a, __m128 b)
    SQRTSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sqrt_ss1"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the square root of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_sqrt_ss (__m128 a)
    SQRTSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_store_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from ""a"" into memory.
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    void _mm_store_ps (float* mem_addr, __m128 a)
    MOVAPS m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_store_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Store the lower single-precision (32-bit) floating-point element from ""a"" into memory. ""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm_store_ss (float* mem_addr, __m128 a)
    MOVSS m32, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storeh_pi"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Store the upper 2 single-precision (32-bit) floating-point elements from ""a"" into memory.
    
    void _mm_storeh_pi (__m64* mem_addr, __m128 a)
    MOVHPS m64, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storel_pi"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Store the lower 2 single-precision (32-bit) floating-point elements from ""a"" into memory.
    
    void _mm_storel_pi (__m64* mem_addr, __m128 a)
    MOVLPS m64, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_storeu_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from ""a"" into memory.
    	""mem_addr"" does not need to be aligned on any particular boundary.
    
    void _mm_storeu_ps (float* mem_addr, __m128 a)
    MOVUPS m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_stream_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Store 128-bits (composed of 4 packed single-precision (32-bit) floating-point elements) from ""a"" into memory using a non-temporal memory hint.
    	""mem_addr"" must be aligned on a 16-byte boundary or a general-protection exception may be generated.
    
    void _mm_stream_ps (float* mem_addr, __m128 a)
    MOVNTPS m128, xmm";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["mm_sub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Subtract packed single-precision (32-bit) floating-point elements in ""b"" from packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".
    
    __m128d _mm_sub_ps (__m128d a, __m128d b)
    SUBPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sub_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Subtract the lower single-precision (32-bit) floating-point element in ""b"" from the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_sub_ss (__m128 a, __m128 b)
    SUBSS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomieq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomieq_ss (__m128 a, __m128 b)
    UCOMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomige_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomige_ss (__m128 a, __m128 b)
    UCOMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomigt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomigt_ss (__m128 a, __m128 b)
    UCOMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomile_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomile_ss (__m128 a, __m128 b)
    UCOMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomilt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomilt_ss (__m128 a, __m128 b)
    UCOMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_ucomineq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
    
    int _mm_ucomineq_ss (__m128 a, __m128 b)
    UCOMISS xmm, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpackhi_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the high half ""a"" and ""b"", and store the results in ""dst"".
    
    __m128 _mm_unpackhi_ps (__m128 a,  __m128 b)
    UNPCKHPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_unpacklo_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the low half of ""a"" and ""b"", and store the results in ""dst"".
    
    __m128 _mm_unpacklo_ps (__m128 a,  __m128 b)
    UNPCKLPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_xor_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".
    
    __m128 _mm_xor_ps (__m128 a,  __m128 b)
    XORPS xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class SseX64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_cvtsi64_ss", (Func<object, long, object>)mm_cvtsi64_ss);
            RegisterFunction("mm_cvtss_si64", (Func<object, long>)mm_cvtss_si64);
            RegisterFunction("mm_cvttss_si64", (Func<object, long>)mm_cvttss_si64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_cvtsi64_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the 64-bit integer ""b"" to a single-precision (32-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".
    
    __m128 _mm_cvtsi64_ss (__m128 a, __int64 b)
    CVTSI2SS xmm, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvtss_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""a"" to a 64-bit integer, and store the result in ""dst"".
    
    __int64 _mm_cvtss_si64 (__m128 a)
    CVTSS2SI r64, xmm/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_cvttss_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""a"" to a 64-bit integer with truncation, and store the result in ""dst"".
    
    __int64 _mm_cvttss_si64 (__m128 a)
    CVTTSS2SI r64, xmm/m32";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Ssse3IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_abs_epi16", (Func<object, object>)mm_abs_epi16);
            RegisterFunction("mm_abs_epi32", (Func<object, object>)mm_abs_epi32);
            RegisterFunction("mm_abs_epi8", (Func<object, object>)mm_abs_epi8);
            RegisterFunction("mm_alignr_epi8", (Func<object, object, byte, object>)mm_alignr_epi8);
            RegisterFunction("mm_hadd_epi16", (Func<object, object, object>)mm_hadd_epi16);
            RegisterFunction("mm_hadd_epi32", (Func<object, object, object>)mm_hadd_epi32);
            RegisterFunction("mm_hadds_epi16", (Func<object, object, object>)mm_hadds_epi16);
            RegisterFunction("mm_hsub_epi16", (Func<object, object, object>)mm_hsub_epi16);
            RegisterFunction("mm_hsub_epi32", (Func<object, object, object>)mm_hsub_epi32);
            RegisterFunction("mm_hsubs_epi16", (Func<object, object, object>)mm_hsubs_epi16);
            RegisterFunction("mm_maddubs_epi16", (Func<object, object, object>)mm_maddubs_epi16);
            RegisterFunction("mm_mulhrs_epi16", (Func<object, object, object>)mm_mulhrs_epi16);
            RegisterFunction("mm_shuffle_epi8", (Func<object, object, object>)mm_shuffle_epi8);
            RegisterFunction("mm_sign_epi16", (Func<object, object, object>)mm_sign_epi16);
            RegisterFunction("mm_sign_epi32", (Func<object, object, object>)mm_sign_epi32);
            RegisterFunction("mm_sign_epi8", (Func<object, object, object>)mm_sign_epi8);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_abs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Compute the absolute value of packed 16-bit integers in ""a"", and store the unsigned results in ""dst"".
    
    __m128i _mm_abs_epi16 (__m128i a)
    PABSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_abs_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Compute the absolute value of packed 32-bit integers in ""a"", and store the unsigned results in ""dst"".
    
    __m128i _mm_abs_epi32 (__m128i a)
    PABSD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_abs_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Compute the absolute value of packed 8-bit integers in ""a"", and store the unsigned results in ""dst"".
    
    __m128i _mm_abs_epi8 (__m128i a)
    PABSB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_alignr_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Concatenate 16-byte blocks in ""a"" and ""b"" into a 32-byte temporary result, shift the result right by ""count"" bytes, and store the low 16 bytes in ""dst"".
    
    __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count)
    PALIGNR xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hadd_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".
    
    __m128i _mm_hadd_epi16 (__m128i a, __m128i b)
    PHADDW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hadd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of 32-bit integers in ""a"" and ""b"", and pack the signed 32-bit results in ""dst"".
    
    __m128i _mm_hadd_epi32 (__m128i a, __m128i b)
    PHADDD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hadds_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".
    
    __m128i _mm_hadds_epi16 (__m128i a, __m128i b)
    PHADDSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hsub_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".
    
    __m128i _mm_hsub_epi16 (__m128i a, __m128i b)
    PHSUBW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hsub_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 32-bit integers in ""a"" and ""b"", and pack the signed 32-bit results in ""dst"".
    
    __m128i _mm_hsub_epi32 (__m128i a, __m128i b)
    PHSUBD xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_hsubs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".
    
    __m128i _mm_hsubs_epi16 (__m128i a, __m128i b)
    PHSUBSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_maddubs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Vertically multiply each unsigned 8-bit integer from ""a"" with the corresponding signed 8-bit integer from ""b"", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in ""dst"".
    
    __m128i _mm_maddubs_epi16 (__m128i a, __m128i b)
    PMADDUBSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_mulhrs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Multiply packed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to ""dst"".
    
    __m128i _mm_mulhrs_epi16 (__m128i a, __m128i b)
    PMULHRSW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_shuffle_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Shuffle packed 8-bit integers in ""a"" according to shuffle control mask in the corresponding 8-bit element of ""b"", and store the results in ""dst"".
    
    __m128i _mm_shuffle_epi8 (__m128i a, __m128i b)
    PSHUFB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sign_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Negate packed 16-bit integers in ""a"" when the corresponding signed 16-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.
    
    __m128i _mm_sign_epi16 (__m128i a, __m128i b)
    PSIGNW xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sign_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Negate packed 32-bit integers in ""a"" when the corresponding signed 32-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.
    
    __m128i _mm_sign_epi32 (__m128i a, __m128i b)
    PSIGND xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_sign_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Negate packed 8-bit integers in ""a"" when the corresponding signed 8-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.
    
    __m128i _mm_sign_epi8 (__m128i a, __m128i b)
    PSIGNB xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class StringModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("escape", (Func<string, string>)StringEscape);
            RegisterFunction("capitalize", (Func<string, string>)StringCapitalize);
            RegisterFunction("capitalize_words", (Func<string, string>)StringCapitalizeWords);
            RegisterFunction("downcase", (Func<string, string>)StringDowncase);
            RegisterFunction("upcase", (Func<string, string>)StringUpcase);
            RegisterFunction("endswith", (Func<string, string, Kalk.Core.KalkBool>)StringEndsWith);
            RegisterFunction("handleize", (Func<string, string>)StringHandleize);
            RegisterFunction("lstrip", (Func<string, string>)StringLeftStrip);
            RegisterFunction("pluralize", (Func<int, string, string, string>)StringPluralize);
            RegisterFunction("rstrip", (Func<string, string>)StringRightStrip);
            RegisterFunction("split", (Func<string, string, System.Collections.IEnumerable>)StringSplit);
            RegisterFunction("startswith", (Func<string, string, Kalk.Core.KalkBool>)StringStartsWith);
            RegisterFunction("strip", (Func<string, string>)StringStrip);
            RegisterFunction("strip_newlines", (Func<string, string>)StringStripNewlines);
            RegisterFunction("pad_left", (Func<string, int, string>)StringPadLeft);
            RegisterFunction("pad_right", (Func<string, int, string>)StringPadRight);
            RegisterFunction("regex_escape", (Func<string, string>)RegexEscape);
            RegisterFunction("regex_match", (Func<string, string, string, Scriban.Runtime.ScriptArray>)RegexMatch);
            RegisterFunction("regex_matches", (Func<string, string, string, Scriban.Runtime.ScriptArray>)RegexMatches);
            RegisterFunction("regex_replace", (Func<string, string, string, string, string>)RegexReplace);
            RegisterFunction("regex_split", (Func<string, string, string, Scriban.Runtime.ScriptArray>)RegexSplit);
            RegisterFunction("regex_unescape", (Func<string, string>)RegexUnescape);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["escape"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["capitalize"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["capitalize_words"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["downcase"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["upcase"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["endswith"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["handleize"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["lstrip"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pluralize"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["rstrip"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["split"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["startswith"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["strip"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["strip_newlines"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pad_left"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pad_right"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_escape"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_match"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_matches"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_replace"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_split"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_unescape"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class VectorModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("length", (Func<object, object>)Length);
            RegisterFunction("normalize", (Func<object, object>)Normalize);
            RegisterFunction("dot", (Func<object, object, object>)Dot);
            RegisterFunction("cross", (Func<Kalk.Core.KalkVector, Kalk.Core.KalkVector, object>)Cross);
            RegisterFunction("byte", (Func<object, byte>)CreateByte);
            RegisterFunction("sbyte", (Func<object, sbyte>)CreateSByte);
            RegisterFunction("short", (Func<object, short>)CreateShort);
            RegisterFunction("ushort", (Func<object, ushort>)CreateUShort);
            RegisterFunction("uint", (Func<object, uint>)CreateUInt);
            RegisterFunction("int", (Func<object, int>)CreateInt);
            RegisterFunction("ulong", (Func<object, ulong>)CreateULong);
            RegisterFunction("long", (Func<object, long>)CreateLong);
            RegisterFunction("bool", (Func<object, Kalk.Core.KalkBool>)CreateBool);
            RegisterFunction("float", (Func<object, float>)CreateFloat);
            RegisterFunction("double", (Func<object, double>)CreateDouble);
            RegisterFunction("byte16", (Func<object[], Kalk.Core.KalkVector<byte>>)CreateByte16);
            RegisterFunction("byte32", (Func<object[], Kalk.Core.KalkVector<byte>>)CreateByte32);
            RegisterFunction("byte64", (Func<object[], Kalk.Core.KalkVector<byte>>)CreateByte64);
            RegisterFunction("sbyte16", (Func<object[], Kalk.Core.KalkVector<sbyte>>)CreateSByte16);
            RegisterFunction("sbyte32", (Func<object[], Kalk.Core.KalkVector<sbyte>>)CreateSByte32);
            RegisterFunction("sbyte64", (Func<object[], Kalk.Core.KalkVector<sbyte>>)CreateSByte64);
            RegisterFunction("short2", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort2);
            RegisterFunction("short4", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort4);
            RegisterFunction("short8", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort8);
            RegisterFunction("short16", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort16);
            RegisterFunction("short32", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort32);
            RegisterFunction("ushort2", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort2);
            RegisterFunction("ushort4", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort4);
            RegisterFunction("ushort8", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort8);
            RegisterFunction("ushort16", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort16);
            RegisterFunction("ushort32", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort32);
            RegisterFunction("int2", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt2);
            RegisterFunction("int3", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt3);
            RegisterFunction("int4", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt4);
            RegisterFunction("int8", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt8);
            RegisterFunction("int16", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt16);
            RegisterFunction("uint2", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt2);
            RegisterFunction("uint3", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt3);
            RegisterFunction("uint4", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt4);
            RegisterFunction("uint8", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt8);
            RegisterFunction("uint16", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt16);
            RegisterFunction("long2", (Func<object[], Kalk.Core.KalkVector<long>>)CreateLong2);
            RegisterFunction("long3", (Func<object[], Kalk.Core.KalkVector<long>>)CreateLong3);
            RegisterFunction("long4", (Func<object[], Kalk.Core.KalkVector<long>>)CreateLong4);
            RegisterFunction("long8", (Func<object[], Kalk.Core.KalkVector<long>>)CreateLong8);
            RegisterFunction("ulong2", (Func<object[], Kalk.Core.KalkVector<ulong>>)CreateULong2);
            RegisterFunction("ulong3", (Func<object[], Kalk.Core.KalkVector<ulong>>)CreateULong3);
            RegisterFunction("ulong4", (Func<object[], Kalk.Core.KalkVector<ulong>>)CreateULong4);
            RegisterFunction("ulong8", (Func<object[], Kalk.Core.KalkVector<ulong>>)CreateULong8);
            RegisterFunction("bool2", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool2);
            RegisterFunction("bool3", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool3);
            RegisterFunction("bool4", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool4);
            RegisterFunction("bool8", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool8);
            RegisterFunction("bool16", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool16);
            RegisterFunction("float2", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat2);
            RegisterFunction("float3", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat3);
            RegisterFunction("float4", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat4);
            RegisterFunction("float8", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat8);
            RegisterFunction("float16", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat16);
            RegisterFunction("double2", (Func<object[], Kalk.Core.KalkVector<double>>)CreateDouble2);
            RegisterFunction("double3", (Func<object[], Kalk.Core.KalkVector<double>>)CreateDouble3);
            RegisterFunction("double4", (Func<object[], Kalk.Core.KalkVector<double>>)CreateDouble4);
            RegisterFunction("double8", (Func<object[], Kalk.Core.KalkVector<double>>)CreateDouble8);
            RegisterFunction("vector", (Func<Scriban.Syntax.ScriptVariable, int, object[], object>)CreateVector);
            RegisterFunction("rgb", (Func<object[], Kalk.Core.KalkColorRgb>)CreateRgb);
            RegisterFunction("rgba", (Func<object[], Kalk.Core.KalkColorRgba>)CreateRgba);
            RegisterFunction("bool2x2", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool2x2);
            RegisterFunction("bool2x3", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool2x3);
            RegisterFunction("bool2x4", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool2x4);
            RegisterFunction("bool3x2", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool3x2);
            RegisterFunction("bool3x3", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool3x3);
            RegisterFunction("bool3x4", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool3x4);
            RegisterFunction("bool4x2", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool4x2);
            RegisterFunction("bool4x3", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool4x3);
            RegisterFunction("bool4x4", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool4x4);
            RegisterFunction("int2x2", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt2x2);
            RegisterFunction("int2x3", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt2x3);
            RegisterFunction("int2x4", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt2x4);
            RegisterFunction("int3x2", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt3x2);
            RegisterFunction("int3x3", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt3x3);
            RegisterFunction("int3x4", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt3x4);
            RegisterFunction("int4x2", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt4x2);
            RegisterFunction("int4x3", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt4x3);
            RegisterFunction("int4x4", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt4x4);
            RegisterFunction("float2x2", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat2x2);
            RegisterFunction("float2x3", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat2x3);
            RegisterFunction("float2x4", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat2x4);
            RegisterFunction("float3x2", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat3x2);
            RegisterFunction("float3x3", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat3x3);
            RegisterFunction("float3x4", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat3x4);
            RegisterFunction("float4x2", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat4x2);
            RegisterFunction("float4x3", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat4x3);
            RegisterFunction("float4x4", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat4x4);
            RegisterFunction("double2x2", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble2x2);
            RegisterFunction("double2x3", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble2x3);
            RegisterFunction("double2x4", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble2x4);
            RegisterFunction("double3x2", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble3x2);
            RegisterFunction("double3x3", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble3x3);
            RegisterFunction("double3x4", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble3x4);
            RegisterFunction("double4x2", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble4x2);
            RegisterFunction("double4x3", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble4x3);
            RegisterFunction("double4x4", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble4x4);
            RegisterFunction("transpose", (Func<Kalk.Core.KalkMatrix, Kalk.Core.KalkMatrix>)Transpose);
            RegisterFunction("identity", (Func<Kalk.Core.KalkMatrix, Kalk.Core.KalkMatrix>)Identity);
            RegisterFunction("determinant", (Func<Kalk.Core.KalkMatrix, object>)Determinant);
            RegisterFunction("inverse", (Func<Kalk.Core.KalkMatrix, Kalk.Core.KalkMatrix>)Inverse);
            RegisterFunction("diag", (Func<object, object>)Diagonal);
            RegisterFunction("matrix", (Func<Scriban.Syntax.ScriptVariable, int, int, object[], object>)CreateMatrix);
            RegisterFunction("row", (Func<Kalk.Core.KalkMatrix, int, Kalk.Core.KalkVector>)GetRow);
            RegisterFunction("col", (Func<Kalk.Core.KalkMatrix, int, Kalk.Core.KalkVector>)GetColumn);
            RegisterFunction("mul", (Func<object, object, object>)Multiply);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["length"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"Returns the length of the specified floating-point vector.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified floating-point vector.")  { IsOptional = false });
                descriptor.Returns = @"A floating-point scalar that represents the length of the x parameter.";
                descriptor.Example = @"    >>> length float2(1, 2)
    # length(float2(1, 2))
    out = 2.23606797749979
    >>> length -5
    # length(-5)
    out = 5
";
            }
            {
                var descriptor = Descriptors["normalize"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"Normalizes the specified floating-point vector according to x / length(x).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"he specified floating-point vector.")  { IsOptional = false });
                descriptor.Returns = @"The normalized x parameter. If the length of the x parameter is 0, the result is indefinite.";
                descriptor.Example = @"    >>> normalize float2(1,2)
    # normalize(float2(1, 2))
    out = float2(0.4472136, 0.8944272)
";
            }
            {
                var descriptor = Descriptors["dot"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"Returns the dot product of two vectors.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The first vector.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The second vector.")  { IsOptional = false });
                descriptor.Returns = @"The dot product of the x parameter and the y parameter.";
                descriptor.Example = @"    >>> dot(float3(1,2,3), float3(4,5,6))
    # dot(float3(1, 2, 3), float3(4, 5, 6))
    out = 32
    >>> dot(float3(1,2,3), 4)
    # dot(float3(1, 2, 3), 4)
    out = 24
    >>> dot(4, float3(1,2,3))
    # dot(4, float3(1, 2, 3))
    out = 24
    >>> dot(5,6)
    # dot(5, 6)
    out = 30
";
            }
            {
                var descriptor = Descriptors["cross"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"Returns the cross product of two floating-point, 3D vectors.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The first floating-point, 3D vector.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The second floating-point, 3D vector.")  { IsOptional = false });
                descriptor.Returns = @"The cross product of the x parameter and the y parameter.";
                descriptor.Example = @"    >>> cross(float3(1,2,3), float3(4,5,6))
    # cross(float3(1, 2, 3), float3(4, 5, 6))
    out = float3(-3, 6, -3)
    >>> cross(float3(1,0,0), float3(0,1,0))
    # cross(float3(1, 0, 0), float3(0, 1, 0))
    out = float3(0, 0, 1)
    >>> cross(float3(0,0,1), float3(0,1,0))
    # cross(float3(0, 0, 1), float3(0, 1, 0))
    out = float3(-1, 0, 0)
";
            }
            {
                var descriptor = Descriptors["byte"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates an unsigned byte value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"An unsigned byte value";
                descriptor.Example = @"    >>> byte
    # byte
    out = 0
    >>> byte 0
    # byte(0)
    out = 0
    >>> byte 255
    # byte(255)
    out = 255
";
            }
            {
                var descriptor = Descriptors["sbyte"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a signed-byte value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A signed-byte value";
                descriptor.Example = @"    >>> sbyte
    # sbyte
    out = 0
    >>> sbyte 0
    # sbyte(0)
    out = 0
    >>> sbyte 127
    # sbyte(127)
    out = 127
    >>> sbyte -128
    # sbyte(-128)
    out = -128
";
            }
            {
                var descriptor = Descriptors["short"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a signed-short (16-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A signed-short (16-bit) value";
                descriptor.Example = @"    >>> short
    # short
    out = 0
    >>> short 0
    # short(0)
    out = 0
    >>> short 32767
    # short(32767)
    out = 32767
    >>> short -32768
    # short(-32768)
    out = -32768
    >>> short 32768
    Unable to convert type `int` to `short`
";
            }
            {
                var descriptor = Descriptors["ushort"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates an unsigned short (16-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"An unsigned short (16-bit) value";
                descriptor.Example = @"    >>> ushort
    # ushort
    out = 0
    >>> ushort 0
    # ushort(0)
    out = 0
    >>> ushort 65535
    # ushort(65535)
    out = 65535
";
            }
            {
                var descriptor = Descriptors["uint"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates an unsigned int (32-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"An unsigned int (32-bit) value";
                descriptor.Example = @"    >>> uint
    # uint
    out = 0
    >>> uint 0
    # uint(0)
    out = 0
    >>> uint(1<<32 - 1)
    # uint(1 << 32 - 1)
    out = 4294967295
";
            }
            {
                var descriptor = Descriptors["int"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a signed-int (32-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A signed-int (32-bit) value";
                descriptor.Example = @"    >>> int
    # int
    out = 0
    >>> int 0
    # int(0)
    out = 0
    >>> int(1 << 31 - 1)
    # int(1 << 31 - 1)
    out = 2147483647
    >>> int(-(1<<31))
    # int(-(1 << 31))
    out = -2147483648
";
            }
            {
                var descriptor = Descriptors["ulong"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates an unsigned long (64-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"An unsigned long (64-bit) value";
                descriptor.Example = @"    >>> ulong
    # ulong
    out = 0
    >>> ulong 0
    # ulong(0)
    out = 0
    >>> ulong(1 << 64 - 1)
    # ulong(1 << 64 - 1)
    out = 18446744073709551615
";
            }
            {
                var descriptor = Descriptors["long"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a signed-long (64-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A signed-long (64-bit) value";
                descriptor.Example = @"    >>> long
    # long
    out = 0
    >>> long 0
    # long(0)
    out = 0
    >>> long(1 << 63 - 1)
    # long(1 << 63 - 1)
    out = 9223372036854775807
    >>> long(-(1<<63))
    # long(-(1 << 63))
    out = -9223372036854775808
";
            }
            {
                var descriptor = Descriptors["bool"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a boolean value (32-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A boolean (32-bit) value";
                descriptor.Example = @"    >>> bool 1
    # bool(1)
    out = true
    >>> bool 0
    # bool(0)
    out = false
    >>> bool true
    # bool(true)
    out = true
    >>> bool false
    # bool(false)
    out = false
";
            }
            {
                var descriptor = Descriptors["float"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a float value (32-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A float (32-bit) value";
                descriptor.Example = @"    >>> float(1)
    # float(1)
    out = 1
    >>> float(-1)
    # float(-1)
    out = -1
    >>> float(100000000000)
    # float(100000000000)
    out = 1E+11
";
            }
            {
                var descriptor = Descriptors["double"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a double value (64-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A double (64-bit) value";
                descriptor.Example = @"    >>> double(1)
    # double(1)
    out = 1
    >>> double(-1)
    # double(-1)
    out = -1
    >>> double(100000000000)
    # double(100000000000)
    out = 100000000000
    >>> double(1<<200)
    # double(1 << 200)
    out = 1.6069380442589903E+60
";
            }
            {
                var descriptor = Descriptors["byte16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["byte32"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["byte64"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["sbyte16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["sbyte32"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["sbyte64"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short32"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort32"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["vector"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["rgb"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["rgba"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool2x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 2 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool2x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 3 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool2x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 4 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool3x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 2 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool3x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 3 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool3x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 4 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool4x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 2 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool4x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 3 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool4x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 4 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int2x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 2 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int2x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 3 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int2x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 4 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int3x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 2 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int3x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 3 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int3x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 4 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int4x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 2 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int4x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 3 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int4x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 4 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float2x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 2 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float2x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 3 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float2x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 4 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float3x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 2 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float3x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 3 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float3x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 4 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float4x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 2 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float4x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 3 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float4x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 4 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double2x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 2 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double2x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 3 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double2x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 4 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double3x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 2 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double3x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 3 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double3x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 4 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double4x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 2 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double4x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 3 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double4x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 4 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["transpose"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["identity"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["determinant"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["inverse"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["diag"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["matrix"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["row"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["col"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mul"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class WebModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("url_encode", (Func<string, string>)UrlEncode);
            RegisterFunction("url_decode", (Func<string, string>)UrlDecode);
            RegisterFunction("url_escape", (Func<string, string>)UrlEscape);
            RegisterFunction("html_encode", (Func<string, string>)HtmlEncode);
            RegisterFunction("html_decode", (Func<string, string>)HtmlDecode);
            RegisterFunction("json", (Func<object, object>)Json);
            RegisterFunction("html_strip", (Func<string, string>)HtmlStrip);
            RegisterFunction("wget", (Func<string, Scriban.Runtime.ScriptObject>)WebGet);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["url_encode"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["url_decode"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["url_escape"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["html_encode"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["html_decode"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["json"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["html_strip"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["wget"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
