//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Date: 13 Jun 2020
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;


namespace Kalk.Core.Modules
{
    public partial class CsvModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("parse_csv", (Func<string, bool, Scriban.Runtime.ScriptRange>)ParseCsv);
            RegisterFunction("load_csv", (Func<string, bool, Scriban.Runtime.ScriptRange>)LoadCsv);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["parse_csv"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["load_csv"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class CurrencyModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterConstant("currencies", Currencies);
            RegisterFunction("currency", (Func<Scriban.Syntax.ScriptVariable, decimal?, Kalk.Core.KalkCurrency>)Currency);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["currencies"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["currency"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class FileModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("file_exists", (Func<string, Kalk.Core.KalkBool>)FileExists);
            RegisterFunction("directory_exists", (Func<string, Kalk.Core.KalkBool>)DirectoryExists);
            RegisterFunction("dir", (Func<string, bool, System.Collections.IEnumerable>)DirectoryListing);
            RegisterFunction("load_text", (Func<string, string, string>)LoadText);
            RegisterFunction("load_bytes", (Func<string, Kalk.Core.KalkNativeBuffer>)LoadBytes);
            RegisterFunction("load_lines", (Func<string, string, Scriban.Runtime.ScriptRange>)LoadLines);
            RegisterFunction("save_lines", (Func<System.Collections.IEnumerable, string, string, object>)SaveLines);
            RegisterFunction("save_text", (Func<string, string, string, object>)SaveText);
            RegisterFunction("save_bytes", (Func<System.Collections.IEnumerable, string, object>)SaveBytes);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["file_exists"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["directory_exists"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["dir"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["load_text"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["load_bytes"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["load_lines"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["save_lines"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["save_text"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["save_bytes"];
                descriptor.Category = "Misc File Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core
{
    public partial class KalkEngine
    {
        protected void RegisterFunctionsAuto()
        {
            RegisterConstant("config", Config);
            RegisterConstant("aliases", Aliases);
            RegisterConstant("units", Units);
            RegisterConstant("shortcuts", Shortcuts);
            RegisterFunction("clipboard", (Func<object, object>)Clipboard);
            RegisterAction("display", (Action<Scriban.Syntax.ScriptVariable>)Display);
            RegisterAction("echo", (Action<Scriban.Syntax.ScriptVariable>)Echo);
            RegisterAction("print", (Action<object>)Print);
            RegisterAction("printh", (Action<object>)Printh);
            RegisterAction("help", (Action<Scriban.Syntax.ScriptExpression>)Help);
            RegisterAction("reset", (Action)Reset);
            RegisterAction("version", (Action)ShowVersion);
            RegisterAction("list", (Action)List);
            RegisterAction("del", (Action<Scriban.Syntax.ScriptVariable>)DeleteVariable);
            RegisterAction("exit", (Action)Exit);
            RegisterAction("history", (Action<object>)History);
            RegisterFunction("eval", (Func<string, bool, object>)EvaluateText);
            RegisterFunction("load", (Func<string, bool, object>)LoadFile);
            RegisterAction("clear", (Action<Scriban.Syntax.ScriptExpression>)Clear);
            RegisterAction("cls", (Action)Cls);
            RegisterFunction("out", (Func<object>)Last);
            RegisterAction("out2clipboard", (Action)LastToClipboard);
            RegisterAction("shortcut", (Action<Scriban.Syntax.ScriptVariable, Scriban.Syntax.ScriptExpression[]>)Shortcut);
            RegisterAction("alias", (Action<Scriban.Syntax.ScriptVariable, Scriban.Syntax.ScriptVariable[]>)Alias);
            RegisterFunction("to", (Func<Kalk.Core.KalkExpression, Kalk.Core.KalkExpression, Kalk.Core.KalkExpression>)ConvertTo);
            RegisterFunction("unit", (Func<Scriban.Syntax.ScriptVariable, string, Scriban.Syntax.ScriptVariable, Kalk.Core.KalkExpression, string, string, Kalk.Core.KalkExpression>)DefineUserUnit);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["config"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets the config object.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["aliases"];
                descriptor.Category = "General";
                descriptor.Description = @"Displays all built-in and user-defined aliases.";
                descriptor.IsCommand = false;
                descriptor.Remarks = @"Aliases are usually used to define equivalent variable names for equivalent mathematical symbols. To create an alias, see the command `alias`.";
            }
            {
                var descriptor = Descriptors["units"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"If used in an expression, returns an object containing all units defined.
    Otherwise it will display units in a friendly format.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["shortcuts"];
                descriptor.Category = "General";
                descriptor.Description = @"Displays all built-in and user-defined keyboard shortcuts.";
                descriptor.IsCommand = false;
                descriptor.Remarks = @"To create an keyboard shortcut, see the command `shortcut`.";
            }
            {
                var descriptor = Descriptors["clipboard"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets or sets the current content of the clipboard.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"Value to set the clipboard to. If not set, this function returns the current content of the clipboard.")  { IsOptional = true });
                descriptor.Returns = @"Returns the content of the clipboard.";
                descriptor.Remarks = @"On Unix platform, if you are running from WSL or from raw console, the clipboard is not supported.";
                descriptor.Example = @"    >>> clipboard ""text""
    # clipboard(""text"")
    out = ""text""
    >>> clipboard
    # clipboard
    out = ""text""
";
            }
            {
                var descriptor = Descriptors["display"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets or sets the display mode.
    
     - `std` for standard mode
     - `dev` for developer mode to display advanced details about integers, vectors and floating point values.
     - `eng` for engineering mode to display floating point values using 3 digits for the exponent.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("name", @"An optional parameter to set the display mode. Default is `std`. If this parameter is not set, this function will display the display mode currently used.")  { IsOptional = true });
                descriptor.Example = @"     >>> display
     # Display mode: std (Standard)
     >>> display dev
     # Display mode: dev (Developer)
     >>> 1.5
     # 1.5
     out = 1.5
         # IEEE 754 - double - 64-bit
         #
         = 0x_3FF80000_00000000
         = 0x____3____F____F____8____0____0____0____0____0____0____0____0____0____0____0____0
         #    seee eeee eeee ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff ffff
         = 0b_0011_1111_1111_1000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000
         #   63                48                  32                  16                   0
         #
         # sign    exponent              |-------------------- fraction --------------------|
         =   1 * 2 ^ (1023 - 1023) * 0b1.1000000000000000000000000000000000000000000000000000
     >>> display invalid
     Invalid display name `invalid`. Expecting `std`, `dev` or `eng`. (Parameter 'name')
";
            }
            {
                var descriptor = Descriptors["echo"];
                descriptor.Category = "General";
                descriptor.Description = @"Gets or sets the current echo mode.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"An optional `true`/`on` or `false`/`off` value to enable or disable the echo. A value of `false` will disable any output generated by a command except for the print commands. If this parameter is not set, this function will display the current display mode.")  { IsOptional = true });
                descriptor.Example = @"    >>> echo
    # Echo is on.
    >>> 1 + 2
    # 1 + 2
    out = 3
    >>> echo off
    >>> 1 + 2
    >>> echo
    >>> echo on
    # Echo is on.
    >>> 1 + 2
    # 1 + 2
    out = 3
";
            }
            {
                var descriptor = Descriptors["print"];
                descriptor.Category = "General";
                descriptor.Description = @"Prints the specified value to the output.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"A value to print to the output.")  { IsOptional = false });
                descriptor.Remarks = @"When the `echo` is off, this method will still output.";
                descriptor.Example = @"    >>> print ""kalk""
    kalk
    >>> echo off
    >>> print ""kalk2""
    kalk2
";
            }
            {
                var descriptor = Descriptors["printh"];
                descriptor.Category = "General";
                descriptor.Description = @"Prints the specified value to the output formatted with kalk syntax highlighting.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"A value to print to the output.")  { IsOptional = false });
                descriptor.Remarks = @"When the `echo` is off, this method will still output.";
                descriptor.Example = @"    >>> printh ""# This is a kalk comment""
    # This is a kalk comment
";
            }
            {
                var descriptor = Descriptors["help"];
                descriptor.Category = "General";
                descriptor.Description = @"Displays the documentation of the specified topic or function name.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("expression", @"An optional topic or function name. If this parameter is not set, it will display all available topics and functions.")  { IsOptional = true });
                descriptor.Example = @"    >>> help
    ... # Displays a list of function and topic names to get help from.
    >>> help alias
    ... # Displays the help for the `alias` function.
";
            }
            {
                var descriptor = Descriptors["reset"];
                descriptor.Category = "General";
                descriptor.Description = @"Removes all user-defined variables and functions.";
                descriptor.IsCommand = true;
                descriptor.Example = @"    >>> x = 5; y = 2
    # x = 5; y = 2
    x = 5
    y = 2
    >>> list
    # Variables
    x = 5
    y = 2
    >>> reset
    >>> list
    # No variables
";
            }
            {
                var descriptor = Descriptors["version"];
                descriptor.Category = "General";
                descriptor.Description = @"Prints the version of kalk.";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["list"];
                descriptor.Category = "General";
                descriptor.Description = @"Lists all user-defined variables and functions.";
                descriptor.IsCommand = true;
                descriptor.Example = @"    >>> x = 5; y = 2; f(x) = x + 5
    # x = 5; y = 2; f(x) = x + 5
    x = 5
    y = 2
     f(x) = x + 5
    >>> list
    # Variables
    x = 5
    y = 2
    # Functions
     f(x) = x + 5
";
            }
            {
                var descriptor = Descriptors["del"];
                descriptor.Category = "General";
                descriptor.Description = @"Deletes a user defined variable or function.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("variable", @"Name of the variable or function to delete.")  { IsOptional = false });
                descriptor.Example = @"    >>> x = 5; y = 2
    # x = 5; y = 2
    x = 5
    y = 2
    >>> del x
    # Variable `x == 5` deleted.
    >>> list
    # Variables
    y = 2
    >>> del y
    # Variable `y == 2` deleted.
    >>> f(x) = x + 5
    # f(x) = x + 5
    f(x) = x + 5
    >>> list
    # Functions
    f(x) = x + 5
    >>> del f
    # Function `f(x) = x + 5` deleted.
    >>> list
    # No variables
";
            }
            {
                var descriptor = Descriptors["exit"];
                descriptor.Category = "General";
                descriptor.Description = @"Exits kalk.";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["history"];
                descriptor.Category = "General";
                descriptor.Description = @"Displays the command history.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("line", @"An optional parameter that indicates:
    
     - if it is >= 0, the index of the history command to re-run. (e.g `history 1` to re-run the command 1 in the history)
     - if it is < 0, how many recent lines to display. (e.g `history -3` would display the last 3 lines in the history)")  { IsOptional = true });
                descriptor.Example = @"     >>> 1 + 5
     # 1 + 5
     out = 6
     >>> abs(out)
     # abs(out)
     out = 6
     >>> history
     0: 1 + 5
     1: abs(out)
";
            }
            {
                var descriptor = Descriptors["eval"];
                descriptor.Category = "General";
                descriptor.Description = @"Evaluates dynamically the input string as an expression.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("text", @"The text of the expression to evaluate.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("output", @"An optional parameter to output intermediate results of nested expressions. Default is `false`.")  { IsOptional = true });
                descriptor.Returns = @"The result of the evaluation.";
                descriptor.Example = @"    >>> eval ""1+5""
    # eval(""1+5"")
    out = 6
    >>> eval ""eval '1+5'""
    # eval(""eval '1+5'"")
    out = 6
";
            }
            {
                var descriptor = Descriptors["load"];
                descriptor.Category = "General";
                descriptor.Description = @"Loads and evaluates the specified script from a file location on a disk.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("path", @"The file location of the script to load and evaluate.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("output", @"An optional parameter to output intermediate results of nested expressions. Default is `false`.")  { IsOptional = true });
                descriptor.Returns = @"The result of the evaluation.";
            }
            {
                var descriptor = Descriptors["clear"];
                descriptor.Category = "General";
                descriptor.Description = @"Clears the screen (by default) or the history (e.g clear history).";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("what", @"An optional argument specifying what to clear. Can be of the following value:
    * screen: to clear the screen (default if not passed)
    * history: to clear the history")  { IsOptional = true });
            }
            {
                var descriptor = Descriptors["cls"];
                descriptor.Category = "General";
                descriptor.Description = @"Clears the screen.";
                descriptor.IsCommand = true;
            }
            {
                var descriptor = Descriptors["out"];
                descriptor.Category = "General";
                descriptor.Description = @"Returns the last evaluated result.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"The last evaluated result as an object.";
                descriptor.Example = @"    >>> 1 + 2
    # 1 + 2
    out = 3
    >>> out + 1
    # out + 1
    out = 4
";
            }
            {
                var descriptor = Descriptors["out2clipboard"];
                descriptor.Category = "General";
                descriptor.Description = @"Copies the last evaluated content to the clipboard.
    
     This is equivalent to `out |> clipboard`.";
                descriptor.IsCommand = true;
                descriptor.Example = @"     >>> 1 + 2
     # 1 + 2
     out = 3
     >>> out2clipboard
     >>> clipboard
     # clipboard
     out = ""3""
";
            }
            {
                var descriptor = Descriptors["shortcut"];
                descriptor.Category = "General";
                descriptor.Description = @"Creates a keyboard shortcut associated with an expression.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("name", @"Name of the shortcut")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("shortcuts", @"A collection of pair of shortcut description (e.g `CTRL+A`) and associated shortcut expression (e.g `1 + 2`).")  { IsOptional = false });
                descriptor.Remarks = @"See the command `shortcuts` to list the shortcuts currently defined. By default several shortcuts for common mathematical symbols are defined (e.g for the symbol pi: `shortcut(pi, ""CTRL+G P"", ""Π"", ""CTRL+G p"", ""π"")`).";
                descriptor.Example = @"    >>> # Creates a shortcut that will print 3 when pressing CTRL+R.
    >>> shortcut(myshortcut, ""CTRL+R"", 1 + 2)
    >>> # Overrides the previous shortcut that will print the text
    >>> # `kalk` when pressing CTRL+R.
    >>> shortcut(myshortcut, ""CTRL+R"", ""kalk"")
    >>> # Overrides the previous shortcut that will print the text
    >>> # `kalk` when pressing CTRL+R or the text `kalk2` when pressing
    >>> # CTRL+E and r key.
    >>> shortcut(myshortcut, ""CTRL+R"", ""kalk"", ""CTRL+E r"", ""kalk2"")
";
            }
            {
                var descriptor = Descriptors["alias"];
                descriptor.Category = "General";
                descriptor.Description = @"Creates an alias between variable names.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("name", @"Name of the original alias name.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("aliases", @"Variable names that are all equivalent to the alias name.")  { IsOptional = false });
                descriptor.Remarks = @"See the command `aliases` to list the aliases currently defined. Several aliases are defined by default for common mathematical symbols (e.g `alias(pi, Π, π)`).";
                descriptor.Example = @"    >>> alias(var1, var2, var3)
    >>> var1 = 2
    # var1 = 2
    var1 = 2
    >>> var2
    # var2
    out = 2
    >>> var3
    # var3
    out = 2
    >>> list
    # Variables
    var1 = 2
    >>> var2 = 1
    # var2 = 1
    var2 = 1
    >>> list
    # Variables
    var1 = 1
";
            }
            {
                var descriptor = Descriptors["to"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["unit"];
                descriptor.Category = "Unit Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core
{
    public partial class MathModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterConstant("nan", Nan);
            RegisterConstant("inf", Inf);
            RegisterConstant("pi", Pi);
            RegisterConstant("e", E);
            RegisterFunction("fib", (Func<Kalk.Core.KalkIntValue, object>)Fib);
            RegisterFunction("i", (Func<object>)ComplexNumber);
            RegisterFunction("all", (Func<object, Kalk.Core.KalkBool>)All);
            RegisterFunction("any", (Func<object, Kalk.Core.KalkBool>)Any);
            RegisterFunction("abs", (Func<Kalk.Core.KalkCompositeValue, object>)Abs);
            RegisterFunction("rnd", (Func<Kalk.Core.KalkCompositeValue, object>)Rnd);
            RegisterAction("seed", (Action<int?>)Seed);
            RegisterFunction("modf", (Func<Kalk.Core.KalkCompositeValue, Scriban.Runtime.ScriptArray>)Modf);
            RegisterFunction("radians", (Func<Kalk.Core.KalkCompositeValue, object>)Radians);
            RegisterFunction("degrees", (Func<Kalk.Core.KalkCompositeValue, object>)Degrees);
            RegisterFunction("sign", (Func<Kalk.Core.KalkCompositeValue, object>)Sign);
            RegisterFunction("cos", (Func<Kalk.Core.KalkDoubleValue, object>)Cos);
            RegisterFunction("acos", (Func<Kalk.Core.KalkDoubleValue, object>)Acos);
            RegisterFunction("cosh", (Func<Kalk.Core.KalkDoubleValue, object>)Cosh);
            RegisterFunction("acosh", (Func<Kalk.Core.KalkDoubleValue, object>)Acosh);
            RegisterFunction("sin", (Func<Kalk.Core.KalkDoubleValue, object>)Sin);
            RegisterFunction("asin", (Func<Kalk.Core.KalkDoubleValue, object>)Asin);
            RegisterFunction("sinh", (Func<Kalk.Core.KalkDoubleValue, object>)Sinh);
            RegisterFunction("asinh", (Func<Kalk.Core.KalkDoubleValue, object>)Asinh);
            RegisterFunction("tan", (Func<Kalk.Core.KalkDoubleValue, object>)Tan);
            RegisterFunction("atan", (Func<Kalk.Core.KalkDoubleValue, object>)Atan);
            RegisterFunction("tanh", (Func<Kalk.Core.KalkDoubleValue, object>)Tanh);
            RegisterFunction("atanh", (Func<Kalk.Core.KalkDoubleValue, object>)Atanh);
            RegisterFunction("atan2", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Atan2);
            RegisterFunction("fmod", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Fmod);
            RegisterFunction("frac", (Func<Kalk.Core.KalkDoubleValue, object>)Frac);
            RegisterFunction("rsqrt", (Func<Kalk.Core.KalkDoubleValue, object>)Rsqrt);
            RegisterFunction("sqrt", (Func<Kalk.Core.KalkDoubleValue, object>)Sqrt);
            RegisterFunction("log", (Func<Kalk.Core.KalkDoubleValue, object>)Log);
            RegisterFunction("log2", (Func<Kalk.Core.KalkDoubleValue, object>)Log2);
            RegisterFunction("log10", (Func<Kalk.Core.KalkDoubleValue, object>)Log10);
            RegisterFunction("exp", (Func<Kalk.Core.KalkDoubleValue, object>)Exp);
            RegisterFunction("exp2", (Func<Kalk.Core.KalkDoubleValue, object>)Exp2);
            RegisterFunction("pow", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Pow);
            RegisterFunction("round", (Func<Kalk.Core.KalkDoubleValue, object>)Round);
            RegisterFunction("floor", (Func<Kalk.Core.KalkDoubleValue, object>)Floor);
            RegisterFunction("ceil", (Func<Kalk.Core.KalkDoubleValue, object>)Ceiling);
            RegisterFunction("trunc", (Func<Kalk.Core.KalkDoubleValue, object>)Trunc);
            RegisterFunction("saturate", (Func<Kalk.Core.KalkDoubleValue, object>)Saturate);
            RegisterFunction("min", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Min);
            RegisterFunction("max", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Max);
            RegisterFunction("step", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Step);
            RegisterFunction("smoothstep", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Smoothstep);
            RegisterFunction("lerp", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Lerp);
            RegisterFunction("clamp", (Func<Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, Kalk.Core.KalkDoubleValue, object>)Clamp);
            RegisterFunction("real", (Func<Kalk.Core.KalkComplex, double>)Real);
            RegisterFunction("imag", (Func<Kalk.Core.KalkComplex, double>)Imag);
            RegisterFunction("phase", (Func<Kalk.Core.KalkComplex, double>)Phase);
            RegisterFunction("isfinite", (Func<Kalk.Core.KalkCompositeValue, object>)IsFinite);
            RegisterFunction("isinf", (Func<Kalk.Core.KalkCompositeValue, object>)IsInf);
            RegisterFunction("isnan", (Func<Kalk.Core.KalkCompositeValue, object>)IsNan);
            RegisterFunction("sum", (Func<object, object[], object>)Sum);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["nan"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the ""Not a Number"" constant for a double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["inf"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the infinity constant for a double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pi"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the PI constant. pi = 3.14159265358979";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["e"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the natural logarithmic base. e = 2.71828182845905";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["fib"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Calculates the fibonacci number for the specified input.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input number.")  { IsOptional = false });
                descriptor.Returns = @"The fibonacci number.";
                descriptor.Example = @"    >>> fib 50
    # fib(50)
    out = 12586269025
";
            }
            {
                var descriptor = Descriptors["i"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Defines the imaginary part of a complex number.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"A complex number.";
                descriptor.Example = @"    >>> 1 + 2i
    # 1 + 2 * i
    out = 1 + 2i
";
            }
            {
                var descriptor = Descriptors["all"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if all components of the specified value are non-zero.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"true if all components of the x parameter are non-zero; otherwise, false.";
                descriptor.Remarks = @"This function is similar to the `any` function.
    The `any` function determines if any components of the specified value are non-zero, while the `all` function determines if all components of the specified value are non-zero.";
                descriptor.Example = @"    >>> all(bool4(true, false, true, false))
    # all(bool4(true, false, true, false))
    out = false
    >>> all(bool4(true, true, true, true))
    # all(bool4(true, true, true, true))
    out = true
    >>> all([0,1,0,2])
    # all([0,1,0,2])
    out = false
    >>> all([1,1,1,1])
    # all([1,1,1,1])
    out = true
";
            }
            {
                var descriptor = Descriptors["any"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if any components of the specified value are non-zero.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"true if any components of the x parameter are non-zero; otherwise, false.";
                descriptor.Remarks = @"This function is similar to the `all` intrinsic function.
    The `any` function determines if any components of the specified value are non-zero,
    while the `all` function determines if all components of the specified value are non-zero.";
                descriptor.Example = @"    >>> any(bool4(true, false, true, false))
    # any(bool4(true, false, true, false))
    out = true
    >>> any(bool4(false, false, false, false))
    # any(bool4(false, false, false, false))
    out = false
    >>> any([0,1,0,2])
    # any([0,1,0,2])
    out = true
    >>> any([0,0,0,0])
    # any([0,0,0,0])
    out = false
";
            }
            {
                var descriptor = Descriptors["abs"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the absolute value of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The absolute value of the x parameter.";
                descriptor.Example = @"    >>> abs(-1)
    # abs(-1)
    out = 1
    >>> abs(float4(-1, 1, -2, -3))
    # abs(float4(-1, 1, -2, -3))
    out = float4(1, 1, 2, 3)
";
            }
            {
                var descriptor = Descriptors["rnd"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns a random value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A value to create random values for.")  { IsOptional = true });
                descriptor.Returns = @"A random value or a random value of the x parameter.";
                descriptor.Example = @"    >>> seed(0); rnd
    # seed(0); rnd
    out = 0.7262432699679598
    >>> rnd
    # rnd
    out = 0.8173253595909687
    >>> rnd(float4)
    # rnd(float4)
    out = float4(0.7680227, 0.5581612, 0.20603316, 0.5588848)
";
            }
            {
                var descriptor = Descriptors["seed"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Setup the seed function for rnd. The default seed is random.";
                descriptor.IsCommand = true;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"An original seed value for the `rnd` function.")  { IsOptional = true });
                descriptor.Remarks = @"The x is not specified, it will generate a random seed automatically.";
                descriptor.Example = @"    >>> seed(0); rnd
    # seed(0); rnd
    out = 0.7262432699679598
    >>> seed(1); rnd
    # seed(1); rnd
    out = 0.24866858415709278
";
            }
            {
                var descriptor = Descriptors["modf"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Splits the value x into fractional and integer parts, each of which has the same sign as x.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The signed-fractional portion of x.";
                descriptor.Example = @"    >>> modf(1.5)
    # modf(1.5)
    out = [1, 0.5]
    >>> modf(float2(-1.2, 3.4))
    # modf(float2(-1.2, 3.4))
    out = [float2(-1, 3), float2(-0.20000005, 0.4000001)]
";
            }
            {
                var descriptor = Descriptors["radians"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Converts the specified value from degrees to radians.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value in degrees.")  { IsOptional = false });
                descriptor.Returns = @"The x parameter converted from degrees to radians.";
                descriptor.Example = @"    >>> radians(90)
    # radians(90)
    out = 1.5707963267948966
    >>> radians(180)
    # radians(180)
    out = 3.141592653589793
";
            }
            {
                var descriptor = Descriptors["degrees"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Converts the specified value from radians to degrees.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"The x parameter converted from radians to degrees.";
                descriptor.Example = @"    >>> degrees(pi/2)
    # degrees(pi / 2)
    out = 90
    >>> degrees(pi)
    # degrees(pi)
    out = 180
";
            }
            {
                var descriptor = Descriptors["sign"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns an integer that indicates the sign of a number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A signed number.")  { IsOptional = false });
                descriptor.Returns = @"A number that indicates the sign of x:
     - -1 if x is less than zero
     - 0 if x is equal to zero
     - 1 if x is greater than zero.";
                descriptor.Example = @"    >>> sign(-5); sign(0); sign(2.3)
    # sign(-5); sign(0); sign(2.3)
    out = -1
    out = 0
    out = 1
    >>> sign float4(-1, 2, 0, 1.5)
    # sign(float4(-1, 2, 0, 1.5))
    out = float4(-1, 1, 0, 1)
";
            }
            {
                var descriptor = Descriptors["cos"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the cosine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The cosine of the x parameter.";
                descriptor.Example = @"    >>> cos 0.5
    # cos(0.5)
    out = 0.8775825618903728
    >>> cos float4(pi, pi/2, 0, 0.5)
    # cos(float4(pi, pi / 2, 0, 0.5))
    out = float4(-1, -4.371139E-08, 1, 0.87758255)
";
            }
            {
                var descriptor = Descriptors["acos"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the arccosine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value. Each component should be a floating-point value within the range of -1 to 1.")  { IsOptional = false });
                descriptor.Returns = @"The arccosine of the x parameter.";
                descriptor.Example = @"    >>> acos(-1)
    # acos(-1)
    out = 3.141592653589793
    >>> acos(0)
    # acos(0)
    out = 1.5707963267948966
    >>> acos(1)
    # acos(1)
    out = 0
    >>> acos(float4(-1,0,1,0.5))
    # acos(float4(-1, 0, 1, 0.5))
    out = float4(3.1415927, 1.5707964, 0, 1.0471976)
";
            }
            {
                var descriptor = Descriptors["cosh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the hyperbolic cosine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The hyperbolic cosine of the x parameter.";
                descriptor.Example = @"    >>> cosh(-1)
    # cosh(-1)
    out = 1.5430806348152437
    >>> cosh(1)
    # cosh(1)
    out = 1.5430806348152437
    >>> cosh(0)
    # cosh(0)
    out = 1
    >>> cosh(float4(-1, 1, 0, 2))
    # cosh(float4(-1, 1, 0, 2))
    out = float4(1.5430807, 1.5430807, 1, 3.7621956)
";
            }
            {
                var descriptor = Descriptors["acosh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the inverse hyperbolic cosine of a number. The number must be greater than or equal to 1.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"Any real number equal to or greater than 1.")  { IsOptional = false });
                descriptor.Returns = @"The inverse hyperbolic cosine of the x parameter";
                descriptor.Example = @"    >>> acosh(1)
    # acosh(1)
    out = 0
    >>> acosh(10)
    # acosh(10)
    out = 2.993222846126381
    >>> acosh(float4(1,2,4,10))
    # acosh(float4(1, 2, 4, 10))
    out = float4(0, 1.316958, 2.063437, 2.993223)
";
            }
            {
                var descriptor = Descriptors["sin"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the sine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The sine of the x parameter.";
                descriptor.Example = @"    >>> sin 0.5
    # sin(0.5)
    out = 0.479425538604203
    >>> sin float4(pi, pi/2, 0, 0.5)
    # sin(float4(pi, pi / 2, 0, 0.5))
    out = float4(-8.742278E-08, 1, 0, 0.47942555)
";
            }
            {
                var descriptor = Descriptors["asin"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the arcsine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value. Each component of the x parameter should be within the range of -π/2 to π/2.")  { IsOptional = false });
                descriptor.Returns = @"The arcsine of the x parameter.";
                descriptor.Example = @"    >>> asin 0.5
    # asin(0.5)
    out = 0.5235987755982989
    >>> asin float4(-1, 0, 1, 0.5)
    # asin(float4(-1, 0, 1, 0.5))
    out = float4(-1.5707964, 0, 1.5707964, 0.5235988)
";
            }
            {
                var descriptor = Descriptors["sinh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the hyperbolic sine of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The hyperbolic sine of the x parameter.";
                descriptor.Example = @"    >>> sinh(-1)
    # sinh(-1)
    out = -1.1752011936438014
    >>> sinh(0)
    # sinh(0)
    out = 0
    >>> sinh(1)
    # sinh(1)
    out = 1.1752011936438014
    >>> sinh(float4(-1, 1, 0, 2))
    # sinh(float4(-1, 1, 0, 2))
    out = float4(-1.1752012, 1.1752012, 0, 3.6268604)
";
            }
            {
                var descriptor = Descriptors["asinh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the inverse hyperbolic sine of a number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The inverse hyperbolic sine of the x parameter.";
                descriptor.Example = @"    >>> asinh(-1.1752011936438014)
    # asinh(-1.1752011936438014)
    out = -1
    >>> asinh(0)
    # asinh(0)
    out = 0
    >>> asinh(1.1752011936438014)
    # asinh(1.1752011936438014)
    out = 1
    >>> asinh(float4(-1.1752011936438014, 0, 1.1752011936438014, 2))
    # asinh(float4(-1.1752011936438014, 0, 1.1752011936438014, 2))
    out = float4(-1, 0, 1, 1.4436355)
";
            }
            {
                var descriptor = Descriptors["tan"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the tangent of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The tangent of the x parameter.";
                descriptor.Example = @"    >>> tan(0.5)
    # tan(0.5)
    out = 0.5463024898437905
    >>> tan(1)
    # tan(1)
    out = 1.5574077246549023
    >>> tan float4(1, 2, 3, 4)
    # tan(float4(1, 2, 3, 4))
    out = float4(1.5574077, -2.1850398, -0.14254655, 1.1578213)
";
            }
            {
                var descriptor = Descriptors["atan"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the arctangent of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The arctangent of the x parameter. This value is within the range of -π/2 to π/2.";
                descriptor.Example = @"    >>> atan(0.5)
    # atan(0.5)
    out = 0.4636476090008061
    >>> atan(1)
    # atan(1)
    out = 0.7853981633974483
    >>> atan(0)
    # atan(0)
    out = 0
    >>> atan(float4(0,1,2,3))
    # atan(float4(0, 1, 2, 3))
    out = float4(0, 0.7853982, 1.1071488, 1.2490457)
";
            }
            {
                var descriptor = Descriptors["tanh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the hyperbolic tangent of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value, in radians.")  { IsOptional = false });
                descriptor.Returns = @"The hyperbolic tangent of the x parameter.";
                descriptor.Example = @"    >>> tanh(0)
    # tanh(0)
    out = 0
    >>> tanh(1)
    # tanh(1)
    out = 0.7615941559557649
    >>> tanh(2)
    # tanh(2)
    out = 0.9640275800758169
    >>> tanh(float4(0, 1, 2, 3))
    # tanh(float4(0, 1, 2, 3))
    out = float4(0, 0.7615942, 0.9640276, 0.9950548)
";
            }
            {
                var descriptor = Descriptors["atanh"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the inverse hyperbolic tangent of a number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value. Number must be between -1 and 1 (excluding -1 and 1).")  { IsOptional = false });
                descriptor.Returns = @"The inverse hyperbolic tangent of the x parameter";
                descriptor.Example = @"    >>> atanh(0)
    # atanh(0)
    out = 0
    >>> atanh(0.5)
    # atanh(0.5)
    out = 0.5493061443340549
    >>> atanh(float4(-0.5, 0, 0.5, 0.8))
    # atanh(float4(-0.5, 0, 0.5, 0.8))
    out = float4(-0.54930615, 0, 0.54930615, 1.0986123)
";
            }
            {
                var descriptor = Descriptors["atan2"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the arctangent of two values (x,y).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The y value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The x value.")  { IsOptional = false });
                descriptor.Returns = @"The arctangent of (y,x).";
                descriptor.Remarks = @"The signs of the x and y parameters are used to determine the quadrant of the return values within the range of -π to π. The `atan2` function is well-defined for every point other than the origin, even if y equals 0 and x does not equal 0.";
                descriptor.Example = @"    >>> atan2(1,1)
    # atan2(1, 1)
    out = 0.7853981633974483
    >>> atan2(1,0)
    # atan2(1, 0)
    out = 1.5707963267948966
    >>> atan2(0,1)
    # atan2(0, 1)
    out = 0
    >>> atan2(float4(1), float4(0,1,-1,2))
    # atan2(float4(1), float4(0, 1, -1, 2))
    out = float4(1.5707964, 0.7853982, 2.3561945, 0.4636476)
";
            }
            {
                var descriptor = Descriptors["fmod"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the floating-point remainder of x/y.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The floating-point dividend.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The floating-point divisor.")  { IsOptional = false });
                descriptor.Returns = @"The floating-point remainder of the x parameter divided by the y parameter.";
                descriptor.Remarks = @"The floating-point remainder is calculated such that x = i * y + f, where i is an integer, f has the same sign as x, and the absolute value of f is less than the absolute value of y.";
                descriptor.Example = @"    >>> fmod(2.5, 2)
    # fmod(2.5, 2)
    out = 0.5
    >>> fmod(2.5, 3)
    # fmod(2.5, 3)
    out = 2.5
    >>> fmod(-1.5, 1)
    # fmod(-1.5, 1)
    out = -0.5
    >>> fmod(float4(1.5, 1.2, -2.3, -4.6), 0.2)
    # fmod(float4(1.5, 1.2, -2.3, -4.6), 0.2)
    out = float4(0.09999998, 2.9802322E-08, -0.09999992, -0.19999984)
";
            }
            {
                var descriptor = Descriptors["frac"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the fractional (or decimal) part of x; which is greater than or equal to 0 and less than 1.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The fractional part of the x parameter.";
                descriptor.Example = @"    >>> frac(1.25)
    # frac(1.25)
    out = 0.25
    >>> frac(10.5)
    # frac(10.5)
    out = 0.5
    >>> frac(-1.75)
    # frac(-1.75)
    out = 0.25
    >>> frac(-10.25)
    # frac(-10.25)
    out = 0.75
    >>> frac(float4(1.25, 10.5, -1.75, -10.25))
    # frac(float4(1.25, 10.5, -1.75, -10.25))
    out = float4(0.25, 0.5, 0.25, 0.75)
";
            }
            {
                var descriptor = Descriptors["rsqrt"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the reciprocal of the square root of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The reciprocal of the square root of the x parameter.";
                descriptor.Remarks = @"This function uses the following formula: 1 / sqrt(x).";
                descriptor.Example = @"    >>> rsqrt(1)
    # rsqrt(1)
    out = 1
    >>> rsqrt(2)
    # rsqrt(2)
    out = 0.7071067811865475
    >>> rsqrt(float4(1,2,3,4))
    # rsqrt(float4(1, 2, 3, 4))
    out = float4(1, 0.70710677, 0.57735026, 0.5)
";
            }
            {
                var descriptor = Descriptors["sqrt"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the square root of the specified floating-point value, per component.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified floating-point value.")  { IsOptional = false });
                descriptor.Returns = @"The square root of the x parameter, per component.";
                descriptor.Example = @"    >>> sqrt(1)
    # sqrt(1)
    out = 1
    >>> sqrt(2)
    # sqrt(2)
    out = 1.4142135623730951
    >>> sqrt(float4(1,2,3,4))
    # sqrt(float4(1, 2, 3, 4))
    out = float4(1, 1.4142135, 1.7320508, 2)
";
            }
            {
                var descriptor = Descriptors["log"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base-e logarithm of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-e logarithm of the x parameter. If the x parameter is negative, this function returns indefinite. If the x parameter is 0, this function returns `-inf`.";
                descriptor.Example = @"    >>> log 1
    # log(1)
    out = 0
    >>> log 2
    # log(2)
    out = 0.6931471805599453
    >>> log 0
    # log(0)
    out = -inf
    >>> log float4(0,1,2,3)
    # log(float4(0, 1, 2, 3))
    out = float4(-inf, 0, 0.6931472, 1.0986123)
";
            }
            {
                var descriptor = Descriptors["log2"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base-2 logarithm of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-2 logarithm of the x parameter. If the x parameter is negative, this function returns indefinite. If the x parameter is 0, this function returns -inf.";
                descriptor.Example = @"    >>> log2 0
    # log2(0)
    out = -inf
    >>> log2 8
    # log2(8)
    out = 3
    >>> log2 129
    # log2(129)
    out = 7.011227255423254
    >>> log2 float4(0, 2, 16, 257)
    # log2(float4(0, 2, 16, 257))
    out = float4(-inf, 1, 4, 8.005625)
";
            }
            {
                var descriptor = Descriptors["log10"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base-10 logarithm of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-10 logarithm of the x parameter. If the x parameter is negative, this function returns indefinite. If the x is 0, this function returns -inf.";
                descriptor.Example = @"    >>> log10 0
    # log10(0)
    out = -inf
    >>> log10 10
    # log10(10)
    out = 1
    >>> log10 100
    # log10(100)
    out = 2
    >>> log10 1001
    # log10(1001)
    out = 3.000434077479319
    >>> log10(float4(0,10,100,1001))
    # log10(float4(0, 10, 100, 1001))
    out = float4(-inf, 1, 2, 3.0004342)
";
            }
            {
                var descriptor = Descriptors["exp"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base-e exponential, or e^x, of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-e exponential of the x parameter.";
                descriptor.Example = @"    >>> exp(0)
    # exp(0)
    out = 1
    >>> exp(1)
    # exp(1)
    out = 2.718281828459045
    >>> exp(float4(0,1,2,3))
    # exp(float4(0, 1, 2, 3))
    out = float4(1, 2.7182817, 7.389056, 20.085537)
";
            }
            {
                var descriptor = Descriptors["exp2"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the base 2 exponential, or 2^x, of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The base-2 exponential of the x parameter.";
                descriptor.Example = @"    >>> exp2(0)
    # exp2(0)
    out = 1
    >>> exp2(1)
    # exp2(1)
    out = 2
    >>> exp2(4)
    # exp2(4)
    out = 16
    >>> exp2(float4(0,1,2,3))
    # exp2(float4(0, 1, 2, 3))
    out = float4(1, 2, 4, 8)
";
            }
            {
                var descriptor = Descriptors["pow"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the specified value raised to the specified power.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The specified power.")  { IsOptional = false });
                descriptor.Returns = @"The x parameter raised to the power of the y parameter.";
                descriptor.Example = @"    >>> pow(1.5, 3.5)
    # pow(1.5, 3.5)
    out = 4.133513940946613
    >>> pow(2, 4)
    # pow(2, 4)
    out = 16
    >>> pow(float4(1,2,3,4), 4)
    # pow(float4(1, 2, 3, 4), 4)
    out = float4(1, 16, 81, 256)
    >>> pow(float4(1..4), float4(5..8))
    # pow(float4(1..4), float4(5..8))
    out = float4(1, 64, 2187, 65536)
";
            }
            {
                var descriptor = Descriptors["round"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Rounds the specified value to the nearest integer.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The x parameter, rounded to the nearest integer within a floating-point type.";
                descriptor.Example = @"    >>> round(0.2); round(1.5); round(10.7)
    # round(0.2); round(1.5); round(10.7)
    out = 0
    out = 2
    out = 11
    >>> round(-0.2); round(-1.5); round(-10.7)
    # round(-0.2); round(-1.5); round(-10.7)
    out = -0
    out = -2
    out = -11
";
            }
            {
                var descriptor = Descriptors["floor"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the largest integer that is less than or equal to the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The largest integer value (returned as a floating-point type) that is less than or equal to the x parameter.";
                descriptor.Example = @"    >>> floor(0.2); floor(1.5); floor(10.7)
    # floor(0.2); floor(1.5); floor(10.7)
    out = 0
    out = 1
    out = 10
    >>> floor(-0.2); floor(-1.5); floor(-10.7)
    # floor(-0.2); floor(-1.5); floor(-10.7)
    out = -1
    out = -2
    out = -11
";
            }
            {
                var descriptor = Descriptors["ceil"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the smallest integer value that is greater than or equal to the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The smallest integer value (returned as a floating-point type) that is greater than or equal to the x parameter.";
                descriptor.Example = @"    >>> ceil(0.2); ceil(1.5); ceil(10.7)
    # ceil(0.2); ceil(1.5); ceil(10.7)
    out = 1
    out = 2
    out = 11
    >>> ceil(-0.2); ceil(-1.5); ceil(-10.7)
    # ceil(-0.2); ceil(-1.5); ceil(-10.7)
    out = -0
    out = -1
    out = -10
";
            }
            {
                var descriptor = Descriptors["trunc"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Truncates a floating-point value to the integer component.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The input value truncated to an integer component.";
                descriptor.Remarks = @"This function truncates a floating-point value to the integer component. Given a floating-point value of 1.6, the trunc function would return 1.0, where as the round function would return 2.0.";
                descriptor.Example = @"    >>> trunc(0.2); trunc(1.5); trunc(10.7)
    # trunc(0.2); trunc(1.5); trunc(10.7)
    out = 0
    out = 1
    out = 10
    >>> trunc(-0.2); trunc(-1.5); trunc(-10.7)
    # trunc(-0.2); trunc(-1.5); trunc(-10.7)
    out = -0
    out = -1
    out = -10
";
            }
            {
                var descriptor = Descriptors["saturate"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Clamps the specified value within the range of 0 to 1.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"The x parameter, clamped within the range of 0 to 1.";
                descriptor.Example = @"    >>> saturate(10)
    # saturate(10)
    out = 1
    >>> saturate(-10)
    # saturate(-10)
    out = 0
    >>> saturate(float4(-1, 0.5, 1, 2))
    # saturate(float4(-1, 0.5, 1, 2))
    out = float4(0, 0.5, 1, 1)
";
            }
            {
                var descriptor = Descriptors["min"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Selects the lesser of x and y.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The x input value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The y input value.")  { IsOptional = false });
                descriptor.Returns = @"The x or y parameter, whichever is the smallest value.";
                descriptor.Example = @"    >>> min(-5, 6)
    # min(-5, 6)
    out = -5
    >>> min(1, 0)
    # min(1, 0)
    out = 0
    >>> min(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    # min(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    out = float4(0, 0, 2, 2)
";
            }
            {
                var descriptor = Descriptors["max"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Selects the greater of x and y.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The x input value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The y input value.")  { IsOptional = false });
                descriptor.Returns = @"The x or y parameter, whichever is the largest value.";
                descriptor.Example = @"    >>> max(-5, 6)
    # max(-5, 6)
    out = 6
    >>> max(1, 0)
    # max(1, 0)
    out = 1
    >>> max(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    # max(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    out = float4(1, 1, 3, 3)
";
            }
            {
                var descriptor = Descriptors["step"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Compares two values, returning 0 or 1 based on which value is greater.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The first floating-point value to compare.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The second floating-point value to compare.")  { IsOptional = false });
                descriptor.Returns = @"1 if the x parameter is greater than or equal to the y parameter; otherwise, 0.";
                descriptor.Remarks = @"This function uses the following formula: (x >= y) ? 1 : 0. The function returns either 0 or 1 depending on whether the x parameter is greater than the y parameter. To compute a smooth interpolation between 0 and 1, use the `smoothstep` function.";
                descriptor.Example = @"    >>> step(1, 5)
    # step(1, 5)
    out = 1
    >>> step(5, 1)
    # step(5, 1)
    out = 0
    >>> step(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    # step(float4(0, 1, 2, 3), float4(1, 0, 3, 2))
    out = float4(1, 0, 1, 0)
    >>> step(-10, 5)
    # step(-10, 5)
    out = 1
    >>> step(5.5, -10.5)
    # step(5.5, -10.5)
    out = 0
";
            }
            {
                var descriptor = Descriptors["smoothstep"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns a smooth Hermite interpolation between 0 and 1, if x is in the range [min, max].";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("min", @"The minimum range of the x parameter.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("max", @"The maximum range of the x parameter.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value to be interpolated.")  { IsOptional = false });
                descriptor.Returns = @"Returns 0 if x is less than min; 1 if x is greater than max; otherwise, a value between 0 and 1 if x is in the range [min, max].";
                descriptor.Remarks = @"Use the smoothstep function to create a smooth transition between two values. For example, you can use this function to blend two colors smoothly.";
                descriptor.Example = @"    >>> smoothstep(float4(0), float4(1), float4(-0.5))
    # smoothstep(float4(0), float4(1), float4(-0.5))
    out = float4(0, 0, 0, 0)
    >>> smoothstep(float4(0), float4(1), float4(1.5))
    # smoothstep(float4(0), float4(1), float4(1.5))
    out = float4(1, 1, 1, 1)
    >>> smoothstep(float4(0), float4(1), float4(0.5))
    # smoothstep(float4(0), float4(1), float4(0.5))
    out = float4(0.5, 0.5, 0.5, 0.5)
    >>> smoothstep(float4(0), float4(1), float4(0.9))
    # smoothstep(float4(0), float4(1), float4(0.9))
    out = float4(0.972, 0.972, 0.972, 0.972)
";
            }
            {
                var descriptor = Descriptors["lerp"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Performs a linear interpolation.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The first-floating point value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The second-floating point value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("s", @"A value that linearly interpolates between the x parameter and the y parameter.")  { IsOptional = false });
                descriptor.Returns = @"The result of the linear interpolation.";
                descriptor.Example = @"    >>> lerp(0, 10, 0.5)
    # lerp(0, 10, 0.5)
    out = 5
    >>> lerp(rgb(""AliceBlue"").xyz, rgb(""Green"").xyz, 0.5)
    # lerp(rgb(""AliceBlue"").xyz, rgb(""Green"").xyz, 0.5)
    out = float3(0.47058824, 0.7372549, 0.5)
";
            }
            {
                var descriptor = Descriptors["clamp"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Clamps the specified value to the specified minimum and maximum range.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A value to clamp.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("min", @"The specified minimum range.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("max", @"The specified maximum range.")  { IsOptional = false });
                descriptor.Returns = @"The clamped value for the x parameter.";
                descriptor.Remarks = @"For values of -inf or inf, clamp will behave as expected. However for values of `nan`, the results are undefined.";
                descriptor.Example = @"    >>> clamp(-1, 0, 1)
    # clamp(-1, 0, 1)
    out = 0
    >>> clamp(2, 0, 1)
    # clamp(2, 0, 1)
    out = 1
    >>> clamp(0.5, 0, 1)
    # clamp(0.5, 0, 1)
    out = 0.5
    >>> clamp(float4(0, 1, -2, 3), float4(0, -1, 3, 4), float4(1, 2, 5, 6))
    # clamp(float4(0, 1, -2, 3), float4(0, -1, 3, 4), float4(1, 2, 5, 6))
    out = float4(0, 1, 3, 4)
";
            }
            {
                var descriptor = Descriptors["real"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the real part of the complex number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A complex number.")  { IsOptional = false });
                descriptor.Returns = @"The real part of the parameter x complex number.";
                descriptor.Example = @"    >>> real(1.5 + 2.5i)
    # real(1.5 + 2.5 * i)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["imag"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the imaginary part of the complex number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A complex number.")  { IsOptional = false });
                descriptor.Returns = @"The imaginary part of the parameter x complex number.";
                descriptor.Example = @"    >>> imag(1.5 + 2.5i)
    # imag(1.5 + 2.5 * i)
    out = 2.5
";
            }
            {
                var descriptor = Descriptors["phase"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Returns the phase of the complex number.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"A complex number.")  { IsOptional = false });
                descriptor.Returns = @"The phase of the parameter x complex number.";
                descriptor.Example = @"    >>> phase(1.5 + 2.5i)
    # phase(1.5 + 2.5 * i)
    out = 1.0303768265243125
";
            }
            {
                var descriptor = Descriptors["isfinite"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if the specified floating-point value is finite.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"Returns a value of the same size as the input, with a value set to `true` if the x parameter is finite; otherwise `false`.";
                descriptor.Example = @"    >>> isfinite(1)
    # isfinite(1)
    out = true
    >>> isfinite(nan)
    # isfinite(nan)
    out = false
    >>> isfinite(inf)
    # isfinite(inf)
    out = false
    >>> isfinite(float4(1, -10.5, inf, nan))
    # isfinite(float4(1, -10.5, inf, nan))
    out = bool4(true, true, false, false)
";
            }
            {
                var descriptor = Descriptors["isinf"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if the specified value is infinite.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"Returns a value of the same size as the input, with a value set to `true` if the x parameter is +inf or -inf. Otherwise, `false`.";
                descriptor.Example = @"    >>> isinf(1)
    # isinf(1)
    out = false
    >>> isinf(inf)
    # isinf(inf)
    out = true
    >>> isinf(float4(1, -10.5, inf, nan))
    # isinf(float4(1, -10.5, inf, nan))
    out = bool4(false, false, true, false)
";
            }
            {
                var descriptor = Descriptors["isnan"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Determines if the specified value is `nan`.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified value.")  { IsOptional = false });
                descriptor.Returns = @"Returns a value of the same size as the input, with a value set to `true` if the x parameter is `nan`. Otherwise, `false`.";
                descriptor.Example = @"    >>> isnan(1)
    # isnan(1)
    out = false
    >>> isnan(inf)
    # isnan(inf)
    out = false
    >>> isnan(nan)
    # isnan(nan)
    out = true
    >>> isnan(float4(1, -10.5, inf, nan))
    # isnan(float4(1, -10.5, inf, nan))
    out = bool4(false, false, false, true)
";
            }
            {
                var descriptor = Descriptors["sum"];
                descriptor.Category = "Math Functions";
                descriptor.Description = @"Performs the summation of the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The specified value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("values", @"Additional values.")  { IsOptional = false });
                descriptor.Returns = @"The summation of the values.";
                descriptor.Example = @"    >>> sum(1,2,3,4)
    # sum(1, 2, 3, 4)
    out = 10
    >>> sum(float4(1..4))
    # sum(float4(1..4))
    out = 10
    >>> sum(float4(1..4), float4(5..8))
    # sum(float4(1..4), float4(5..8))
    out = float4(15, 16, 17, 18)
    >>> sum(""a"", ""b"", ""c"")
    # sum(""a"", ""b"", ""c"")
    out = ""abc""
    >>> sum([""a"", ""b"", ""c""])
    # sum([""a"", ""b"", ""c""])
    out = ""abc""
";
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class MemoryModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("malloc", (Func<int, Kalk.Core.KalkNativeBuffer>)Malloc);
            RegisterFunction("bitcast", (Func<object, object, object>)Bitcast);
            RegisterFunction("asbytes", (Func<object, Kalk.Core.KalkNativeBuffer>)AsBytes);
            RegisterFunction("countbits", (Func<object, object>)CountBits);
            RegisterFunction("firstbithigh", (Func<object, object>)FirstBitHigh);
            RegisterFunction("firstbitlow", (Func<object, object>)FirstBitLow);
            RegisterFunction("reversebits", (Func<object, object>)ReverseBits);
            RegisterFunction("asdouble", (Func<object, double>)AsDouble);
            RegisterFunction("asfloat", (Func<object, float>)AsFloat);
            RegisterFunction("aslong", (Func<object, long>)AsLong);
            RegisterFunction("asulong", (Func<object, ulong>)AsULong);
            RegisterFunction("asint", (Func<object, int>)AsInt);
            RegisterFunction("asuint", (Func<object, uint>)AsUInt);
            RegisterFunction("bytebuffer", (Func<object[], Kalk.Core.KalkNativeBuffer>)ByteBuffer);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["malloc"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Allocates a `bytebuffer` of the specified size.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("size", @"Size of the bytebuffer.")  { IsOptional = false });
                descriptor.Returns = @"A bytebuffer of the specified size.";
                descriptor.Example = @"    >>> buffer = malloc(16)
    # buffer = malloc(16)
    buffer = bytebuffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    >>> buffer[0] = 5
    >>> buffer
    # buffer
    out = bytebuffer([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
";
            }
            {
                var descriptor = Descriptors["bitcast"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Binary cast of a value to a target type.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("type", @"The type to cast to.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The value to cast.")  { IsOptional = false });
                descriptor.Returns = @"The binary cast of the input value.";
                descriptor.Remarks = @"The supported types are `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, `rgb`, `rgba` and all vector and matrix types.";
                descriptor.Example = @"    >>> bitcast(int, 1.5f)
    # bitcast(int, 1.5f)
    out = 1069547520
    >>> bitcast(float, out)
    # bitcast(float, out)
    out = 1.5
    >>> bitcast(long, 2.5)
    # bitcast(long, 2.5)
    out = 4612811918334230528
    >>> bitcast(double, out)
    # bitcast(double, out)
    out = 2.5
    >>> asbytes(float4(1..4))
    # asbytes(float4(1..4))
    out = bytebuffer([0, 0, 128, 63, 0, 0, 0, 64, 0, 0, 64, 64, 0, 0, 128, 64])
    >>> bitcast(float4, out)
    # bitcast(float4, out)
    out = float4(1, 2, 3, 4)
";
            }
            {
                var descriptor = Descriptors["asbytes"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Binary cast the specified value to a bytebuffer.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"An input value.")  { IsOptional = false });
                descriptor.Returns = @"A binary bytebuffer representing the value in binary form. The size of the buffer equals the binary size in memory of the input value.";
                descriptor.Example = @"    >>> asbytes(float4(1..4))
    # asbytes(float4(1..4))
    out = bytebuffer([0, 0, 128, 63, 0, 0, 0, 64, 0, 0, 64, 64, 0, 0, 128, 64])
    >>> asbytes(int(0x01020304))
    # asbytes(int(16909060))
    out = bytebuffer([4, 3, 2, 1])
    >>> asbytes(1.5)
    # asbytes(1.5)
    out = bytebuffer([0, 0, 0, 0, 0, 0, 248, 63])
    >>> asbytes(2.5f)
    # asbytes(2.5f)
    out = bytebuffer([0, 0, 32, 64])
";
            }
            {
                var descriptor = Descriptors["countbits"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Counts the number of bits (per component) of the input value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The number of bits (per component if the input is an int vector).";
                descriptor.Example = @"    >>> for val in 0..7; countbits(val); end;
    # for val in 0..7; countbits(val); end;
    out = 0
    out = 1
    out = 1
    out = 2
    out = 1
    out = 2
    out = 2
    out = 3
    >>> countbits(int4(1,2,3,4))
    # countbits(int4(1, 2, 3, 4))
    out = int4(1, 1, 2, 1)
    >>> countbits(bytebuffer(1..16))
    # countbits(bytebuffer(1..16))
    out = 33
";
            }
            {
                var descriptor = Descriptors["firstbithigh"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Gets the location of the first set bit starting from the highest order bit and working downward, per component.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The location of the first set bit.";
                descriptor.Remarks = @"If no bits are sets, this function will return -1.";
                descriptor.Example = @"    >>> firstbithigh 128
    # firstbithigh(128)
    out = 24
    >>> firstbithigh byte(128)
    # firstbithigh(byte(128))
    out = 0
    >>> firstbithigh 0
    # firstbithigh(0)
    out = -1
    >>> firstbithigh(int4(1, -1, 65536, 1 << 20))
    # firstbithigh(int4(1, -1, 65536, 1 << 20))
    out = int4(31, 0, 15, 11)
";
            }
            {
                var descriptor = Descriptors["firstbitlow"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Returns the location of the first set bit starting from the lowest order bit and working upward, per component.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The location of the first set bit.";
                descriptor.Remarks = @"If no bits are sets, this function will return -1.";
                descriptor.Example = @"    >>> firstbitlow 128
    # firstbitlow(128)
    out = 7
    >>> firstbitlow byte(128)
    # firstbitlow(byte(128))
    out = 7
    >>> firstbitlow 0
    # firstbitlow(0)
    out = -1
    >>> firstbitlow(int4(1, -1, 65536, 1 << 20))
    # firstbitlow(int4(1, -1, 65536, 1 << 20))
    out = int4(0, 0, 16, 20)
";
            }
            {
                var descriptor = Descriptors["reversebits"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reverses the order of the bits, per component";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input value, with the bit order reversed";
                descriptor.Example = @"    >>> reversebits 128
    # reversebits(128)
    out = 16777216
    >>> reversebits out
    # reversebits(out)
    out = 128
    >>> reversebits byte(128)
    # reversebits(byte(128))
    out = 1
    >>> reversebits(out)
    # reversebits(out)
    out = 128
    >>> reversebits(int4(1,2,3,4))
    # reversebits(int4(1, 2, 3, 4))
    out = int4(-2147483648, 1073741824, -1073741824, 536870912)
    >>> reversebits out
    # reversebits(out)
    out = int4(1, 2, 3, 4)
";
            }
            {
                var descriptor = Descriptors["asdouble"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets a 64-bit value into a double.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a double.";
                descriptor.Example = @"    >>> asdouble(1.5)
    # asdouble(1.5)
    out = 1.5
    >>> aslong(1.5)
    # aslong(1.5)
    out = 4609434218613702656
    >>> asdouble(out)
    # asdouble(out)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["asfloat"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets a 32-bit value into a float.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a float.";
                descriptor.Example = @"    >>> asfloat(1.5f)
    # asfloat(1.5f)
    out = 1.5
    >>> asint(1.5f)
    # asint(1.5f)
    out = 1069547520
    >>> asfloat(out)
    # asfloat(out)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["aslong"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets an input value to a 64-bit long.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a 64-bit long.";
                descriptor.Example = @"    >>> aslong(1.5)
    # aslong(1.5)
    out = 4609434218613702656
    >>> asdouble(out)
    # asdouble(out)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["asulong"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets an input value to a 64-bit ulong.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a 64-bit ulong.";
                descriptor.Example = @"    >>> asulong(-1.5)
    # asulong(-1.5)
    out = 13832806255468478464
    >>> asdouble(out)
    # asdouble(out)
    out = -1.5
";
            }
            {
                var descriptor = Descriptors["asint"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets an input value into a 32-bit int.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a 32-bit int.";
                descriptor.Example = @"    >>> asint(1.5f)
    # asint(1.5f)
    out = 1069547520
    >>> asfloat(out)
    # asfloat(out)
    out = 1.5
";
            }
            {
                var descriptor = Descriptors["asuint"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Reinterprets an input value into a 32-bit uint.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The input value.")  { IsOptional = false });
                descriptor.Returns = @"The input recast as a 32-bit uint.";
                descriptor.Example = @"    >>> asuint(-1.5f)
    # asuint(-1.5f)
    out = 3217031168
    >>> asfloat(out)
    # asfloat(out)
    out = -1.5
";
            }
            {
                var descriptor = Descriptors["bytebuffer"];
                descriptor.Category = "Misc Memory Functions";
                descriptor.Description = @"Creates a bytebuffer from the specified input.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("values", @"The input values.")  { IsOptional = false });
                descriptor.Returns = @"A bytebuffer from the specified input.";
                descriptor.Example = @"    >>> bytebuffer
    # bytebuffer
    out = bytebuffer([])
    >>> bytebuffer(0,1,2,3,4)
    # bytebuffer(0, 1, 2, 3, 4)
    out = bytebuffer([0, 1, 2, 3, 4])
    >>> bytebuffer(float4(1))
    # bytebuffer(float4(1))
    out = bytebuffer([0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63])
    >>> bytebuffer([1,2,3,4])
    # bytebuffer([1,2,3,4])
    out = bytebuffer([1, 2, 3, 4])
";
            }
        }        
    }
}
namespace Kalk.Core
{
    public partial class MiscModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("ascii", (Func<object, object>)Ascii);
            RegisterFunction("keys", (Func<object, System.Collections.IEnumerable>)Keys);
            RegisterFunction("guid", (Func<string>)Guid);
            RegisterFunction("size", (Func<object, int>)Size);
            RegisterFunction("values", (Func<object, System.Collections.IEnumerable>)Values);
            RegisterFunction("hex", (Func<object, bool, string, object>)Hexadecimal);
            RegisterFunction("bin", (Func<object, bool, string, object>)Binary);
            RegisterFunction("utf8", (Func<object, object>)GetUtf8);
            RegisterFunction("utf16", (Func<object, object>)GetUtf16);
            RegisterFunction("utf32", (Func<object, object>)GetUtf32);
            RegisterFunction("insert_at", (Func<object, int, object, object>)InsertAt);
            RegisterFunction("remove_at", (Func<object, int, object>)RemoveAt);
            RegisterFunction("contains", (Func<object, object, Kalk.Core.KalkBool>)Contains);
            RegisterFunction("replace", (Func<object, object, object, object>)Replace);
            RegisterFunction("slice", (Func<object, int, int?, object>)Slice);
            RegisterFunction("lines", (Func<string, Scriban.Runtime.ScriptRange>)Lines);
            RegisterFunction("colors", (Func<object>)Colors);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["ascii"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Prints the ascii table or convert an input string to an ascii array, or an ascii array to a string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("obj", @"An optional input (string or array of numbers or directly an integer).")  { IsOptional = true });
                descriptor.Returns = @"Depending on the input:
    - If no input, it will display the ascii table
    - If the input is an integer, it will convert it to the equivalent ascii char.
    - If the input is a string, it will convert the string to a byte buffer containing the corresponding ascii bytes.
    - If the input is an array of integer, it will convert each element to the equivalent ascii char.";
                descriptor.Example = @"    >>> ascii 65
    # ascii(65)
    out = ""A""
    >>> ascii 97
    # ascii(97)
    out = ""a""
    >>> ascii ""A""
    # ascii(""A"")
    out = 65
    >>> ascii ""kalk""
    # ascii(""kalk"")
    out = bytebuffer([107, 97, 108, 107])
    >>> ascii out
    # ascii(out)
    out = ""kalk""
";
            }
            {
                var descriptor = Descriptors["keys"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Returns the keys of the specified object.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("obj", @"An object to get the keys from.")  { IsOptional = false });
                descriptor.Returns = @"The keys of the parameter obj.";
                descriptor.Example = @"    >>> obj = {m: 1, n: 2}; keys obj
    # obj = {m: 1, n: 2}; keys(obj)
    obj = {m: 1, n: 2}
    out = [""m"", ""n""]
";
            }
            {
                var descriptor = Descriptors["guid"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Returns a new GUID as a string.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"A new GUID as a string.";
            }
            {
                var descriptor = Descriptors["size"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Returns the size of the specified object.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("obj", @"The object value.")  { IsOptional = false });
                descriptor.Returns = @"The size of the object.";
                descriptor.Example = @"    >>> size 1
    # size(1)
    out = 0
    >>> size ""kalk""
    # size(""kalk"")
    out = 4
    >>> size float4(1,2,3,4)
    # size(float4(1, 2, 3, 4))
    out = 4
    >>> size [1, 2, 3]
    # size([1, 2, 3])
    out = 3
";
            }
            {
                var descriptor = Descriptors["values"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Returns the values of the specified object.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("obj", @"An object to get the values from.")  { IsOptional = false });
                descriptor.Returns = @"The values of the parameter obj.";
                descriptor.Example = @"    >>> obj = {m: 1, n: 2}; values obj
    # obj = {m: 1, n: 2}; values(obj)
    obj = {m: 1, n: 2}
    out = [1, 2]
";
            }
            {
                var descriptor = Descriptors["hex"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts an integral/bytebuffer input to an hexadecimal representation or convert an hexadecimal input string
    to an integral/bytebuffer representation.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("separator", @"The character used to separate hexadecimal bytes when converting
    from integral to hexadecimal.")  { IsOptional = true });
                descriptor.Params.Add(new KalkParamDescriptor("prefix", @"Output the prefix `0x` in front of each hexadecimal bytes when converting
    from integral to hexadecimal.")  { IsOptional = true });
                descriptor.Returns = @"The hexadecimal representation of the input or convert the hexadecimal input string
    to an integral representation.";
                descriptor.Remarks = @"When converting from a hexadecimal string to an integral representation, this method
    will skip any white-space characters, comma `,`, colon `:`, semi-colon `;`, underscore `_` and
    dash `-`.
    When the hexadecimal input string can be converted to an integral less than or equal 8 bytes (64 bits)
    it will convert it to a single integral result, otherwise it will convert to a bytebuffer.
    See the following examples.";
                descriptor.Example = @"    >>> hex 10
    # hex(10)
    out = ""0A""
    >>> hex ""0a""
    # hex(""0a"")
    out = 10
    >>> hex ""0xff030201""
    # hex(""0xff030201"")
    out = 4278387201
    >>> hex out
    # hex(out)
    out = ""01 02 03 FF""
    >>> hex ""01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F""
    # hex(""01:02:03:04:05:06:07:08:09:0A:0B:0C:0D:0E:0F"")
    out = bytebuffer([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
    >>> hex(out, true, "","")
    # hex(out, true, "","")
    out = ""0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F""
    >>> hex out
    # hex(out)
    out = bytebuffer([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
    >>> hex(""1a,2b;3c 4d-5e_6f"")
    # hex(""1a,2b;3c 4d-5e_6f"")
    out = 103832130169626
    >>> hex out
    # hex(out)
    out = ""1A 2B 3C 4D 6F 5E 00 00""
    >>> hex float4(1,2,3,4)
    # hex(float4(1, 2, 3, 4))
    out = ""00 00 80 3F 00 00 00 40 00 00 40 40 00 00 80 40""
";
            }
            {
                var descriptor = Descriptors["bin"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts an integral/bytebuffer input to a binary representation or convert a binary input string
    to an integral/bytebuffer representation.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("prefix", @"Output the prefix `0x` in front of each binary bytes when converting
        from integral to binary.")  { IsOptional = true });
                descriptor.Params.Add(new KalkParamDescriptor("separator", @"The character used to separate binary bytes when converting
        from integral to binary.")  { IsOptional = true });
                descriptor.Returns = @"The binary representation of the input or convert the binary input string
    to an integral representation.";
                descriptor.Remarks = @"When converting from a binary string to an integral representation, this method
    will skip any white-space characters, comma `,`, colon `:`, semi-colon `;`, underscore `_` and
    dash `-`.
    When the binary input string can be converted to an integral less than or equal 8 bytes (64 bits)
    it will convert it to a single integral result, otherwise it will convert to a bytebuffer.
    See the following examples.";
                descriptor.Example = @"    >>> bin 10
    # bin(10)
    out = ""00001010""
    >>> bin out
    # bin(out)
    out = 10
    >>> bin 0xff030201
    # bin(-16580095)
    out = ""00000001 00000010 00000011 11111111""
    >>> bin out
    # bin(out)
    out = 4278387201
    >>> bin ""11111111000000110000001000000001""
    # bin(""11111111000000110000001000000001"")
    out = 4278387201
";
            }
            {
                var descriptor = Descriptors["utf8"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts a string to an UTF8 bytebuffer or convert a bytebuffer of UTF8 bytes to a string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The UTF8 bytebuffer representation of the input string or the string representation of the input UTF8 bytebuffer.";
                descriptor.Example = @"    >>> utf8 ""kalk""
    # utf8(""kalk"")
    out = bytebuffer([107, 97, 108, 107])
    >>> utf8 out
    # utf8(out)
    out = ""kalk""
";
            }
            {
                var descriptor = Descriptors["utf16"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts a string to an UTF16 bytebuffer or convert a bytebuffer of UTF16 bytes to a string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The UTF16 bytebuffer representation of the input string or the string representation of the input UTF16 bytebuffer.";
                descriptor.Example = @"    >>> utf16 ""kalk""
    # utf16(""kalk"")
    out = bytebuffer([107, 0, 97, 0, 108, 0, 107, 0])
    >>> utf16 out
    # utf16(out)
    out = ""kalk""
";
            }
            {
                var descriptor = Descriptors["utf32"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Converts a string to an UTF32 bytebuffer or convert a bytebuffer of UTF32 bytes to a string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The specified input.")  { IsOptional = false });
                descriptor.Returns = @"The UTF32 bytebuffer representation of the input string or the string representation of the input UTF32 bytebuffer.";
                descriptor.Example = @"    >>> utf32 ""kalk""
    # utf32(""kalk"")
    out = bytebuffer([107, 0, 0, 0, 97, 0, 0, 0, 108, 0, 0, 0, 107, 0, 0, 0])
    >>> utf32 out
    # utf32(out)
    out = ""kalk""
";
            }
            {
                var descriptor = Descriptors["insert_at"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Inserts an item into a string or list at the specified index.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"A string or list to insert an item into.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("index", @"The index at which to insert the item.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("item", @"The item to insert.")  { IsOptional = false });
                descriptor.Returns = @"A new string with the item inserted, or a new list with the item inserted at the specified index.";
                descriptor.Remarks = @"The index is adjusted at the modulo of the length of the input value.
    If the index is < 0, then the index starts from the end of the string/list length + 1. A value of -1 for the index would insert the item at the end, after the last element of the string or list.";
                descriptor.Example = @"    >>> insert_at(""kalk"", 0, ""YES"")
    # insert_at(""kalk"", 0, ""YES"")
    out = ""YESkalk""
    >>> insert_at(""kalk"", -1, ""YES"")
    # insert_at(""kalk"", -1, ""YES"")
    out = ""kalkYES""
    >>> insert_at(0..10, 1, 50)
    # insert_at(0..10, 1, 50)
    out = [0, 50, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> insert_at(0..9, 21, 50) # final index is 21 % 10 = 1
    # insert_at(0..9, 21, 50) # final index is 21 % 10 = 1
    out = [0, 50, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> insert_at([], 3, 1)
    # insert_at([], 3, 1)
    out = [1]
";
            }
            {
                var descriptor = Descriptors["remove_at"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Removes an item from a string or list at the specified index.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"A string or list to remove an item from.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("index", @"The index at which to remove the item.")  { IsOptional = false });
                descriptor.Returns = @"A new string/list with the item at the specified index removed.";
                descriptor.Remarks = @"The index is adjusted at the modulo of the length of the input value.
    If the index is < 0, then the index starts from the end of the string/list length. A value of -1 for the index would remove the last element.";
                descriptor.Example = @"    >>> remove_at(""kalk"", 0)
    # remove_at(""kalk"", 0)
    out = ""alk""
    >>> remove_at(""kalk"", -1)
    # remove_at(""kalk"", -1)
    out = ""kal""
    >>> remove_at(0..9, 5)
    # remove_at(0..9, 5)
    out = [0, 1, 2, 3, 4, 6, 7, 8, 9]
    >>> remove_at(0..9, -1)
    # remove_at(0..9, -1)
    out = [0, 1, 2, 3, 4, 5, 6, 7, 8]
    >>> remove_at(asbytes(0x04030201), 1)
    # remove_at(asbytes(67305985), 1)
    out = bytebuffer([1, 3, 4])
";
            }
            {
                var descriptor = Descriptors["contains"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Checks if an object (string, list, vector types, bytebuffer...) is containing the specified value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"The list to search into.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The value to search into the list.")  { IsOptional = false });
                descriptor.Returns = @"true if value was found in the list input; otherwise false.";
                descriptor.Example = @"    >>> contains(""kalk"", ""l"")
    # contains(""kalk"", ""l"")
    out = true
    >>> contains(""kalk"", ""e"")
    # contains(""kalk"", ""e"")
    out = false
    >>> contains([1,2,3,4,5], 3)
    # contains([1,2,3,4,5], 3)
    out = true
    >>> contains([1,2,3,4,5], 6)
    # contains([1,2,3,4,5], 6)
    out = false
    >>> contains(float4(1,2,3,4), 3)
    # contains(float4(1, 2, 3, 4), 3)
    out = true
    >>> contains(float4(1,2,3,4), 6)
    # contains(float4(1, 2, 3, 4), 6)
    out = false
";
            }
            {
                var descriptor = Descriptors["replace"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Replaces in an object (string, list, vector types, bytebuffer...) an item of the specified value by another value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"The list to search into to replace an element.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The item to replace.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("by", @"The value to replace with.")  { IsOptional = false });
                descriptor.Returns = @"The modified object.";
                descriptor.Example = @"    >>> replace(""kalk"", ""k"", ""woo"")
    # replace(""kalk"", ""k"", ""woo"")
    out = ""wooalwoo""
    >>> replace([1,2,3,4], 3, 5)
    # replace([1,2,3,4], 3, 5)
    out = [1, 2, 5, 4]
    >>> replace(float4(1,2,3,4), 3, 5)
    # replace(float4(1, 2, 3, 4), 3, 5)
    out = float4(1, 2, 5, 4)
";
            }
            {
                var descriptor = Descriptors["slice"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Creates a slice of an object (string, list, vector types, bytebuffer...) starting at the specified index and with the specified length;";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("list", @"The object to create a slice from.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("index", @"The index into the object.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("length", @"The optional length of the slice. If the length is not defined, the length will start from index with the remaining elements.")  { IsOptional = true });
                descriptor.Returns = @"A slice of the input object.";
                descriptor.Remarks = @"The index is adjusted at the modulo of the specified length of the input object.
    If the index is < 0, then the index starts from the end of the input object length. A value of -1 for the index would take a slice with the only the last element.";
                descriptor.Example = @"    >>> slice(""kalk"", 1)
    # slice(""kalk"", 1)
    out = ""alk""
    >>> slice(""kalk"", -2)
    # slice(""kalk"", -2)
    out = ""lk""
    >>> slice(""kalk"", 1, 2)
    # slice(""kalk"", 1, 2)
    out = ""al""
    >>> slice([1,2,3,4], 1)
    # slice([1,2,3,4], 1)
    out = [2, 3, 4]
    >>> slice([1,2,3,4], -1)
    # slice([1,2,3,4], -1)
    out = [4]
    >>> slice([1,2,3,4], -1, 3) # length is bigger than expected, no errors
    # slice([1,2,3,4], -1, 3) # length is bigger than expected, no errors
    out = [4]
    >>> slice(asbytes(0x04030201), 1, 2)
    # slice(asbytes(67305985), 1, 2)
    out = slice(bytebuffer([2, 3]), 1, 2)
";
            }
            {
                var descriptor = Descriptors["lines"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Extract lines from the specified string.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("text", @"A string to extract lines from.")  { IsOptional = false });
                descriptor.Returns = @"Lines extracted from the input string.";
                descriptor.Example = @"    >>> lines(""k\na\nl\nk"")
    # lines(""k\na\nl\nk"")
    out = [""k"", ""a"", ""l"", ""k""]
";
            }
            {
                var descriptor = Descriptors["colors"];
                descriptor.Category = "Misc Functions";
                descriptor.Description = @"Display or returns the known CSS colors.";
                descriptor.IsCommand = false;
                descriptor.Returns = @"Prints known CSS colors or return a list if this function is used in an expression.";
                descriptor.Example = @"    >>> colors[0]
    # colors[0]
    out = rgb(240, 248, 255) ## F0F8FF AliceBlue ##
    >>> mycolor = colors[""AliceBlue""]; mycolor.name
    # mycolor = colors[""AliceBlue""]; mycolor.name
    mycolor = rgb(240, 248, 255) ## F0F8FF AliceBlue ##
    out = ""AliceBlue""
";
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class StringModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("escape", (Func<string, string>)StringEscape);
            RegisterFunction("capitalize", (Func<string, string>)StringCapitalize);
            RegisterFunction("capitalize_words", (Func<string, string>)StringCapitalizeWords);
            RegisterFunction("downcase", (Func<string, string>)StringDowncase);
            RegisterFunction("upcase", (Func<string, string>)StringUpcase);
            RegisterFunction("endswith", (Func<string, string, Kalk.Core.KalkBool>)StringEndsWith);
            RegisterFunction("handleize", (Func<string, string>)StringHandleize);
            RegisterFunction("lstrip", (Func<string, string>)StringLeftStrip);
            RegisterFunction("pluralize", (Func<int, string, string, string>)StringPluralize);
            RegisterFunction("rstrip", (Func<string, string>)StringRightStrip);
            RegisterFunction("split", (Func<string, string, System.Collections.IEnumerable>)StringSplit);
            RegisterFunction("startswith", (Func<string, string, Kalk.Core.KalkBool>)StringStartsWith);
            RegisterFunction("strip", (Func<string, string>)StringStrip);
            RegisterFunction("strip_newlines", (Func<string, string>)StringStripNewlines);
            RegisterFunction("pad_left", (Func<string, int, string>)StringPadLeft);
            RegisterFunction("pad_right", (Func<string, int, string>)StringPadRight);
            RegisterFunction("regex_escape", (Func<string, string>)RegexEscape);
            RegisterFunction("regex_match", (Func<string, string, string, Scriban.Runtime.ScriptArray>)RegexMatch);
            RegisterFunction("regex_matches", (Func<string, string, string, Scriban.Runtime.ScriptArray>)RegexMatches);
            RegisterFunction("regex_replace", (Func<string, string, string, string, string>)RegexReplace);
            RegisterFunction("regex_split", (Func<string, string, string, Scriban.Runtime.ScriptArray>)RegexSplit);
            RegisterFunction("regex_unescape", (Func<string, string>)RegexUnescape);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["escape"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["capitalize"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["capitalize_words"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["downcase"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["upcase"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["endswith"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["handleize"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["lstrip"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pluralize"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["rstrip"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["split"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["startswith"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["strip"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["strip_newlines"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pad_left"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pad_right"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_escape"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_match"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_matches"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_replace"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_split"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["regex_unescape"];
                descriptor.Category = "Text Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class VectorModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("length", (Func<object, object>)Length);
            RegisterFunction("normalize", (Func<object, object>)Normalize);
            RegisterFunction("dot", (Func<object, object, object>)Dot);
            RegisterFunction("cross", (Func<Kalk.Core.KalkVector, Kalk.Core.KalkVector, object>)Cross);
            RegisterFunction("byte", (Func<object, byte>)CreateByte);
            RegisterFunction("sbyte", (Func<object, sbyte>)CreateSByte);
            RegisterFunction("short", (Func<object, short>)CreateShort);
            RegisterFunction("ushort", (Func<object, ushort>)CreateUShort);
            RegisterFunction("uint", (Func<object, uint>)CreateUInt);
            RegisterFunction("int", (Func<object, int>)CreateInt);
            RegisterFunction("ulong", (Func<object, ulong>)CreateULong);
            RegisterFunction("long", (Func<object, long>)CreateLong);
            RegisterFunction("bool", (Func<object, Kalk.Core.KalkBool>)CreateBool);
            RegisterFunction("float", (Func<object, float>)CreateFloat);
            RegisterFunction("double", (Func<object, double>)CreateDouble);
            RegisterFunction("byte16", (Func<object[], Kalk.Core.KalkVector<byte>>)CreateByte16);
            RegisterFunction("byte32", (Func<object[], Kalk.Core.KalkVector<byte>>)CreateByte32);
            RegisterFunction("byte64", (Func<object[], Kalk.Core.KalkVector<byte>>)CreateByte64);
            RegisterFunction("sbyte16", (Func<object[], Kalk.Core.KalkVector<sbyte>>)CreateSByte16);
            RegisterFunction("sbyte32", (Func<object[], Kalk.Core.KalkVector<sbyte>>)CreateSByte32);
            RegisterFunction("sbyte64", (Func<object[], Kalk.Core.KalkVector<sbyte>>)CreateSByte64);
            RegisterFunction("short2", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort2);
            RegisterFunction("short4", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort4);
            RegisterFunction("short8", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort8);
            RegisterFunction("short16", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort16);
            RegisterFunction("short32", (Func<object[], Kalk.Core.KalkVector<short>>)CreateShort32);
            RegisterFunction("ushort2", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort2);
            RegisterFunction("ushort4", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort4);
            RegisterFunction("ushort8", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort8);
            RegisterFunction("ushort16", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort16);
            RegisterFunction("ushort32", (Func<object[], Kalk.Core.KalkVector<ushort>>)CreateUShort32);
            RegisterFunction("int2", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt2);
            RegisterFunction("int3", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt3);
            RegisterFunction("int4", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt4);
            RegisterFunction("int8", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt8);
            RegisterFunction("int16", (Func<object[], Kalk.Core.KalkVector<int>>)CreateInt16);
            RegisterFunction("uint2", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt2);
            RegisterFunction("uint3", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt3);
            RegisterFunction("uint4", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt4);
            RegisterFunction("uint8", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt8);
            RegisterFunction("uint16", (Func<object[], Kalk.Core.KalkVector<uint>>)CreateUInt16);
            RegisterFunction("long2", (Func<object[], Kalk.Core.KalkVector<long>>)CreateLong2);
            RegisterFunction("long3", (Func<object[], Kalk.Core.KalkVector<long>>)CreateLong3);
            RegisterFunction("long4", (Func<object[], Kalk.Core.KalkVector<long>>)CreateLong4);
            RegisterFunction("long8", (Func<object[], Kalk.Core.KalkVector<long>>)CreateLong8);
            RegisterFunction("ulong2", (Func<object[], Kalk.Core.KalkVector<ulong>>)CreateULong2);
            RegisterFunction("ulong3", (Func<object[], Kalk.Core.KalkVector<ulong>>)CreateULong3);
            RegisterFunction("ulong4", (Func<object[], Kalk.Core.KalkVector<ulong>>)CreateULong4);
            RegisterFunction("ulong8", (Func<object[], Kalk.Core.KalkVector<ulong>>)CreateULong8);
            RegisterFunction("bool2", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool2);
            RegisterFunction("bool3", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool3);
            RegisterFunction("bool4", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool4);
            RegisterFunction("bool8", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool8);
            RegisterFunction("bool16", (Func<object[], Kalk.Core.KalkVector<Kalk.Core.KalkBool>>)CreateBool16);
            RegisterFunction("float2", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat2);
            RegisterFunction("float3", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat3);
            RegisterFunction("float4", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat4);
            RegisterFunction("float8", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat8);
            RegisterFunction("float16", (Func<object[], Kalk.Core.KalkVector<float>>)CreateFloat16);
            RegisterFunction("double2", (Func<object[], Kalk.Core.KalkVector<double>>)CreateDouble2);
            RegisterFunction("double3", (Func<object[], Kalk.Core.KalkVector<double>>)CreateDouble3);
            RegisterFunction("double4", (Func<object[], Kalk.Core.KalkVector<double>>)CreateDouble4);
            RegisterFunction("double8", (Func<object[], Kalk.Core.KalkVector<double>>)CreateDouble8);
            RegisterFunction("vector", (Func<Scriban.Syntax.ScriptVariable, int, object[], object>)CreateVector);
            RegisterFunction("rgb", (Func<object[], Kalk.Core.KalkColorRgb>)CreateRgb);
            RegisterFunction("rgba", (Func<object[], Kalk.Core.KalkColorRgba>)CreateRgba);
            RegisterFunction("bool2x2", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool2x2);
            RegisterFunction("bool2x3", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool2x3);
            RegisterFunction("bool2x4", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool2x4);
            RegisterFunction("bool3x2", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool3x2);
            RegisterFunction("bool3x3", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool3x3);
            RegisterFunction("bool3x4", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool3x4);
            RegisterFunction("bool4x2", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool4x2);
            RegisterFunction("bool4x3", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool4x3);
            RegisterFunction("bool4x4", (Func<object[], Kalk.Core.KalkMatrix<Kalk.Core.KalkBool>>)CreateBool4x4);
            RegisterFunction("int2x2", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt2x2);
            RegisterFunction("int2x3", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt2x3);
            RegisterFunction("int2x4", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt2x4);
            RegisterFunction("int3x2", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt3x2);
            RegisterFunction("int3x3", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt3x3);
            RegisterFunction("int3x4", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt3x4);
            RegisterFunction("int4x2", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt4x2);
            RegisterFunction("int4x3", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt4x3);
            RegisterFunction("int4x4", (Func<object[], Kalk.Core.KalkMatrix<int>>)CreateInt4x4);
            RegisterFunction("float2x2", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat2x2);
            RegisterFunction("float2x3", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat2x3);
            RegisterFunction("float2x4", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat2x4);
            RegisterFunction("float3x2", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat3x2);
            RegisterFunction("float3x3", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat3x3);
            RegisterFunction("float3x4", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat3x4);
            RegisterFunction("float4x2", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat4x2);
            RegisterFunction("float4x3", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat4x3);
            RegisterFunction("float4x4", (Func<object[], Kalk.Core.KalkMatrix<float>>)CreateFloat4x4);
            RegisterFunction("double2x2", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble2x2);
            RegisterFunction("double2x3", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble2x3);
            RegisterFunction("double2x4", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble2x4);
            RegisterFunction("double3x2", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble3x2);
            RegisterFunction("double3x3", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble3x3);
            RegisterFunction("double3x4", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble3x4);
            RegisterFunction("double4x2", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble4x2);
            RegisterFunction("double4x3", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble4x3);
            RegisterFunction("double4x4", (Func<object[], Kalk.Core.KalkMatrix<double>>)CreateDouble4x4);
            RegisterFunction("transpose", (Func<Kalk.Core.KalkMatrix, Kalk.Core.KalkMatrix>)Transpose);
            RegisterFunction("identity", (Func<Kalk.Core.KalkMatrix, Kalk.Core.KalkMatrix>)Identity);
            RegisterFunction("determinant", (Func<Kalk.Core.KalkMatrix, object>)Determinant);
            RegisterFunction("inverse", (Func<Kalk.Core.KalkMatrix, Kalk.Core.KalkMatrix>)Inverse);
            RegisterFunction("diag", (Func<object, object>)Diagonal);
            RegisterFunction("matrix", (Func<Scriban.Syntax.ScriptVariable, int, int, object[], object>)CreateMatrix);
            RegisterFunction("row", (Func<Kalk.Core.KalkMatrix, int, Kalk.Core.KalkVector>)GetRow);
            RegisterFunction("col", (Func<Kalk.Core.KalkMatrix, int, Kalk.Core.KalkVector>)GetColumn);
            RegisterFunction("mul", (Func<object, object, object>)Multiply);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["length"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"Returns the length of the specified floating-point vector.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The specified floating-point vector.")  { IsOptional = false });
                descriptor.Returns = @"A floating-point scalar that represents the length of the x parameter.";
                descriptor.Example = @"    >>> length float2(1, 2)
    # length(float2(1, 2))
    out = 2.23606797749979
    >>> length -5
    # length(-5)
    out = 5
";
            }
            {
                var descriptor = Descriptors["normalize"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"Normalizes the specified floating-point vector according to x / length(x).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"he specified floating-point vector.")  { IsOptional = false });
                descriptor.Returns = @"The normalized x parameter. If the length of the x parameter is 0, the result is indefinite.";
                descriptor.Example = @"    >>> normalize float2(1,2)
    # normalize(float2(1, 2))
    out = float2(0.4472136, 0.8944272)
";
            }
            {
                var descriptor = Descriptors["dot"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"Returns the dot product of two vectors.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The first vector.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The second vector.")  { IsOptional = false });
                descriptor.Returns = @"The dot product of the x parameter and the y parameter.";
                descriptor.Example = @"    >>> dot(float3(1,2,3), float3(4,5,6))
    # dot(float3(1, 2, 3), float3(4, 5, 6))
    out = 32
    >>> dot(float3(1,2,3), 4)
    # dot(float3(1, 2, 3), 4)
    out = 24
    >>> dot(4, float3(1,2,3))
    # dot(4, float3(1, 2, 3))
    out = 24
    >>> dot(5,6)
    # dot(5, 6)
    out = 30
";
            }
            {
                var descriptor = Descriptors["cross"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"Returns the cross product of two floating-point, 3D vectors.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("x", @"The first floating-point, 3D vector.")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("y", @"The second floating-point, 3D vector.")  { IsOptional = false });
                descriptor.Returns = @"The cross product of the x parameter and the y parameter.";
                descriptor.Example = @"    >>> cross(float3(1,2,3), float3(4,5,6))
    # cross(float3(1, 2, 3), float3(4, 5, 6))
    out = float3(-3, 6, -3)
    >>> cross(float3(1,0,0), float3(0,1,0))
    # cross(float3(1, 0, 0), float3(0, 1, 0))
    out = float3(0, 0, 1)
    >>> cross(float3(0,0,1), float3(0,1,0))
    # cross(float3(0, 0, 1), float3(0, 1, 0))
    out = float3(-1, 0, 0)
";
            }
            {
                var descriptor = Descriptors["byte"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates an unsigned byte value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"An unsigned byte value";
                descriptor.Example = @"    >>> byte
    # byte
    out = 0
    >>> byte 0
    # byte(0)
    out = 0
    >>> byte 255
    # byte(255)
    out = 255
    >>> byte 256
    Unable to convert type `int` to `byte`
";
            }
            {
                var descriptor = Descriptors["sbyte"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a signed-byte value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A signed-byte value";
                descriptor.Example = @"    >>> sbyte
    # sbyte
    out = 0
    >>> sbyte 0
    # sbyte(0)
    out = 0
    >>> sbyte 127
    # sbyte(127)
    out = 127
    >>> sbyte -128
    # sbyte(-128)
    out = -128
    >>> sbyte 128
    Unable to convert type `int` to `sbyte`
";
            }
            {
                var descriptor = Descriptors["short"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates a signed-short (16-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"A signed-short (16-bit) value";
                descriptor.Example = @"    >>> short
    # short
    out = 0
    >>> short 0
    # short(0)
    out = 0
    >>> short 32767
    # short(32767)
    out = 32767
    >>> short -32768
    # short(-32768)
    out = -32768
    >>> short 32768
    Unable to convert type `int` to `short`
";
            }
            {
                var descriptor = Descriptors["ushort"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"Creates an unsigned short (16-bit) value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("value", @"The input value.")  { IsOptional = true });
                descriptor.Returns = @"An unsigned short (16-bit) value";
                descriptor.Example = @"    >>> ushort
    # ushort
    out = 0
    >>> ushort 0
    # ushort(0)
    out = 0
    >>> ushort 65535
    # ushort(65535)
    out = 65535
    >>> ushort 65536
    Unable to convert type `int` to `ushort`
";
            }
            {
                var descriptor = Descriptors["uint"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double"];
                descriptor.Category = "Type Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["byte16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["byte32"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["byte64"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["sbyte16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["sbyte32"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["sbyte64"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["short32"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ushort32"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["uint16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["long8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["ulong8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float16"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double2"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double3"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double4"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double8"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["vector"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["rgb"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["rgba"];
                descriptor.Category = "Type Vector Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool2x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 2 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool2x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 3 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool2x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 4 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool3x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 2 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool3x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 3 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool3x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 4 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool4x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 2 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool4x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 3 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bool4x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 4 (columns) matrix of bool.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int2x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 2 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int2x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 3 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int2x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 4 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int3x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 2 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int3x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 3 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int3x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 4 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int4x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 2 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int4x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 3 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["int4x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 4 (columns) matrix of int.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float2x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 2 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float2x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 3 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float2x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 4 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float3x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 2 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float3x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 3 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float3x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 4 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float4x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 2 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float4x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 3 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["float4x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 4 (columns) matrix of float.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double2x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 2 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double2x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 3 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double2x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 2 (rows) x 4 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double3x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 2 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double3x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 3 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double3x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 3 (rows) x 4 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double4x2"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 2 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double4x3"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 3 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["double4x4"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"Creates a 4 (rows) x 4 (columns) matrix of double.";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["transpose"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["identity"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["determinant"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["inverse"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["diag"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["matrix"];
                descriptor.Category = "Type Matrix Constructors";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["row"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["col"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mul"];
                descriptor.Category = "Math Vector/Matrix Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules
{
    public partial class WebModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("url_encode", (Func<string, string>)UrlEncode);
            RegisterFunction("url_decode", (Func<string, string>)UrlDecode);
            RegisterFunction("url_escape", (Func<string, string>)UrlEscape);
            RegisterFunction("html_encode", (Func<string, string>)HtmlEncode);
            RegisterFunction("html_decode", (Func<string, string>)HtmlDecode);
            RegisterFunction("html_strip", (Func<string, string>)HtmlStrip);
            RegisterFunction("wget", (Func<string, object>)WebGet);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["url_encode"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["url_decode"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["url_escape"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["html_encode"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["html_decode"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["html_strip"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["wget"];
                descriptor.Category = "Web & Html Functions";
                descriptor.Description = @"";
                descriptor.IsCommand = false;
            }
        }        
    }
}
