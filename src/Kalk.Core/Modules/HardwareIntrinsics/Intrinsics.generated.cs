//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Date: 24 May 2020
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AesIntrinsicsModule
    {
        /// <summary>
        /// __m128i _mm_aesdec_si128 (__m128i a, __m128i RoundKey) AESDEC xmm, xmm/m128
        /// </summary>
        public object mm_aesdec_si128(object value, object roundKey) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, roundKey, System.Runtime.Intrinsics.X86.Aes.Decrypt);

        /// <summary>
        /// __m128i _mm_aesdeclast_si128 (__m128i a, __m128i RoundKey) AESDECLAST xmm, xmm/m128
        /// </summary>
        public object mm_aesdeclast_si128(object value, object roundKey) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, roundKey, System.Runtime.Intrinsics.X86.Aes.DecryptLast);

        /// <summary>
        /// __m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey) AESENC xmm, xmm/m128
        /// </summary>
        public object mm_aesenc_si128(object value, object roundKey) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, roundKey, System.Runtime.Intrinsics.X86.Aes.Encrypt);

        /// <summary>
        /// __m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey) AESENCLAST xmm, xmm/m128
        /// </summary>
        public object mm_aesenclast_si128(object value, object roundKey) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, roundKey, System.Runtime.Intrinsics.X86.Aes.EncryptLast);

        /// <summary>
        /// __m128i _mm_aesimc_si128 (__m128i a) AESIMC xmm, xmm/m128
        /// </summary>
        public object mm_aesimc_si128(object value) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, System.Runtime.Intrinsics.X86.Aes.InverseMixColumns);

        /// <summary>
        /// __m128i _mm_aeskeygenassist_si128 (__m128i a, const int imm8) AESKEYGENASSIST xmm, xmm/m128, imm8
        /// </summary>
        public object mm_aeskeygenassist_si128(object value, byte control) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, byte, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, control, System.Runtime.Intrinsics.X86.Aes.KeygenAssist);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AvxIntrinsicsModule
    {
        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" based on the comparison operand specified by "imm8", and store the results in "dst".
        /// </summary>
        public object mm_cmp_ps(object a, object b, System.Runtime.Intrinsics.X86.FloatComparisonMode imm8) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, System.Runtime.Intrinsics.X86.FloatComparisonMode, System.Runtime.Intrinsics.X86.FloatComparisonMode, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx.Compare);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" based on the comparison operand specified by "imm8", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmp_sd(object a, object b, System.Runtime.Intrinsics.X86.FloatComparisonMode imm8) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, System.Runtime.Intrinsics.X86.FloatComparisonMode, System.Runtime.Intrinsics.X86.FloatComparisonMode, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx.CompareScalar);

        /// <summary>
        /// Shuffle single-precision (32-bit) floating-point elements in "a" using the control in "imm8", and store the results in "dst".
        /// </summary>
        public object mm_permute_ps(object a, byte imm8) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, byte, byte, float, System.Runtime.Intrinsics.Vector128<float>>(a, imm8, System.Runtime.Intrinsics.X86.Avx.Permute);

        /// <summary>
        /// Shuffle single-precision (32-bit) floating-point elements in "a" using the control in "b", and store the results in "dst".
        /// </summary>
        public object mm_permutevar_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, int, System.Runtime.Intrinsics.Vector128<int>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.PermuteVar);

        /// <summary>
        /// Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return the "CF" value.
        /// </summary>
        public bool mm_testc_ps(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Avx.TestC);

        /// <summary>
        /// Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return 1 if both the "ZF" and "CF" values are zero, otherwise return 0.
        /// </summary>
        public bool mm_testnzc_ps(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Avx.TestNotZAndNotC);

        /// <summary>
        /// Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in "a" and "b", producing an intermediate 128-bit value, and set "ZF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", producing an intermediate value, and set "CF" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set "CF" to 0. Return the "ZF" value.
        /// </summary>
        public bool mm_testz_ps(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Avx.TestZ);

        /// <summary>
        /// Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_add_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Add);

        /// <summary>
        /// Alternatively add and subtract packed single-precision (32-bit) floating-point elements in "a" to/from packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm256_addsub_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.AddSubtract);

        /// <summary>
        /// Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_and_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.And);

        /// <summary>
        /// Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in "a" and then AND with "b", and store the results in "dst".
        /// </summary>
        public object mm256_andnot_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.AndNot);

        /// <summary>
        /// Blend packed single-precision (32-bit) floating-point elements from "a" and "b" using control mask "imm8", and store the results in "dst".
        /// </summary>
        public object mm256_blend_ps(object a, object b, byte imm8) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, byte, byte, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx.Blend);

        /// <summary>
        /// Blend packed single-precision (32-bit) floating-point elements from "a" and "b" using "mask", and store the results in "dst".
        /// </summary>
        public object mm256_blendv_ps(object a, object b, object mask) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, mask, System.Runtime.Intrinsics.X86.Avx.BlendVariable);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" up to an integer value, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm256_ceil_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.Ceiling);

        /// <summary>
        /// Convert packed 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".
        /// </summary>
        public object mm256_cvtepi32_ps(object a) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector256<int>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Single);

        /// <summary>
        /// Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst".
        /// </summary>
        public object mm256_cvtpd_epi32(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector256<double>, int, System.Runtime.Intrinsics.Vector128<int>>(a, System.Runtime.Intrinsics.X86.Avx.ConvertToVector128Int32);

        /// <summary>
        /// Convert packed double-precision (64-bit) floating-point elements in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".
        /// </summary>
        public object mm256_cvtpd_ps(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector256<double>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Avx.ConvertToVector128Single);

        /// <summary>
        /// Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst".
        /// </summary>
        public object mm256_cvtps_epi32(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, int, System.Runtime.Intrinsics.Vector256<int>>(a, System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Int32);

        /// <summary>
        /// Convert packed single-precision (32-bit) floating-point elements in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst".
        /// </summary>
        public object mm256_cvtps_pd(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, double, System.Runtime.Intrinsics.Vector256<double>>(a, System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Double);

        /// <summary>
        /// Convert packed double-precision (64-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst".
        /// </summary>
        public object mm256_cvttpd_epi32(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector256<double>, int, System.Runtime.Intrinsics.Vector128<int>>(a, System.Runtime.Intrinsics.X86.Avx.ConvertToVector128Int32WithTruncation);

        /// <summary>
        /// Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst".
        /// </summary>
        public object mm256_cvttps_epi32(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, int, System.Runtime.Intrinsics.Vector256<int>>(a, System.Runtime.Intrinsics.X86.Avx.ConvertToVector256Int32WithTruncation);

        /// <summary>
        /// Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm256_div_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Divide);

        /// <summary>
        /// Conditionally multiply the packed single-precision (32-bit) floating-point elements in "a" and "b" using the high 4 bits in "imm8", sum the four products, and conditionally store the sum in "dst" using the low 4 bits of "imm8".
        /// </summary>
        public object mm256_dp_ps(object a, object b, byte imm8) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, byte, byte, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx.DotProduct);

        /// <summary>
        /// Extract 128 bits (composed of integer data) from "a", selected with "imm8", and store the result in "dst".
        /// </summary>
        public object mm256_extractf128_si256(object a, byte imm8) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector256<byte>, byte, byte, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, imm8, System.Runtime.Intrinsics.X86.Avx.ExtractVector128);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" down to an integer value, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm256_floor_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.Floor);

        /// <summary>
        /// Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in "a" and "b", and pack the results in "dst".
        /// </summary>
        public object mm256_hadd_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.HorizontalAdd);

        /// <summary>
        /// Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in "a" and "b", and pack the results in "dst".
        /// </summary>
        public object mm256_hsub_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.HorizontalSubtract);

        /// <summary>
        /// Copy "a" to "dst", then insert 128 bits from "b" into "dst" at the location specified by "imm8".
        /// </summary>
        public object mm256_insertf128_si256(object a, object b, byte imm8) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector256<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, byte, byte, System.Runtime.Intrinsics.Vector256<byte>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx.InsertVector128);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm256_max_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Max);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm256_min_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Min);

        /// <summary>
        /// Duplicate odd-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
        /// </summary>
        public object mm256_movehdup_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.DuplicateOddIndexed);

        /// <summary>
        /// Duplicate even-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
        /// </summary>
        public object mm256_moveldup_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.DuplicateEvenIndexed);

        /// <summary>
        /// Set each bit of mask "dst" based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in "a".
        /// </summary>
        public int mm256_movemask_ps(object a) => (int)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, int, int>(a, System.Runtime.Intrinsics.X86.Avx.MoveMask);

        /// <summary>
        /// Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_mul_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Multiply);

        /// <summary>
        /// Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_or_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Or);

        /// <summary>
        /// Shuffle 128-bits (composed of integer data) selected by "imm8" from "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_permute2f128_si256(object a, object b, byte imm8) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector256<byte>, byte, System.Runtime.Intrinsics.Vector256<byte>, byte, byte, byte, System.Runtime.Intrinsics.Vector256<byte>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx.Permute2x128);

        /// <summary>
        /// Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm256_rcp_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.Reciprocal);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" using the "rounding" parameter, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm256_round_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.RoundCurrentDirection);

        /// <summary>
        /// Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm256_rsqrt_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.ReciprocalSqrt);

        /// <summary>
        /// Shuffle single-precision (32-bit) floating-point elements in "a" within 128-bit lanes using the control in "imm8", and store the results in "dst".
        /// </summary>
        public object mm256_shuffle_ps(object a, object b, byte imm8) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, byte, byte, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx.Shuffle);

        /// <summary>
        /// Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm256_sqrt_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.Sqrt);

        /// <summary>
        /// Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm256_sub_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Subtract);

        /// <summary>
        /// Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_unpackhi_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.UnpackHigh);

        /// <summary>
        /// Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_unpacklo_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.UnpackLow);

        /// <summary>
        /// Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_xor_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Xor);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Avx2IntrinsicsModule
    {
        /// <summary>
        /// Blend packed 32-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst".
        /// </summary>
        public object mm_blend_epi32(object a, object b, byte imm8) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector128<int>, int, System.Runtime.Intrinsics.Vector128<int>, byte, byte, int, System.Runtime.Intrinsics.Vector128<int>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx2.Blend);

        /// <summary>
        /// Broadcast the low packed 8-bit integer from "a" to all elements of "dst".
        /// </summary>
        public object mm_broadcastb_epi8(object a) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128);

        /// <summary>
        /// Compute the absolute value of packed 8-bit integers in "a", and store the unsigned results in "dst".
        /// </summary>
        public object mm256_abs_epi8(object a) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, byte, System.Runtime.Intrinsics.Vector256<byte>>(a, System.Runtime.Intrinsics.X86.Avx2.Abs);

        /// <summary>
        /// Add packed 8-bit integers in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_add_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Add);

        /// <summary>
        /// Add packed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".
        /// </summary>
        public object mm256_adds_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.AddSaturate);

        /// <summary>
        /// Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "count" bytes, and store the low 16 bytes in "dst".
        /// </summary>
        public object mm256_alignr_epi8(object a, object b, byte count) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, count, System.Runtime.Intrinsics.X86.Avx2.AlignRight);

        /// <summary>
        /// Compute the bitwise AND of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm256_and_si256(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.And);

        /// <summary>
        /// Compute the bitwise NOT of 256 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".
        /// </summary>
        public object mm256_andnot_si256(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.AndNot);

        /// <summary>
        /// Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_avg_epu8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector256<byte>, byte, System.Runtime.Intrinsics.Vector256<byte>, byte, System.Runtime.Intrinsics.Vector256<byte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Average);

        /// <summary>
        /// Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".
        /// </summary>
        public object mm256_blendv_epi8(object a, object b, object mask) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, mask, System.Runtime.Intrinsics.X86.Avx2.BlendVariable);

        /// <summary>
        /// Broadcast the low packed 8-bit integer from "a" to all elements of "dst".
        /// </summary>
        public object mm256_broadcastb_epi8(object a) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector256<byte>>(a, System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector256);

        /// <summary>
        /// Shift 128-bit lanes in "a" left by "imm8" bytes while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm256_bslli_epi128(object a, byte imm8) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, imm8, System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical128BitLane);

        /// <summary>
        /// Shift 128-bit lanes in "a" right by "imm8" bytes while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm256_bsrli_epi128(object a, byte imm8) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, imm8, System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical128BitLane);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".
        /// </summary>
        public object mm256_cmpeq_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.CompareEqual);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".
        /// </summary>
        public object mm256_cmpgt_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.CompareGreaterThan);

        /// <summary>
        /// Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".
        /// </summary>
        public object mm256_cvtepi8_epi16(object a) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, short, System.Runtime.Intrinsics.Vector256<short>>(a, System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int16);

        /// <summary>
        /// Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".
        /// </summary>
        public object mm256_cvtepi8_epi32(object a) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, int, System.Runtime.Intrinsics.Vector256<int>>(a, System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int32);

        /// <summary>
        /// Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst".
        /// </summary>
        public object mm256_cvtepi8_epi64(object a) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, long, System.Runtime.Intrinsics.Vector256<long>>(a, System.Runtime.Intrinsics.X86.Avx2.ConvertToVector256Int64);

        /// <summary>
        /// Copy the lower 32-bit integer in "a" to "dst".
        /// </summary>
        public int mm256_cvtsi256_si32(object a) => (int)ProcessFunc<int, System.Runtime.Intrinsics.Vector256<int>, int, int>(a, System.Runtime.Intrinsics.X86.Avx2.ConvertToInt32);

        /// <summary>
        /// Extract 128 bits (composed of integer data) from "a", selected with "imm8", and store the result in "dst".
        /// </summary>
        public object mm256_extracti128_si256(object a, byte imm8) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, imm8, System.Runtime.Intrinsics.X86.Avx2.ExtractVector128);

        /// <summary>
        /// Horizontally add adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm256_hadd_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.HorizontalAdd);

        /// <summary>
        /// Horizontally add adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm256_hadds_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.HorizontalAddSaturate);

        /// <summary>
        /// Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm256_hsub_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.HorizontalSubtract);

        /// <summary>
        /// Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm256_hsubs_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.HorizontalSubtractSaturate);

        /// <summary>
        /// Copy "a" to "dst", then insert 128 bits (composed of integer data) from "b" into "dst" at the location specified by "imm8".
        /// </summary>
        public object mm256_inserti128_si256(object a, object b, byte imm8) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx2.InsertVector128);

        /// <summary>
        /// Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst".
        /// </summary>
        public object mm256_madd_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, int, System.Runtime.Intrinsics.Vector256<int>>(a, b, System.Runtime.Intrinsics.X86.Avx2.MultiplyAddAdjacent);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm256_max_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Max);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm256_min_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Min);

        /// <summary>
        /// Create mask from the most significant bit of each 8-bit element in "a", and store the result in "dst".
        /// </summary>
        public int mm256_movemask_epi8(object a) => (int)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, int, int>(a, System.Runtime.Intrinsics.X86.Avx2.MoveMask);

        /// <summary>
        /// Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst". 	Eight SADs are performed for each 128-bit lane using one quadruplet from "b" and eight quadruplets from "a". One quadruplet is selected from "b" starting at on the offset specified in "imm8". Eight quadruplets are formed from sequential 8-bit integers selected from "a" starting at the offset specified in "imm8".
        /// </summary>
        public object mm256_mpsadbw_epu8(object a, object b, byte imm8) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector256<byte>, byte, System.Runtime.Intrinsics.Vector256<byte>, byte, byte, ushort, System.Runtime.Intrinsics.Vector256<ushort>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx2.MultipleSumAbsoluteDifferences);

        /// <summary>
        /// Multiply the low 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst".
        /// </summary>
        public object mm256_mul_epi32(object a, object b) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector256<int>, int, System.Runtime.Intrinsics.Vector256<int>, long, System.Runtime.Intrinsics.Vector256<long>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Multiply);

        /// <summary>
        /// Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm256_mulhi_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.MultiplyHigh);

        /// <summary>
        /// Multiply packed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst".
        /// </summary>
        public object mm256_mulhrs_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.MultiplyHighRoundScale);

        /// <summary>
        /// Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm256_mullo_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.MultiplyLow);

        /// <summary>
        /// Compute the bitwise OR of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm256_or_si256(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Or);

        /// <summary>
        /// Convert packed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".
        /// </summary>
        public object mm256_packs_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.PackSignedSaturate);

        /// <summary>
        /// Convert packed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".
        /// </summary>
        public object mm256_packus_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, byte, System.Runtime.Intrinsics.Vector256<byte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.PackUnsignedSaturate);

        /// <summary>
        /// Shuffle 128-bits (composed of integer data) selected by "imm8" from "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_permute2x128_si256(object a, object b, byte imm8) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, imm8, System.Runtime.Intrinsics.X86.Avx2.Permute2x128);

        /// <summary>
        /// Shuffle 64-bit integers in "a" across lanes using the control in "imm8", and store the results in "dst".
        /// </summary>
        public object mm256_permute4x64_epi64(object a, byte imm8) => (object)ProcessFunc<long, System.Runtime.Intrinsics.Vector256<long>, byte, byte, long, System.Runtime.Intrinsics.Vector256<long>>(a, imm8, System.Runtime.Intrinsics.X86.Avx2.Permute4x64);

        /// <summary>
        /// Shuffle 32-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst".
        /// </summary>
        public object mm256_permutevar8x32_epi32(object a, object idx) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector256<int>, int, System.Runtime.Intrinsics.Vector256<int>, int, System.Runtime.Intrinsics.Vector256<int>>(a, idx, System.Runtime.Intrinsics.X86.Avx2.PermuteVar8x32);

        /// <summary>
        /// Compute the absolute differences of packed unsigned 8-bit integers in "a" and "b", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in "dst".
        /// </summary>
        public object mm256_sad_epu8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector256<byte>, byte, System.Runtime.Intrinsics.Vector256<byte>, ushort, System.Runtime.Intrinsics.Vector256<ushort>>(a, b, System.Runtime.Intrinsics.X86.Avx2.SumAbsoluteDifferences);

        /// <summary>
        /// Shuffle 8-bit integers in "a" within 128-bit lanes according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".
        /// </summary>
        public object mm256_shuffle_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Shuffle);

        /// <summary>
        /// Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of "a" using the control in "imm8". Store the results in the high 64 bits of 128-bit lanes of "dst", with the low 64 bits of 128-bit lanes being copied from from "a" to "dst".
        /// </summary>
        public object mm256_shufflehi_epi16(object a, byte imm8) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, byte, byte, short, System.Runtime.Intrinsics.Vector256<short>>(a, imm8, System.Runtime.Intrinsics.X86.Avx2.ShuffleHigh);

        /// <summary>
        /// Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of "a" using the control in "imm8". Store the results in the low 64 bits of 128-bit lanes of "dst", with the high 64 bits of 128-bit lanes being copied from from "a" to "dst".
        /// </summary>
        public object mm256_shufflelo_epi16(object a, byte imm8) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, byte, byte, short, System.Runtime.Intrinsics.Vector256<short>>(a, imm8, System.Runtime.Intrinsics.X86.Avx2.ShuffleLow);

        /// <summary>
        /// Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.
        /// </summary>
        public object mm256_sign_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Sign);

        /// <summary>
        /// Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm256_sll_epi16(object a, object count) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, count, System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogical);

        /// <summary>
        /// Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm256_sllv_epi32(object a, object count) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector256<int>, uint, System.Runtime.Intrinsics.Vector256<uint>, int, System.Runtime.Intrinsics.Vector256<int>>(a, count, System.Runtime.Intrinsics.X86.Avx2.ShiftLeftLogicalVariable);

        /// <summary>
        /// Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".
        /// </summary>
        public object mm256_srav_epi32(object a, object count) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector256<int>, uint, System.Runtime.Intrinsics.Vector256<uint>, int, System.Runtime.Intrinsics.Vector256<int>>(a, count, System.Runtime.Intrinsics.X86.Avx2.ShiftRightArithmeticVariable);

        /// <summary>
        /// Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm256_srl_epi16(object a, object count) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, count, System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogical);

        /// <summary>
        /// Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm256_srlv_epi32(object a, object count) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector256<int>, uint, System.Runtime.Intrinsics.Vector256<uint>, int, System.Runtime.Intrinsics.Vector256<int>>(a, count, System.Runtime.Intrinsics.X86.Avx2.ShiftRightLogicalVariable);

        /// <summary>
        /// Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".
        /// </summary>
        public object mm256_sub_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Subtract);

        /// <summary>
        /// Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".
        /// </summary>
        public object mm256_subs_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.SubtractSaturate);

        /// <summary>
        /// Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_unpackhi_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.UnpackHigh);

        /// <summary>
        /// Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_unpacklo_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.UnpackLow);

        /// <summary>
        /// Compute the bitwise XOR of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm256_xor_si256(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Xor);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi1IntrinsicsModule
    {
        /// <summary>
        /// unsigned int _andn_u32 (unsigned int a, unsigned int b) ANDN r32a, r32b, reg/m32
        /// </summary>
        public uint andn_u32(uint left, uint right) => (uint)ProcessFunc<uint, uint, uint, uint, uint, uint>(left, right, System.Runtime.Intrinsics.X86.Bmi1.AndNot);

        /// <summary>
        /// unsigned int _bextr_u32 (unsigned int a, unsigned int start, unsigned int len) BEXTR r32a, reg/m32, r32b
        /// </summary>
        public uint bextr_u32(uint value, byte start, byte length) => (uint)ProcessFunc<uint, uint, byte, byte, byte, byte, uint, uint>(value, start, length, System.Runtime.Intrinsics.X86.Bmi1.BitFieldExtract);

        /// <summary>
        /// unsigned int _bextr2_u32 (unsigned int a, unsigned int control) BEXTR r32a, reg/m32, r32b
        /// </summary>
        public uint bextr2_u32(uint value, ushort control) => (uint)ProcessFunc<uint, uint, ushort, ushort, uint, uint>(value, control, System.Runtime.Intrinsics.X86.Bmi1.BitFieldExtract);

        /// <summary>
        /// unsigned int _blsi_u32 (unsigned int a) BLSI reg, reg/m32
        /// </summary>
        public uint blsi_u32(uint value) => (uint)ProcessFunc<uint, uint, uint, uint>(value, System.Runtime.Intrinsics.X86.Bmi1.ExtractLowestSetBit);

        /// <summary>
        /// unsigned int _blsmsk_u32 (unsigned int a) BLSMSK reg, reg/m32
        /// </summary>
        public uint blsmsk_u32(uint value) => (uint)ProcessFunc<uint, uint, uint, uint>(value, System.Runtime.Intrinsics.X86.Bmi1.GetMaskUpToLowestSetBit);

        /// <summary>
        /// unsigned int _blsr_u32 (unsigned int a) BLSR reg, reg/m32
        /// </summary>
        public uint blsr_u32(uint value) => (uint)ProcessFunc<uint, uint, uint, uint>(value, System.Runtime.Intrinsics.X86.Bmi1.ResetLowestSetBit);

        /// <summary>
        /// int _mm_tzcnt_32 (unsigned int a) TZCNT reg, reg/m32
        /// </summary>
        public uint mm_tzcnt_32(uint value) => (uint)ProcessFunc<uint, uint, uint, uint>(value, System.Runtime.Intrinsics.X86.Bmi1.TrailingZeroCount);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi1X64IntrinsicsModule
    {
        /// <summary>
        /// unsigned __int64 _andn_u64 (unsigned __int64 a, unsigned __int64 b) ANDN r64a, r64b, reg/m64
        /// </summary>
        public ulong andn_u64(ulong left, ulong right) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong, ulong, ulong>(left, right, System.Runtime.Intrinsics.X86.Bmi1.X64.AndNot);

        /// <summary>
        /// unsigned __int64 _bextr_u64 (unsigned __int64 a, unsigned int start, unsigned int len) BEXTR r64a, reg/m64, r64b
        /// </summary>
        public ulong bextr_u64(ulong value, byte start, byte length) => (ulong)ProcessFunc<ulong, ulong, byte, byte, byte, byte, ulong, ulong>(value, start, length, System.Runtime.Intrinsics.X86.Bmi1.X64.BitFieldExtract);

        /// <summary>
        /// unsigned __int64 _bextr2_u64 (unsigned __int64 a, unsigned __int64 control) BEXTR r64a, reg/m64, r64b
        /// </summary>
        public ulong bextr2_u64(ulong value, ushort control) => (ulong)ProcessFunc<ulong, ulong, ushort, ushort, ulong, ulong>(value, control, System.Runtime.Intrinsics.X86.Bmi1.X64.BitFieldExtract);

        /// <summary>
        /// unsigned __int64 _blsi_u64 (unsigned __int64 a) BLSI reg, reg/m64
        /// </summary>
        public ulong blsi_u64(ulong value) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong>(value, System.Runtime.Intrinsics.X86.Bmi1.X64.ExtractLowestSetBit);

        /// <summary>
        /// unsigned __int64 _blsmsk_u64 (unsigned __int64 a) BLSMSK reg, reg/m64
        /// </summary>
        public ulong blsmsk_u64(ulong value) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong>(value, System.Runtime.Intrinsics.X86.Bmi1.X64.GetMaskUpToLowestSetBit);

        /// <summary>
        /// unsigned __int64 _blsr_u64 (unsigned __int64 a) BLSR reg, reg/m64
        /// </summary>
        public ulong blsr_u64(ulong value) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong>(value, System.Runtime.Intrinsics.X86.Bmi1.X64.ResetLowestSetBit);

        /// <summary>
        /// __int64 _mm_tzcnt_64 (unsigned __int64 a) TZCNT reg, reg/m64
        /// </summary>
        public ulong mm_tzcnt_64(ulong value) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong>(value, System.Runtime.Intrinsics.X86.Bmi1.X64.TrailingZeroCount);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi2IntrinsicsModule
    {
        /// <summary>
        /// unsigned int _bzhi_u32 (unsigned int a, unsigned int index) BZHI r32a, reg/m32, r32b
        /// </summary>
        public uint bzhi_u32(uint value, uint index) => (uint)ProcessFunc<uint, uint, uint, uint, uint, uint>(value, index, System.Runtime.Intrinsics.X86.Bmi2.ZeroHighBits);

        /// <summary>
        /// unsigned int _mulx_u32 (unsigned int a, unsigned int b, unsigned int* hi) MULX r32a, r32b, reg/m32
        /// </summary>
        public uint mulx_u32(uint left, uint right) => (uint)ProcessFunc<uint, uint, uint, uint, uint, uint>(left, right, System.Runtime.Intrinsics.X86.Bmi2.MultiplyNoFlags);

        /// <summary>
        /// unsigned int _pdep_u32 (unsigned int a, unsigned int mask) PDEP r32a, r32b, reg/m32
        /// </summary>
        public uint pdep_u32(uint value, uint mask) => (uint)ProcessFunc<uint, uint, uint, uint, uint, uint>(value, mask, System.Runtime.Intrinsics.X86.Bmi2.ParallelBitDeposit);

        /// <summary>
        /// unsigned int _pext_u32 (unsigned int a, unsigned int mask) PEXT r32a, r32b, reg/m32
        /// </summary>
        public uint pext_u32(uint value, uint mask) => (uint)ProcessFunc<uint, uint, uint, uint, uint, uint>(value, mask, System.Runtime.Intrinsics.X86.Bmi2.ParallelBitExtract);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi2X64IntrinsicsModule
    {
        /// <summary>
        /// unsigned __int64 _bzhi_u64 (unsigned __int64 a, unsigned int index) BZHI r64a, reg/m32, r64b
        /// </summary>
        public ulong bzhi_u64(ulong value, ulong index) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong, ulong, ulong>(value, index, System.Runtime.Intrinsics.X86.Bmi2.X64.ZeroHighBits);

        /// <summary>
        /// unsigned __int64 _mulx_u64 (unsigned __int64 a, unsigned __int64 b, unsigned __int64* hi) MULX r64a, r64b, reg/m64
        /// </summary>
        public ulong mulx_u64(ulong left, ulong right) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong, ulong, ulong>(left, right, System.Runtime.Intrinsics.X86.Bmi2.X64.MultiplyNoFlags);

        /// <summary>
        /// unsigned __int64 _pdep_u64 (unsigned __int64 a, unsigned __int64 mask) PDEP r64a, r64b, reg/m64
        /// </summary>
        public ulong pdep_u64(ulong value, ulong mask) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong, ulong, ulong>(value, mask, System.Runtime.Intrinsics.X86.Bmi2.X64.ParallelBitDeposit);

        /// <summary>
        /// unsigned __int64 _pext_u64 (unsigned __int64 a, unsigned __int64 mask) PEXT r64a, r64b, reg/m64
        /// </summary>
        public ulong pext_u64(ulong value, ulong mask) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong, ulong, ulong>(value, mask, System.Runtime.Intrinsics.X86.Bmi2.X64.ParallelBitExtract);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class SseIntrinsicsModule
    {
        /// <summary>
        /// Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_add_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Add);

        /// <summary>
        /// Add the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_add_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.AddScalar);

        /// <summary>
        /// Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_and_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.And);

        /// <summary>
        /// Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in "a" and then AND with "b", and store the results in "dst".
        /// </summary>
        public object mm_andnot_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.AndNot);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for equality, and store the results in "dst".
        /// </summary>
        public object mm_cmpeq_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for equality, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpeq_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for greater-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpge_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for greater-than-or-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpge_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarGreaterThanOrEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpgt_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareGreaterThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for greater-than, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpgt_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarGreaterThan);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for less-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmple_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareLessThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for less-than-or-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmple_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarLessThanOrEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for less-than, and store the results in "dst".
        /// </summary>
        public object mm_cmplt_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareLessThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for less-than, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmplt_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarLessThan);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpneq_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpneq_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-greater-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpnge_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-greater-than-or-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpnge_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotGreaterThanOrEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpngt_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotGreaterThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-greater-than, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpngt_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotGreaterThan);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpnle_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotLessThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpnle_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotLessThanOrEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpnlt_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotLessThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpnlt_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotLessThan);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" to see if neither is NaN, and store the results in "dst".
        /// </summary>
        public object mm_cmpord_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareOrdered);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" to see if neither is NaN, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpord_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarOrdered);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" to see if either is NaN, and store the results in "dst".
        /// </summary>
        public object mm_cmpunord_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareUnordered);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" to see if either is NaN, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpunord_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarUnordered);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for equality, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comieq_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for greater-than-or-equal, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comige_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for greater-than, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comigt_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedGreaterThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for less-than-or-equal, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comile_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedLessThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for less-than, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comilt_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedLessThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for not-equal, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comineq_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarOrderedNotEqual);

        /// <summary>
        /// Convert the 32-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cvtsi32_ss(object a, int b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, int, int, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.ConvertScalarToVector128Single);

        /// <summary>
        /// Convert the lower single-precision (32-bit) floating-point element in "a" to a 32-bit integer, and store the result in "dst".
        /// </summary>
        public int mm_cvtss_si32(object a) => (int)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, int, int>(a, System.Runtime.Intrinsics.X86.Sse.ConvertToInt32);

        /// <summary>
        /// Convert the lower single-precision (32-bit) floating-point element in "a" to a 32-bit integer with truncation, and store the result in "dst".
        /// </summary>
        public int mm_cvttss_si32(object a) => (int)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, int, int>(a, System.Runtime.Intrinsics.X86.Sse.ConvertToInt32WithTruncation);

        /// <summary>
        /// Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm_div_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Divide);

        /// <summary>
        /// Divide the lower single-precision (32-bit) floating-point element in "a" by the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_div_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.DivideScalar);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm_max_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Max);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_max_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MaxScalar);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm_min_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Min);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_min_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MinScalar);

        /// <summary>
        /// Move the lower single-precision (32-bit) floating-point element from "b" to the lower element of "dst", and copy the upper 3 elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_move_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MoveScalar);

        /// <summary>
        /// Move the upper 2 single-precision (32-bit) floating-point elements from "b" to the lower 2 elements of "dst", and copy the upper 2 elements from "a" to the upper 2 elements of "dst".
        /// </summary>
        public object mm_movehl_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MoveHighToLow);

        /// <summary>
        /// Move the lower 2 single-precision (32-bit) floating-point elements from "b" to the upper 2 elements of "dst", and copy the lower 2 elements from "a" to the lower 2 elements of "dst".
        /// </summary>
        public object mm_movelh_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MoveLowToHigh);

        /// <summary>
        /// Set each bit of mask "dst" based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in "a".
        /// </summary>
        public int mm_movemask_ps(object a) => (int)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, int, int>(a, System.Runtime.Intrinsics.X86.Sse.MoveMask);

        /// <summary>
        /// Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_mul_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Multiply);

        /// <summary>
        /// Multiply the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_mul_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MultiplyScalar);

        /// <summary>
        /// Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_or_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Or);

        /// <summary>
        /// Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm_rcp_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.Reciprocal);

        /// <summary>
        /// Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm_rcp_ss(object a, object value) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, value, System.Runtime.Intrinsics.X86.Sse.ReciprocalScalar);

        /// <summary>
        /// Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm_rsqrt_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.ReciprocalSqrt);

        /// <summary>
        /// Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm_rsqrt_ss(object a, object value) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, value, System.Runtime.Intrinsics.X86.Sse.ReciprocalSqrtScalar);

        /// <summary>
        /// Shuffle single-precision (32-bit) floating-point elements in "a" using the control in "imm8", and store the results in "dst".
        /// </summary>
        public object mm_shuffle_ps(object a, object b, byte imm8) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, byte, byte, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, imm8, System.Runtime.Intrinsics.X86.Sse.Shuffle);

        /// <summary>
        /// Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm_sqrt_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.Sqrt);

        /// <summary>
        /// Compute the square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_sqrt_ss(object a, object value) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, value, System.Runtime.Intrinsics.X86.Sse.SqrtScalar);

        /// <summary>
        /// Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm_sub_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Subtract);

        /// <summary>
        /// Subtract the lower single-precision (32-bit) floating-point element in "b" from the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_sub_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.SubtractScalar);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomieq_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomige_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomigt_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedGreaterThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomile_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedLessThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomilt_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedLessThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point element in "a" and "b" for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomineq_ss(object a, object b) => (bool)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarUnorderedNotEqual);

        /// <summary>
        /// Unpack and interleave single-precision (32-bit) floating-point elements from the high half "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_unpackhi_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.UnpackHigh);

        /// <summary>
        /// Unpack and interleave single-precision (32-bit) floating-point elements from the low half of "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_unpacklo_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.UnpackLow);

        /// <summary>
        /// Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_xor_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Xor);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse2IntrinsicsModule
    {
        /// <summary>
        /// Add packed 8-bit integers in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_add_epi8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Add);

        /// <summary>
        /// Add the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_add_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.AddScalar);

        /// <summary>
        /// Add packed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".
        /// </summary>
        public object mm_adds_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.AddSaturate);

        /// <summary>
        /// Compute the bitwise AND of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm_and_si128(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.And);

        /// <summary>
        /// Compute the bitwise NOT of 128 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".
        /// </summary>
        public object mm_andnot_si128(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.AndNot);

        /// <summary>
        /// Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_avg_epu8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Average);

        /// <summary>
        /// Shift "a" left by "imm8" bytes while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm_bslli_si128(object a, byte imm8) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, imm8, System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical128BitLane);

        /// <summary>
        /// Shift "a" right by "imm8" bytes while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm_bsrli_si128(object a, byte imm8) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, imm8, System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical128BitLane);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".
        /// </summary>
        public object mm_cmpeq_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for equality, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpeq_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarEqual);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for greater-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpge_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for greater-than-or-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpge_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarGreaterThanOrEqual);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpgt_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for greater-than, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpgt_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarGreaterThan);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for less-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmple_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareLessThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for less-than-or-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmple_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarLessThanOrEqual);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for less-than, and store the results in "dst". Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.
        /// </summary>
        public object mm_cmplt_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareLessThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for less-than, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmplt_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarLessThan);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpneq_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpneq_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotEqual);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-greater-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpnge_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-greater-than-or-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpnge_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotGreaterThanOrEqual);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpngt_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotGreaterThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-greater-than, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpngt_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotGreaterThan);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpnle_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotLessThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpnle_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotLessThanOrEqual);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpnlt_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotLessThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpnlt_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotLessThan);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" to see if neither is NaN, and store the results in "dst".
        /// </summary>
        public object mm_cmpord_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareOrdered);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" to see if neither is NaN, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpord_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrdered);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" to see if either is NaN, and store the results in "dst".
        /// </summary>
        public object mm_cmpunord_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareUnordered);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" to see if either is NaN, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpunord_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnordered);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for equality, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comieq_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for greater-than-or-equal, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comige_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for greater-than, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comigt_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedGreaterThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for less-than-or-equal, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comile_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedLessThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for less-than, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comilt_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedLessThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for not-equal, and return the boolean result (0 or 1).
        /// </summary>
        public bool mm_comineq_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrderedNotEqual);

        /// <summary>
        /// Convert packed 32-bit integers in "a" to packed double-precision (64-bit) floating-point elements, and store the results in "dst".
        /// </summary>
        public object mm_cvtepi32_pd(object a) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector128<int>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Double);

        /// <summary>
        /// Convert packed 32-bit integers in "a" to packed single-precision (32-bit) floating-point elements, and store the results in "dst".
        /// </summary>
        public object mm_cvtepi32_ps(object a) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector128<int>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Single);

        /// <summary>
        /// Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers, and store the results in "dst".
        /// </summary>
        public object mm_cvtps_epi32(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, int, System.Runtime.Intrinsics.Vector128<int>>(a, System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Int32);

        /// <summary>
        /// Convert the lower double-precision (64-bit) floating-point element in "a" to a 32-bit integer, and store the result in "dst".
        /// </summary>
        public int mm_cvtsd_si32(object a) => (int)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, int, int>(a, System.Runtime.Intrinsics.X86.Sse2.ConvertToInt32);

        /// <summary>
        /// Convert the lower double-precision (64-bit) floating-point element in "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cvtsd_ss(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, double, System.Runtime.Intrinsics.Vector128<double>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse2.ConvertScalarToVector128Single);

        /// <summary>
        /// Copy the lower 32-bit integer in "a" to "dst".
        /// </summary>
        public uint mm_cvtsi128_si32(object a) => (uint)ProcessFunc<uint, System.Runtime.Intrinsics.Vector128<uint>, uint, uint>(a, System.Runtime.Intrinsics.X86.Sse2.ConvertToUInt32);

        /// <summary>
        /// Convert the 32-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cvtsi32_sd(object a, int b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, int, int, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.ConvertScalarToVector128Double);

        /// <summary>
        /// Copy 32-bit integer "a" to the lower elements of "dst", and zero the upper elements of "dst".
        /// </summary>
        public object mm_cvtsi32_si128(int a) => (object)ProcessFunc<int, int, int, System.Runtime.Intrinsics.Vector128<int>>(a, System.Runtime.Intrinsics.X86.Sse2.ConvertScalarToVector128Int32);

        /// <summary>
        /// Convert packed single-precision (32-bit) floating-point elements in "a" to packed 32-bit integers with truncation, and store the results in "dst".
        /// </summary>
        public object mm_cvttps_epi32(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, int, System.Runtime.Intrinsics.Vector128<int>>(a, System.Runtime.Intrinsics.X86.Sse2.ConvertToVector128Int32WithTruncation);

        /// <summary>
        /// Convert the lower double-precision (64-bit) floating-point element in "a" to a 32-bit integer with truncation, and store the result in "dst".
        /// </summary>
        public int mm_cvttsd_si32(object a) => (int)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, int, int>(a, System.Runtime.Intrinsics.X86.Sse2.ConvertToInt32WithTruncation);

        /// <summary>
        /// Divide packed double-precision (64-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm_div_pd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Divide);

        /// <summary>
        /// Divide the lower double-precision (64-bit) floating-point element in "a" by the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_div_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.DivideScalar);

        /// <summary>
        /// Extract a 16-bit integer from "a", selected with "imm8", and store the result in the lower element of "dst".
        /// </summary>
        public ushort mm_extract_epi16(object a, byte imm8) => (ushort)ProcessFunc<ushort, System.Runtime.Intrinsics.Vector128<ushort>, byte, byte, ushort, ushort>(a, imm8, System.Runtime.Intrinsics.X86.Sse2.Extract);

        /// <summary>
        /// Copy "a" to "dst", and insert the 16-bit integer "i" into "dst" at the location specified by "imm8".
        /// </summary>
        public object mm_insert_epi16(object a, short i, byte imm8) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, short, byte, byte, short, System.Runtime.Intrinsics.Vector128<short>>(a, i, imm8, System.Runtime.Intrinsics.X86.Sse2.Insert);

        /// <summary>
        /// Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst".
        /// </summary>
        public object mm_madd_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, int, System.Runtime.Intrinsics.Vector128<int>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MultiplyAddAdjacent);

        /// <summary>
        /// Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm_max_epu8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Max);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_max_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MaxScalar);

        /// <summary>
        /// Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm_min_epu8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Min);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_min_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MinScalar);

        /// <summary>
        /// Copy the lower 64-bit integer in "a" to the lower element of "dst", and zero the upper element.
        /// </summary>
        public object mm_move_epi64(object a) => (object)ProcessFunc<long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>>(a, System.Runtime.Intrinsics.X86.Sse2.MoveScalar);

        /// <summary>
        /// Move the lower double-precision (64-bit) floating-point element from "b" to the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_move_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MoveScalar);

        /// <summary>
        /// Create mask from the most significant bit of each 8-bit element in "a", and store the result in "dst".
        /// </summary>
        public int mm_movemask_epi8(object a) => (int)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, int, int>(a, System.Runtime.Intrinsics.X86.Sse2.MoveMask);

        /// <summary>
        /// Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst".
        /// </summary>
        public object mm_mul_epu32(object a, object b) => (object)ProcessFunc<uint, System.Runtime.Intrinsics.Vector128<uint>, uint, System.Runtime.Intrinsics.Vector128<uint>, ulong, System.Runtime.Intrinsics.Vector128<ulong>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Multiply);

        /// <summary>
        /// Multiply the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_mul_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MultiplyScalar);

        /// <summary>
        /// Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm_mulhi_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MultiplyHigh);

        /// <summary>
        /// Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm_mullo_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MultiplyLow);

        /// <summary>
        /// Compute the bitwise OR of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm_or_si128(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Or);

        /// <summary>
        /// Convert packed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".
        /// </summary>
        public object mm_packs_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.PackSignedSaturate);

        /// <summary>
        /// Convert packed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".
        /// </summary>
        public object mm_packus_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.PackUnsignedSaturate);

        /// <summary>
        /// Compute the absolute differences of packed unsigned 8-bit integers in "a" and "b", then horizontally sum each consecutive 8 differences to produce two unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in "dst".
        /// </summary>
        public object mm_sad_epu8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, ushort, System.Runtime.Intrinsics.Vector128<ushort>>(a, b, System.Runtime.Intrinsics.X86.Sse2.SumAbsoluteDifferences);

        /// <summary>
        /// Shuffle 32-bit integers in "a" using the control in "imm8", and store the results in "dst".
        /// </summary>
        public object mm_shuffle_epi32(object a, byte imm8) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector128<int>, byte, byte, int, System.Runtime.Intrinsics.Vector128<int>>(a, imm8, System.Runtime.Intrinsics.X86.Sse2.Shuffle);

        /// <summary>
        /// Shuffle double-precision (64-bit) floating-point elements using the control in "imm8", and store the results in "dst".
        /// </summary>
        public object mm_shuffle_pd(object a, object b, byte imm8) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, byte, byte, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, imm8, System.Runtime.Intrinsics.X86.Sse2.Shuffle);

        /// <summary>
        /// Shuffle 16-bit integers in the high 64 bits of "a" using the control in "imm8". Store the results in the high 64 bits of "dst", with the low 64 bits being copied from from "a" to "dst".
        /// </summary>
        public object mm_shufflehi_epi16(object a, byte imm8) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, byte, byte, short, System.Runtime.Intrinsics.Vector128<short>>(a, imm8, System.Runtime.Intrinsics.X86.Sse2.ShuffleHigh);

        /// <summary>
        /// Shuffle 16-bit integers in the low 64 bits of "a" using the control in "imm8". Store the results in the low 64 bits of "dst", with the high 64 bits being copied from from "a" to "dst".
        /// </summary>
        public object mm_shufflelo_epi16(object a, byte imm8) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, byte, byte, short, System.Runtime.Intrinsics.Vector128<short>>(a, imm8, System.Runtime.Intrinsics.X86.Sse2.ShuffleLow);

        /// <summary>
        /// Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm_sll_epi16(object a, object count) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, count, System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical);

        /// <summary>
        /// Compute the square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm_sqrt_pd(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse2.Sqrt);

        /// <summary>
        /// Compute the square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_sqrt_sd(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse2.SqrtScalar);

        /// <summary>
        /// Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".
        /// </summary>
        public object mm_sra_epi16(object a, object count) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, count, System.Runtime.Intrinsics.X86.Sse2.ShiftRightArithmetic);

        /// <summary>
        /// Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm_srl_epi16(object a, object count) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, count, System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical);

        /// <summary>
        /// Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".
        /// </summary>
        public object mm_sub_epi8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Subtract);

        /// <summary>
        /// Subtract the lower double-precision (64-bit) floating-point element in "b" from the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_sub_sd(object a, object b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.SubtractScalar);

        /// <summary>
        /// Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".
        /// </summary>
        public object mm_subs_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.SubtractSaturate);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomieq_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomige_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomigt_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedGreaterThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomile_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedLessThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomilt_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedLessThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point element in "a" and "b" for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.
        /// </summary>
        public bool mm_ucomineq_sd(object a, object b) => (bool)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnorderedNotEqual);

        /// <summary>
        /// Unpack and interleave 8-bit integers from the high half of "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_unpackhi_epi8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.UnpackHigh);

        /// <summary>
        /// Unpack and interleave 8-bit integers from the low half of "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_unpacklo_epi8(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.UnpackLow);

        /// <summary>
        /// Compute the bitwise XOR of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm_xor_si128(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Xor);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse2X64IntrinsicsModule
    {
        /// <summary>
        /// Convert the lower double-precision (64-bit) floating-point element in "a" to a 64-bit integer, and store the result in "dst".
        /// </summary>
        public long mm_cvtsd_si64(object a) => (long)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, long, long>(a, System.Runtime.Intrinsics.X86.Sse2.X64.ConvertToInt64);

        /// <summary>
        /// Copy the lower 64-bit integer in "a" to "dst".
        /// </summary>
        public ulong mm_cvtsi128_si64(object a) => (ulong)ProcessFunc<ulong, System.Runtime.Intrinsics.Vector128<ulong>, ulong, ulong>(a, System.Runtime.Intrinsics.X86.Sse2.X64.ConvertToUInt64);

        /// <summary>
        /// Convert the 64-bit integer "b" to a double-precision (64-bit) floating-point element, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cvtsi64_sd(object a, long b) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, long, long, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.X64.ConvertScalarToVector128Double);

        /// <summary>
        /// Copy 64-bit integer "a" to the lower element of "dst", and zero the upper element.
        /// </summary>
        public object mm_cvtsi64_si128(long a) => (object)ProcessFunc<long, long, long, System.Runtime.Intrinsics.Vector128<long>>(a, System.Runtime.Intrinsics.X86.Sse2.X64.ConvertScalarToVector128Int64);

        /// <summary>
        /// Convert the lower double-precision (64-bit) floating-point element in "a" to a 64-bit integer with truncation, and store the result in "dst".
        /// </summary>
        public long mm_cvttsd_si64(object a) => (long)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, long, long>(a, System.Runtime.Intrinsics.X86.Sse2.X64.ConvertToInt64WithTruncation);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse3IntrinsicsModule
    {
        /// <summary>
        /// Alternatively add and subtract packed single-precision (32-bit) floating-point elements in "a" to/from packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm_addsub_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse3.AddSubtract);

        /// <summary>
        /// Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in "a" and "b", and pack the results in "dst".
        /// </summary>
        public object mm_hadd_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse3.HorizontalAdd);

        /// <summary>
        /// Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in "a" and "b", and pack the results in "dst".
        /// </summary>
        public object mm_hsub_ps(object a, object b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse3.HorizontalSubtract);

        /// <summary>
        /// Duplicate the low double-precision (64-bit) floating-point element from "a", and store the results in "dst".
        /// </summary>
        public object mm_movedup_pd(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse3.MoveAndDuplicate);

        /// <summary>
        /// Duplicate odd-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
        /// </summary>
        public object mm_movehdup_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse3.MoveHighAndDuplicate);

        /// <summary>
        /// Duplicate even-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
        /// </summary>
        public object mm_moveldup_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse3.MoveLowAndDuplicate);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse41IntrinsicsModule
    {
        /// <summary>
        /// Blend packed 16-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst".
        /// </summary>
        public object mm_blend_epi16(object a, object b, byte imm8) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, byte, byte, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, imm8, System.Runtime.Intrinsics.X86.Sse41.Blend);

        /// <summary>
        /// Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".
        /// </summary>
        public object mm_blendv_epi8(object a, object b, object mask) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, mask, System.Runtime.Intrinsics.X86.Sse41.BlendVariable);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" up to an integer value, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm_ceil_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse41.Ceiling);

        /// <summary>
        /// Round the lower double-precision (64-bit) floating-point element in "b" up to an integer value, store the result as a double-precision floating-point element in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_ceil_sd(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse41.CeilingScalar);

        /// <summary>
        /// Compare packed 64-bit integers in "a" and "b" for equality, and store the results in "dst".
        /// </summary>
        public object mm_cmpeq_epi64(object a, object b) => (object)ProcessFunc<long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>>(a, b, System.Runtime.Intrinsics.X86.Sse41.CompareEqual);

        /// <summary>
        /// Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".
        /// </summary>
        public object mm_cvtepi8_epi16(object a) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, short, System.Runtime.Intrinsics.Vector128<short>>(a, System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int16);

        /// <summary>
        /// Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".
        /// </summary>
        public object mm_cvtepi8_epi32(object a) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, int, System.Runtime.Intrinsics.Vector128<int>>(a, System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int32);

        /// <summary>
        /// Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst".
        /// </summary>
        public object mm_cvtepi8_epi64(object a) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, long, System.Runtime.Intrinsics.Vector128<long>>(a, System.Runtime.Intrinsics.X86.Sse41.ConvertToVector128Int64);

        /// <summary>
        /// Conditionally multiply the packed single-precision (32-bit) floating-point elements in "a" and "b" using the high 4 bits in "imm8", sum the four products, and conditionally store the sum in "dst" using the low 4 bits of "imm8".
        /// </summary>
        public object mm_dp_ps(object a, object b, byte imm8) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, byte, byte, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, imm8, System.Runtime.Intrinsics.X86.Sse41.DotProduct);

        /// <summary>
        /// Extract an 8-bit integer from "a", selected with "imm8", and store the result in the lower element of "dst".
        /// </summary>
        public byte mm_extract_epi8(object a, byte imm8) => (byte)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, byte, byte, byte>(a, imm8, System.Runtime.Intrinsics.X86.Sse41.Extract);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" down to an integer value, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm_floor_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse41.Floor);

        /// <summary>
        /// Round the lower double-precision (64-bit) floating-point element in "b" down to an integer value, store the result as a double-precision floating-point element in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_floor_sd(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse41.FloorScalar);

        /// <summary>
        /// Copy "a" to "dst", and insert the lower 8-bit integer from "i" into "dst" at the location specified by "imm8".
        /// </summary>
        public object mm_insert_epi8(object a, sbyte i, byte imm8) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, sbyte, byte, byte, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, i, imm8, System.Runtime.Intrinsics.X86.Sse41.Insert);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm_max_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse41.Max);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm_min_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse41.Min);

        /// <summary>
        /// Horizontally compute the minimum amongst the packed unsigned 16-bit integers in "a", store the minimum and index in "dst", and zero the remaining bits in "dst".
        /// </summary>
        public object mm_minpos_epu16(object a) => (object)ProcessFunc<ushort, System.Runtime.Intrinsics.Vector128<ushort>, ushort, System.Runtime.Intrinsics.Vector128<ushort>>(a, System.Runtime.Intrinsics.X86.Sse41.MinHorizontal);

        /// <summary>
        /// Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst". 	Eight SADs are performed using one quadruplet from "b" and eight quadruplets from "a". One quadruplet is selected from "b" starting at on the offset specified in "imm8". Eight quadruplets are formed from sequential 8-bit integers selected from "a" starting at the offset specified in "imm8".
        /// </summary>
        public object mm_mpsadbw_epu8(object a, object b, byte imm8) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, byte, ushort, System.Runtime.Intrinsics.Vector128<ushort>>(a, b, imm8, System.Runtime.Intrinsics.X86.Sse41.MultipleSumAbsoluteDifferences);

        /// <summary>
        /// Multiply the low 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst".
        /// </summary>
        public object mm_mul_epi32(object a, object b) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector128<int>, int, System.Runtime.Intrinsics.Vector128<int>, long, System.Runtime.Intrinsics.Vector128<long>>(a, b, System.Runtime.Intrinsics.X86.Sse41.Multiply);

        /// <summary>
        /// Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm_mullo_epi32(object a, object b) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector128<int>, int, System.Runtime.Intrinsics.Vector128<int>, int, System.Runtime.Intrinsics.Vector128<int>>(a, b, System.Runtime.Intrinsics.X86.Sse41.MultiplyLow);

        /// <summary>
        /// Convert packed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst".
        /// </summary>
        public object mm_packus_epi32(object a, object b) => (object)ProcessFunc<int, System.Runtime.Intrinsics.Vector128<int>, int, System.Runtime.Intrinsics.Vector128<int>, ushort, System.Runtime.Intrinsics.Vector128<ushort>>(a, b, System.Runtime.Intrinsics.X86.Sse41.PackUnsignedSaturate);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" using the "rounding" parameter, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm_round_ps(object a) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse41.RoundToNearestInteger);

        /// <summary>
        /// Round the lower double-precision (64-bit) floating-point element in "b" using the "rounding" parameter, store the result as a double-precision floating-point element in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_round_sd(object a) => (object)ProcessFunc<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse41.RoundCurrentDirectionScalar);

        /// <summary>
        /// Compute the bitwise AND of 128 bits (representing integer data) in "a" and "b", and set "ZF" to 1 if the result is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", and set "CF" to 1 if the result is zero, otherwise set "CF" to 0. Return the "CF" value.
        /// </summary>
        public bool mm_testc_si128(object a, object b) => (bool)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse41.TestC);

        /// <summary>
        /// Compute the bitwise AND of 128 bits (representing integer data) in "a" and "b", and set "ZF" to 1 if the result is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", and set "CF" to 1 if the result is zero, otherwise set "CF" to 0. Return 1 if both the "ZF" and "CF" values are zero, otherwise return 0.
        /// </summary>
        public bool mm_testnzc_si128(object a, object b) => (bool)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse41.TestNotZAndNotC);

        /// <summary>
        /// Compute the bitwise AND of 128 bits (representing integer data) in "a" and "b", and set "ZF" to 1 if the result is zero, otherwise set "ZF" to 0. Compute the bitwise NOT of "a" and then AND with "b", and set "CF" to 1 if the result is zero, otherwise set "CF" to 0. Return the "ZF" value.
        /// </summary>
        public bool mm_testz_si128(object a, object b) => (bool)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, bool, bool>(a, b, System.Runtime.Intrinsics.X86.Sse41.TestZ);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse41X64IntrinsicsModule
    {
        /// <summary>
        /// Extract a 64-bit integer from "a", selected with "imm8", and store the result in "dst".
        /// </summary>
        public long mm_extract_epi64(object a, byte imm8) => (long)ProcessFunc<long, System.Runtime.Intrinsics.Vector128<long>, byte, byte, long, long>(a, imm8, System.Runtime.Intrinsics.X86.Sse41.X64.Extract);

        /// <summary>
        /// Copy "a" to "dst", and insert the 64-bit integer "i" into "dst" at the location specified by "imm8".
        /// </summary>
        public object mm_insert_epi64(object a, long i, byte imm8) => (object)ProcessFunc<long, System.Runtime.Intrinsics.Vector128<long>, long, long, byte, byte, long, System.Runtime.Intrinsics.Vector128<long>>(a, i, imm8, System.Runtime.Intrinsics.X86.Sse41.X64.Insert);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse42IntrinsicsModule
    {
        /// <summary>
        /// Compare packed 64-bit integers in "a" and "b" for greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpgt_epi64(object a, object b) => (object)ProcessFunc<long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>>(a, b, System.Runtime.Intrinsics.X86.Sse42.CompareGreaterThan);

        /// <summary>
        /// Starting with the initial value in "crc", accumulates a CRC32 value for unsigned 8-bit integer "v", and stores the result in "dst".
        /// </summary>
        public uint mm_crc32_u8(uint crc, byte v) => (uint)ProcessFunc<uint, uint, byte, byte, uint, uint>(crc, v, System.Runtime.Intrinsics.X86.Sse42.Crc32);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse42X64IntrinsicsModule
    {
        /// <summary>
        /// Starting with the initial value in "crc", accumulates a CRC32 value for unsigned 64-bit integer "v", and stores the result in "dst".
        /// </summary>
        public ulong mm_crc32_u64(ulong crc, ulong v) => (ulong)ProcessFunc<ulong, ulong, ulong, ulong, ulong, ulong>(crc, v, System.Runtime.Intrinsics.X86.Sse42.X64.Crc32);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class SseX64IntrinsicsModule
    {
        /// <summary>
        /// Convert the 64-bit integer "b" to a single-precision (32-bit) floating-point element, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cvtsi64_ss(object a, long b) => (object)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, long, long, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.X64.ConvertScalarToVector128Single);

        /// <summary>
        /// Convert the lower single-precision (32-bit) floating-point element in "a" to a 64-bit integer, and store the result in "dst".
        /// </summary>
        public long mm_cvtss_si64(object a) => (long)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, long, long>(a, System.Runtime.Intrinsics.X86.Sse.X64.ConvertToInt64);

        /// <summary>
        /// Convert the lower single-precision (32-bit) floating-point element in "a" to a 64-bit integer with truncation, and store the result in "dst".
        /// </summary>
        public long mm_cvttss_si64(object a) => (long)ProcessFunc<float, System.Runtime.Intrinsics.Vector128<float>, long, long>(a, System.Runtime.Intrinsics.X86.Sse.X64.ConvertToInt64WithTruncation);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Ssse3IntrinsicsModule
    {
        /// <summary>
        /// Compute the absolute value of packed 8-bit integers in "a", and store the unsigned results in "dst".
        /// </summary>
        public object mm_abs_epi8(object a) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, System.Runtime.Intrinsics.X86.Ssse3.Abs);

        /// <summary>
        /// Concatenate 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "count" bytes, and store the low 16 bytes in "dst".
        /// </summary>
        public object mm_alignr_epi8(object a, object b, byte count) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, byte, byte, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, count, System.Runtime.Intrinsics.X86.Ssse3.AlignRight);

        /// <summary>
        /// Horizontally add adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm_hadd_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.HorizontalAdd);

        /// <summary>
        /// Horizontally add adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm_hadds_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.HorizontalAddSaturate);

        /// <summary>
        /// Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm_hsub_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.HorizontalSubtract);

        /// <summary>
        /// Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm_hsubs_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.HorizontalSubtractSaturate);

        /// <summary>
        /// Vertically multiply each unsigned 8-bit integer from "a" with the corresponding signed 8-bit integer from "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst".
        /// </summary>
        public object mm_maddubs_epi16(object a, object b) => (object)ProcessFunc<byte, System.Runtime.Intrinsics.Vector128<byte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.MultiplyAddAdjacent);

        /// <summary>
        /// Multiply packed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst".
        /// </summary>
        public object mm_mulhrs_epi16(object a, object b) => (object)ProcessFunc<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.MultiplyHighRoundScale);

        /// <summary>
        /// Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".
        /// </summary>
        public object mm_shuffle_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.Shuffle);

        /// <summary>
        /// Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.
        /// </summary>
        public object mm_sign_epi8(object a, object b) => (object)ProcessFunc<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.Sign);

    }
}

namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AesIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_aesdec_si128", (Func<object, object, object>)mm_aesdec_si128);
            RegisterFunction("mm_aesdeclast_si128", (Func<object, object, object>)mm_aesdeclast_si128);
            RegisterFunction("mm_aesenc_si128", (Func<object, object, object>)mm_aesenc_si128);
            RegisterFunction("mm_aesenclast_si128", (Func<object, object, object>)mm_aesenclast_si128);
            RegisterFunction("mm_aesimc_si128", (Func<object, object>)mm_aesimc_si128);
            RegisterFunction("mm_aeskeygenassist_si128", (Func<object, byte, object>)mm_aeskeygenassist_si128);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_aesdec_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesdec_si128 (__m128i a, __m128i RoundKey) AESDEC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesdeclast_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesdeclast_si128 (__m128i a, __m128i RoundKey) AESDECLAST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesenc_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey) AESENC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesenclast_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey) AESENCLAST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesimc_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aesimc_si128 (__m128i a) AESIMC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aeskeygenassist_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / AES";
                descriptor.Description = @"__m128i _mm_aeskeygenassist_si128 (__m128i a, const int imm8) AESKEYGENASSIST xmm, xmm/m128, imm8";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AvxIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_cmp_ps", (Func<object, object, System.Runtime.Intrinsics.X86.FloatComparisonMode, object>)mm_cmp_ps);
            RegisterFunction("mm_cmp_sd", (Func<object, object, System.Runtime.Intrinsics.X86.FloatComparisonMode, object>)mm_cmp_sd);
            RegisterFunction("mm_permute_ps", (Func<object, byte, object>)mm_permute_ps);
            RegisterFunction("mm_permutevar_ps", (Func<object, object, object>)mm_permutevar_ps);
            RegisterFunction("mm_testc_ps", (Func<object, object, bool>)mm_testc_ps);
            RegisterFunction("mm_testnzc_ps", (Func<object, object, bool>)mm_testnzc_ps);
            RegisterFunction("mm_testz_ps", (Func<object, object, bool>)mm_testz_ps);
            RegisterFunction("mm256_add_ps", (Func<object, object, object>)mm256_add_ps);
            RegisterFunction("mm256_addsub_ps", (Func<object, object, object>)mm256_addsub_ps);
            RegisterFunction("mm256_and_ps", (Func<object, object, object>)mm256_and_ps);
            RegisterFunction("mm256_andnot_ps", (Func<object, object, object>)mm256_andnot_ps);
            RegisterFunction("mm256_blend_ps", (Func<object, object, byte, object>)mm256_blend_ps);
            RegisterFunction("mm256_blendv_ps", (Func<object, object, object, object>)mm256_blendv_ps);
            RegisterFunction("mm256_ceil_ps", (Func<object, object>)mm256_ceil_ps);
            RegisterFunction("mm256_cvtepi32_ps", (Func<object, object>)mm256_cvtepi32_ps);
            RegisterFunction("mm256_cvtpd_epi32", (Func<object, object>)mm256_cvtpd_epi32);
            RegisterFunction("mm256_cvtpd_ps", (Func<object, object>)mm256_cvtpd_ps);
            RegisterFunction("mm256_cvtps_epi32", (Func<object, object>)mm256_cvtps_epi32);
            RegisterFunction("mm256_cvtps_pd", (Func<object, object>)mm256_cvtps_pd);
            RegisterFunction("mm256_cvttpd_epi32", (Func<object, object>)mm256_cvttpd_epi32);
            RegisterFunction("mm256_cvttps_epi32", (Func<object, object>)mm256_cvttps_epi32);
            RegisterFunction("mm256_div_ps", (Func<object, object, object>)mm256_div_ps);
            RegisterFunction("mm256_dp_ps", (Func<object, object, byte, object>)mm256_dp_ps);
            RegisterFunction("mm256_extractf128_si256", (Func<object, byte, object>)mm256_extractf128_si256);
            RegisterFunction("mm256_floor_ps", (Func<object, object>)mm256_floor_ps);
            RegisterFunction("mm256_hadd_ps", (Func<object, object, object>)mm256_hadd_ps);
            RegisterFunction("mm256_hsub_ps", (Func<object, object, object>)mm256_hsub_ps);
            RegisterFunction("mm256_insertf128_si256", (Func<object, object, byte, object>)mm256_insertf128_si256);
            RegisterFunction("mm256_max_ps", (Func<object, object, object>)mm256_max_ps);
            RegisterFunction("mm256_min_ps", (Func<object, object, object>)mm256_min_ps);
            RegisterFunction("mm256_movehdup_ps", (Func<object, object>)mm256_movehdup_ps);
            RegisterFunction("mm256_moveldup_ps", (Func<object, object>)mm256_moveldup_ps);
            RegisterFunction("mm256_movemask_ps", (Func<object, int>)mm256_movemask_ps);
            RegisterFunction("mm256_mul_ps", (Func<object, object, object>)mm256_mul_ps);
            RegisterFunction("mm256_or_ps", (Func<object, object, object>)mm256_or_ps);
            RegisterFunction("mm256_permute2f128_si256", (Func<object, object, byte, object>)mm256_permute2f128_si256);
            RegisterFunction("mm256_rcp_ps", (Func<object, object>)mm256_rcp_ps);
            RegisterFunction("mm256_round_ps", (Func<object, object>)mm256_round_ps);
            RegisterFunction("mm256_rsqrt_ps", (Func<object, object>)mm256_rsqrt_ps);
            RegisterFunction("mm256_shuffle_ps", (Func<object, object, byte, object>)mm256_shuffle_ps);
            RegisterFunction("mm256_sqrt_ps", (Func<object, object>)mm256_sqrt_ps);
            RegisterFunction("mm256_sub_ps", (Func<object, object, object>)mm256_sub_ps);
            RegisterFunction("mm256_unpackhi_ps", (Func<object, object, object>)mm256_unpackhi_ps);
            RegisterFunction("mm256_unpacklo_ps", (Func<object, object, object>)mm256_unpacklo_ps);
            RegisterFunction("mm256_xor_ps", (Func<object, object, object>)mm256_xor_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_cmp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" based on the comparison operand specified by ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmp_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" based on the comparison operand specified by ""imm8"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_permute_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" using the control in ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_permutevar_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" using the control in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_testc_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""CF"" value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_testnzc_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return 1 if both the ""ZF"" and ""CF"" values are zero, otherwise return 0.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_testz_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing single-precision (32-bit) floating-point elements) in ""a"" and ""b"", producing an intermediate 128-bit value, and set ""ZF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", producing an intermediate value, and set ""CF"" to 1 if the sign bit of each 32-bit element in the intermediate value is zero, otherwise set ""CF"" to 0. Return the ""ZF"" value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_add_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Add packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_addsub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Alternatively add and subtract packed single-precision (32-bit) floating-point elements in ""a"" to/from packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_and_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_andnot_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in ""a"" and then AND with ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_blend_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Blend packed single-precision (32-bit) floating-point elements from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_blendv_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Blend packed single-precision (32-bit) floating-point elements from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("mask", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_ceil_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" up to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtepi32_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed 32-bit integers in ""a"" to packed single-precision (32-bit) floating-point elements, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtpd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed 32-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtpd_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed single-precision (32-bit) floating-point elements, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtps_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed 32-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtps_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed double-precision (64-bit) floating-point elements, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvttpd_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed double-precision (64-bit) floating-point elements in ""a"" to packed 32-bit integers with truncation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvttps_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed 32-bit integers with truncation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_div_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Divide packed single-precision (32-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_dp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Conditionally multiply the packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" using the high 4 bits in ""imm8"", sum the four products, and conditionally store the sum in ""dst"" using the low 4 bits of ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_extractf128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Extract 128 bits (composed of integer data) from ""a"", selected with ""imm8"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_floor_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" down to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hadd_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hsub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_insertf128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Copy ""a"" to ""dst"", then insert 128 bits from ""b"" into ""dst"" at the location specified by ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_max_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_min_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_movehdup_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Duplicate odd-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_moveldup_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Duplicate even-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_movemask_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Set each bit of mask ""dst"" based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in ""a"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mul_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Multiply packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_or_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_permute2f128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle 128-bits (composed of integer data) selected by ""imm8"" from ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_rcp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_round_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("rounding", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_rsqrt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_shuffle_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" within 128-bit lanes using the control in ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sqrt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Subtract packed single-precision (32-bit) floating-point elements in ""b"" from packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_xor_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX";
                descriptor.Description = @"Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Avx2IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_blend_epi32", (Func<object, object, byte, object>)mm_blend_epi32);
            RegisterFunction("mm_broadcastb_epi8", (Func<object, object>)mm_broadcastb_epi8);
            RegisterFunction("mm256_abs_epi8", (Func<object, object>)mm256_abs_epi8);
            RegisterFunction("mm256_add_epi8", (Func<object, object, object>)mm256_add_epi8);
            RegisterFunction("mm256_adds_epi8", (Func<object, object, object>)mm256_adds_epi8);
            RegisterFunction("mm256_alignr_epi8", (Func<object, object, byte, object>)mm256_alignr_epi8);
            RegisterFunction("mm256_and_si256", (Func<object, object, object>)mm256_and_si256);
            RegisterFunction("mm256_andnot_si256", (Func<object, object, object>)mm256_andnot_si256);
            RegisterFunction("mm256_avg_epu8", (Func<object, object, object>)mm256_avg_epu8);
            RegisterFunction("mm256_blendv_epi8", (Func<object, object, object, object>)mm256_blendv_epi8);
            RegisterFunction("mm256_broadcastb_epi8", (Func<object, object>)mm256_broadcastb_epi8);
            RegisterFunction("mm256_bslli_epi128", (Func<object, byte, object>)mm256_bslli_epi128);
            RegisterFunction("mm256_bsrli_epi128", (Func<object, byte, object>)mm256_bsrli_epi128);
            RegisterFunction("mm256_cmpeq_epi8", (Func<object, object, object>)mm256_cmpeq_epi8);
            RegisterFunction("mm256_cmpgt_epi8", (Func<object, object, object>)mm256_cmpgt_epi8);
            RegisterFunction("mm256_cvtepi8_epi16", (Func<object, object>)mm256_cvtepi8_epi16);
            RegisterFunction("mm256_cvtepi8_epi32", (Func<object, object>)mm256_cvtepi8_epi32);
            RegisterFunction("mm256_cvtepi8_epi64", (Func<object, object>)mm256_cvtepi8_epi64);
            RegisterFunction("mm256_cvtsi256_si32", (Func<object, int>)mm256_cvtsi256_si32);
            RegisterFunction("mm256_extracti128_si256", (Func<object, byte, object>)mm256_extracti128_si256);
            RegisterFunction("mm256_hadd_epi16", (Func<object, object, object>)mm256_hadd_epi16);
            RegisterFunction("mm256_hadds_epi16", (Func<object, object, object>)mm256_hadds_epi16);
            RegisterFunction("mm256_hsub_epi16", (Func<object, object, object>)mm256_hsub_epi16);
            RegisterFunction("mm256_hsubs_epi16", (Func<object, object, object>)mm256_hsubs_epi16);
            RegisterFunction("mm256_inserti128_si256", (Func<object, object, byte, object>)mm256_inserti128_si256);
            RegisterFunction("mm256_madd_epi16", (Func<object, object, object>)mm256_madd_epi16);
            RegisterFunction("mm256_max_epi8", (Func<object, object, object>)mm256_max_epi8);
            RegisterFunction("mm256_min_epi8", (Func<object, object, object>)mm256_min_epi8);
            RegisterFunction("mm256_movemask_epi8", (Func<object, int>)mm256_movemask_epi8);
            RegisterFunction("mm256_mpsadbw_epu8", (Func<object, object, byte, object>)mm256_mpsadbw_epu8);
            RegisterFunction("mm256_mul_epi32", (Func<object, object, object>)mm256_mul_epi32);
            RegisterFunction("mm256_mulhi_epi16", (Func<object, object, object>)mm256_mulhi_epi16);
            RegisterFunction("mm256_mulhrs_epi16", (Func<object, object, object>)mm256_mulhrs_epi16);
            RegisterFunction("mm256_mullo_epi16", (Func<object, object, object>)mm256_mullo_epi16);
            RegisterFunction("mm256_or_si256", (Func<object, object, object>)mm256_or_si256);
            RegisterFunction("mm256_packs_epi16", (Func<object, object, object>)mm256_packs_epi16);
            RegisterFunction("mm256_packus_epi16", (Func<object, object, object>)mm256_packus_epi16);
            RegisterFunction("mm256_permute2x128_si256", (Func<object, object, byte, object>)mm256_permute2x128_si256);
            RegisterFunction("mm256_permute4x64_epi64", (Func<object, byte, object>)mm256_permute4x64_epi64);
            RegisterFunction("mm256_permutevar8x32_epi32", (Func<object, object, object>)mm256_permutevar8x32_epi32);
            RegisterFunction("mm256_sad_epu8", (Func<object, object, object>)mm256_sad_epu8);
            RegisterFunction("mm256_shuffle_epi8", (Func<object, object, object>)mm256_shuffle_epi8);
            RegisterFunction("mm256_shufflehi_epi16", (Func<object, byte, object>)mm256_shufflehi_epi16);
            RegisterFunction("mm256_shufflelo_epi16", (Func<object, byte, object>)mm256_shufflelo_epi16);
            RegisterFunction("mm256_sign_epi8", (Func<object, object, object>)mm256_sign_epi8);
            RegisterFunction("mm256_sll_epi16", (Func<object, object, object>)mm256_sll_epi16);
            RegisterFunction("mm256_sllv_epi32", (Func<object, object, object>)mm256_sllv_epi32);
            RegisterFunction("mm256_srav_epi32", (Func<object, object, object>)mm256_srav_epi32);
            RegisterFunction("mm256_srl_epi16", (Func<object, object, object>)mm256_srl_epi16);
            RegisterFunction("mm256_srlv_epi32", (Func<object, object, object>)mm256_srlv_epi32);
            RegisterFunction("mm256_sub_epi8", (Func<object, object, object>)mm256_sub_epi8);
            RegisterFunction("mm256_subs_epi8", (Func<object, object, object>)mm256_subs_epi8);
            RegisterFunction("mm256_unpackhi_epi8", (Func<object, object, object>)mm256_unpackhi_epi8);
            RegisterFunction("mm256_unpacklo_epi8", (Func<object, object, object>)mm256_unpacklo_epi8);
            RegisterFunction("mm256_xor_si256", (Func<object, object, object>)mm256_xor_si256);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_blend_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Blend packed 32-bit integers from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_broadcastb_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 8-bit integer from ""a"" to all elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_abs_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the absolute value of packed 8-bit integers in ""a"", and store the unsigned results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_add_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_adds_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_alignr_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Concatenate pairs of 16-byte blocks in ""a"" and ""b"" into a 32-byte temporary result, shift the result right by ""count"" bytes, and store the low 16 bytes in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_and_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_andnot_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the bitwise NOT of 256 bits (representing integer data) in ""a"" and then AND with ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_avg_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Average packed unsigned 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_blendv_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Blend packed 8-bit integers from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("mask", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_broadcastb_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Broadcast the low packed 8-bit integer from ""a"" to all elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_bslli_epi128"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift 128-bit lanes in ""a"" left by ""imm8"" bytes while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_bsrli_epi128"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift 128-bit lanes in ""a"" right by ""imm8"" bytes while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cmpeq_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cmpgt_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtepi8_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 8-bit integers in ""a"" to packed 16-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtepi8_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 8-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtepi8_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Sign extend packed 8-bit integers in the low 8 bytes of ""a"" to packed 64-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cvtsi256_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Copy the lower 32-bit integer in ""a"" to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_extracti128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Extract 128 bits (composed of integer data) from ""a"", selected with ""imm8"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hadd_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hadds_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hsub_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hsubs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_inserti128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Copy ""a"" to ""dst"", then insert 128 bits (composed of integer data) from ""b"" into ""dst"" at the location specified by ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_madd_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply packed signed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_max_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_min_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_movemask_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Create mask from the most significant bit of each 8-bit element in ""a"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mpsadbw_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in ""a"" compared to those in ""b"", and store the 16-bit results in ""dst"". 	Eight SADs are performed for each 128-bit lane using one quadruplet from ""b"" and eight quadruplets from ""a"". One quadruplet is selected from ""b"" starting at on the offset specified in ""imm8"". Eight quadruplets are formed from sequential 8-bit integers selected from ""a"" starting at the offset specified in ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mul_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the low 32-bit integers from each packed 64-bit element in ""a"" and ""b"", and store the signed 64-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mulhi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mulhrs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply packed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mullo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_or_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the bitwise OR of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_packs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Convert packed 16-bit integers from ""a"" and ""b"" to packed 8-bit integers using signed saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_packus_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Convert packed 16-bit integers from ""a"" and ""b"" to packed 8-bit integers using unsigned saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_permute2x128_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 128-bits (composed of integer data) selected by ""imm8"" from ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_permute4x64_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 64-bit integers in ""a"" across lanes using the control in ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_permutevar8x32_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 32-bit integers in ""a"" across lanes using the corresponding index in ""idx"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("idx", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sad_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the absolute differences of packed unsigned 8-bit integers in ""a"" and ""b"", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_shuffle_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 8-bit integers in ""a"" within 128-bit lanes according to shuffle control mask in the corresponding 8-bit element of ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_shufflehi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 16-bit integers in the high 64 bits of 128-bit lanes of ""a"" using the control in ""imm8"". Store the results in the high 64 bits of 128-bit lanes of ""dst"", with the low 64 bits of 128-bit lanes being copied from from ""a"" to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_shufflelo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shuffle 16-bit integers in the low 64 bits of 128-bit lanes of ""a"" using the control in ""imm8"". Store the results in the low 64 bits of 128-bit lanes of ""dst"", with the high 64 bits of 128-bit lanes being copied from from ""a"" to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sign_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Negate packed 8-bit integers in ""a"" when the corresponding signed 8-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sll_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sllv_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" left by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_srav_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by the amount specified by the corresponding element in ""count"" while shifting in sign bits, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_srl_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_srlv_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Shift packed 32-bit integers in ""a"" right by the amount specified by the corresponding element in ""count"" while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sub_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_subs_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"" using saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_xor_si256"];
                descriptor.Category = "Vector Hardware Intrinsics / AVX2";
                descriptor.Description = @"Compute the bitwise XOR of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi1IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("andn_u32", (Func<uint, uint, uint>)andn_u32);
            RegisterFunction("bextr_u32", (Func<uint, byte, byte, uint>)bextr_u32);
            RegisterFunction("bextr2_u32", (Func<uint, ushort, uint>)bextr2_u32);
            RegisterFunction("blsi_u32", (Func<uint, uint>)blsi_u32);
            RegisterFunction("blsmsk_u32", (Func<uint, uint>)blsmsk_u32);
            RegisterFunction("blsr_u32", (Func<uint, uint>)blsr_u32);
            RegisterFunction("mm_tzcnt_32", (Func<uint, uint>)mm_tzcnt_32);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["andn_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _andn_u32 (unsigned int a, unsigned int b) ANDN r32a, r32b, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bextr_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _bextr_u32 (unsigned int a, unsigned int start, unsigned int len) BEXTR r32a, reg/m32, r32b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bextr2_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _bextr2_u32 (unsigned int a, unsigned int control) BEXTR r32a, reg/m32, r32b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsi_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _blsi_u32 (unsigned int a) BLSI reg, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsmsk_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _blsmsk_u32 (unsigned int a) BLSMSK reg, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsr_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned int _blsr_u32 (unsigned int a) BLSR reg, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_tzcnt_32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"int _mm_tzcnt_32 (unsigned int a) TZCNT reg, reg/m32";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi1X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("andn_u64", (Func<ulong, ulong, ulong>)andn_u64);
            RegisterFunction("bextr_u64", (Func<ulong, byte, byte, ulong>)bextr_u64);
            RegisterFunction("bextr2_u64", (Func<ulong, ushort, ulong>)bextr2_u64);
            RegisterFunction("blsi_u64", (Func<ulong, ulong>)blsi_u64);
            RegisterFunction("blsmsk_u64", (Func<ulong, ulong>)blsmsk_u64);
            RegisterFunction("blsr_u64", (Func<ulong, ulong>)blsr_u64);
            RegisterFunction("mm_tzcnt_64", (Func<ulong, ulong>)mm_tzcnt_64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["andn_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _andn_u64 (unsigned __int64 a, unsigned __int64 b) ANDN r64a, r64b, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bextr_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _bextr_u64 (unsigned __int64 a, unsigned int start, unsigned int len) BEXTR r64a, reg/m64, r64b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["bextr2_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _bextr2_u64 (unsigned __int64 a, unsigned __int64 control) BEXTR r64a, reg/m64, r64b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsi_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _blsi_u64 (unsigned __int64 a) BLSI reg, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsmsk_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _blsmsk_u64 (unsigned __int64 a) BLSMSK reg, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["blsr_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"unsigned __int64 _blsr_u64 (unsigned __int64 a) BLSR reg, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_tzcnt_64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI1";
                descriptor.Description = @"__int64 _mm_tzcnt_64 (unsigned __int64 a) TZCNT reg, reg/m64";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi2IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("bzhi_u32", (Func<uint, uint, uint>)bzhi_u32);
            RegisterFunction("mulx_u32", (Func<uint, uint, uint>)mulx_u32);
            RegisterFunction("pdep_u32", (Func<uint, uint, uint>)pdep_u32);
            RegisterFunction("pext_u32", (Func<uint, uint, uint>)pext_u32);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["bzhi_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned int _bzhi_u32 (unsigned int a, unsigned int index) BZHI r32a, reg/m32, r32b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mulx_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned int _mulx_u32 (unsigned int a, unsigned int b, unsigned int* hi) MULX r32a, r32b, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pdep_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned int _pdep_u32 (unsigned int a, unsigned int mask) PDEP r32a, r32b, reg/m32";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pext_u32"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned int _pext_u32 (unsigned int a, unsigned int mask) PEXT r32a, r32b, reg/m32";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Bmi2X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("bzhi_u64", (Func<ulong, ulong, ulong>)bzhi_u64);
            RegisterFunction("mulx_u64", (Func<ulong, ulong, ulong>)mulx_u64);
            RegisterFunction("pdep_u64", (Func<ulong, ulong, ulong>)pdep_u64);
            RegisterFunction("pext_u64", (Func<ulong, ulong, ulong>)pext_u64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["bzhi_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned __int64 _bzhi_u64 (unsigned __int64 a, unsigned int index) BZHI r64a, reg/m32, r64b";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mulx_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned __int64 _mulx_u64 (unsigned __int64 a, unsigned __int64 b, unsigned __int64* hi) MULX r64a, r64b, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pdep_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned __int64 _pdep_u64 (unsigned __int64 a, unsigned __int64 mask) PDEP r64a, r64b, reg/m64";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["pext_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / BMI2";
                descriptor.Description = @"unsigned __int64 _pext_u64 (unsigned __int64 a, unsigned __int64 mask) PEXT r64a, r64b, reg/m64";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class SseIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_add_ps", (Func<object, object, object>)mm_add_ps);
            RegisterFunction("mm_add_ss", (Func<object, object, object>)mm_add_ss);
            RegisterFunction("mm_and_ps", (Func<object, object, object>)mm_and_ps);
            RegisterFunction("mm_andnot_ps", (Func<object, object, object>)mm_andnot_ps);
            RegisterFunction("mm_cmpeq_ps", (Func<object, object, object>)mm_cmpeq_ps);
            RegisterFunction("mm_cmpeq_ss", (Func<object, object, object>)mm_cmpeq_ss);
            RegisterFunction("mm_cmpge_ps", (Func<object, object, object>)mm_cmpge_ps);
            RegisterFunction("mm_cmpge_ss", (Func<object, object, object>)mm_cmpge_ss);
            RegisterFunction("mm_cmpgt_ps", (Func<object, object, object>)mm_cmpgt_ps);
            RegisterFunction("mm_cmpgt_ss", (Func<object, object, object>)mm_cmpgt_ss);
            RegisterFunction("mm_cmple_ps", (Func<object, object, object>)mm_cmple_ps);
            RegisterFunction("mm_cmple_ss", (Func<object, object, object>)mm_cmple_ss);
            RegisterFunction("mm_cmplt_ps", (Func<object, object, object>)mm_cmplt_ps);
            RegisterFunction("mm_cmplt_ss", (Func<object, object, object>)mm_cmplt_ss);
            RegisterFunction("mm_cmpneq_ps", (Func<object, object, object>)mm_cmpneq_ps);
            RegisterFunction("mm_cmpneq_ss", (Func<object, object, object>)mm_cmpneq_ss);
            RegisterFunction("mm_cmpnge_ps", (Func<object, object, object>)mm_cmpnge_ps);
            RegisterFunction("mm_cmpnge_ss", (Func<object, object, object>)mm_cmpnge_ss);
            RegisterFunction("mm_cmpngt_ps", (Func<object, object, object>)mm_cmpngt_ps);
            RegisterFunction("mm_cmpngt_ss", (Func<object, object, object>)mm_cmpngt_ss);
            RegisterFunction("mm_cmpnle_ps", (Func<object, object, object>)mm_cmpnle_ps);
            RegisterFunction("mm_cmpnle_ss", (Func<object, object, object>)mm_cmpnle_ss);
            RegisterFunction("mm_cmpnlt_ps", (Func<object, object, object>)mm_cmpnlt_ps);
            RegisterFunction("mm_cmpnlt_ss", (Func<object, object, object>)mm_cmpnlt_ss);
            RegisterFunction("mm_cmpord_ps", (Func<object, object, object>)mm_cmpord_ps);
            RegisterFunction("mm_cmpord_ss", (Func<object, object, object>)mm_cmpord_ss);
            RegisterFunction("mm_cmpunord_ps", (Func<object, object, object>)mm_cmpunord_ps);
            RegisterFunction("mm_cmpunord_ss", (Func<object, object, object>)mm_cmpunord_ss);
            RegisterFunction("mm_comieq_ss", (Func<object, object, bool>)mm_comieq_ss);
            RegisterFunction("mm_comige_ss", (Func<object, object, bool>)mm_comige_ss);
            RegisterFunction("mm_comigt_ss", (Func<object, object, bool>)mm_comigt_ss);
            RegisterFunction("mm_comile_ss", (Func<object, object, bool>)mm_comile_ss);
            RegisterFunction("mm_comilt_ss", (Func<object, object, bool>)mm_comilt_ss);
            RegisterFunction("mm_comineq_ss", (Func<object, object, bool>)mm_comineq_ss);
            RegisterFunction("mm_cvtsi32_ss", (Func<object, int, object>)mm_cvtsi32_ss);
            RegisterFunction("mm_cvtss_si32", (Func<object, int>)mm_cvtss_si32);
            RegisterFunction("mm_cvttss_si32", (Func<object, int>)mm_cvttss_si32);
            RegisterFunction("mm_div_ps", (Func<object, object, object>)mm_div_ps);
            RegisterFunction("mm_div_ss", (Func<object, object, object>)mm_div_ss);
            RegisterFunction("mm_max_ps", (Func<object, object, object>)mm_max_ps);
            RegisterFunction("mm_max_ss", (Func<object, object, object>)mm_max_ss);
            RegisterFunction("mm_min_ps", (Func<object, object, object>)mm_min_ps);
            RegisterFunction("mm_min_ss", (Func<object, object, object>)mm_min_ss);
            RegisterFunction("mm_move_ss", (Func<object, object, object>)mm_move_ss);
            RegisterFunction("mm_movehl_ps", (Func<object, object, object>)mm_movehl_ps);
            RegisterFunction("mm_movelh_ps", (Func<object, object, object>)mm_movelh_ps);
            RegisterFunction("mm_movemask_ps", (Func<object, int>)mm_movemask_ps);
            RegisterFunction("mm_mul_ps", (Func<object, object, object>)mm_mul_ps);
            RegisterFunction("mm_mul_ss", (Func<object, object, object>)mm_mul_ss);
            RegisterFunction("mm_or_ps", (Func<object, object, object>)mm_or_ps);
            RegisterFunction("mm_rcp_ps", (Func<object, object>)mm_rcp_ps);
            RegisterFunction("mm_rcp_ss", (Func<object, object, object>)mm_rcp_ss);
            RegisterFunction("mm_rsqrt_ps", (Func<object, object>)mm_rsqrt_ps);
            RegisterFunction("mm_rsqrt_ss", (Func<object, object, object>)mm_rsqrt_ss);
            RegisterFunction("mm_shuffle_ps", (Func<object, object, byte, object>)mm_shuffle_ps);
            RegisterFunction("mm_sqrt_ps", (Func<object, object>)mm_sqrt_ps);
            RegisterFunction("mm_sqrt_ss", (Func<object, object, object>)mm_sqrt_ss);
            RegisterFunction("mm_sub_ps", (Func<object, object, object>)mm_sub_ps);
            RegisterFunction("mm_sub_ss", (Func<object, object, object>)mm_sub_ss);
            RegisterFunction("mm_ucomieq_ss", (Func<object, object, bool>)mm_ucomieq_ss);
            RegisterFunction("mm_ucomige_ss", (Func<object, object, bool>)mm_ucomige_ss);
            RegisterFunction("mm_ucomigt_ss", (Func<object, object, bool>)mm_ucomigt_ss);
            RegisterFunction("mm_ucomile_ss", (Func<object, object, bool>)mm_ucomile_ss);
            RegisterFunction("mm_ucomilt_ss", (Func<object, object, bool>)mm_ucomilt_ss);
            RegisterFunction("mm_ucomineq_ss", (Func<object, object, bool>)mm_ucomineq_ss);
            RegisterFunction("mm_unpackhi_ps", (Func<object, object, object>)mm_unpackhi_ps);
            RegisterFunction("mm_unpacklo_ps", (Func<object, object, object>)mm_unpacklo_ps);
            RegisterFunction("mm_xor_ps", (Func<object, object, object>)mm_xor_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_add_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Add packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_add_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Add the lower single-precision (32-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_and_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_andnot_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in ""a"" and then AND with ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for equality, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for equality, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpge_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpge_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpgt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpgt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmple_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmple_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmplt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmplt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpneq_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpneq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnge_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnge_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpngt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpngt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnle_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnle_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpord_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpord_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpunord_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpunord_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comieq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for equality, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comige_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for greater-than-or-equal, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comigt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for greater-than, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comile_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for less-than-or-equal, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comilt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for less-than, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comineq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for not-equal, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsi32_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the 32-bit integer ""b"" to a single-precision (32-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtss_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""a"" to a 32-bit integer, and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvttss_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""a"" to a 32-bit integer with truncation, and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_div_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Divide packed single-precision (32-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_div_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Divide the lower single-precision (32-bit) floating-point element in ""a"" by the lower single-precision (32-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"", store the maximum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"", store the minimum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_move_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Move the lower single-precision (32-bit) floating-point element from ""b"" to the lower element of ""dst"", and copy the upper 3 elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movehl_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Move the upper 2 single-precision (32-bit) floating-point elements from ""b"" to the lower 2 elements of ""dst"", and copy the upper 2 elements from ""a"" to the upper 2 elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movelh_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Move the lower 2 single-precision (32-bit) floating-point elements from ""b"" to the upper 2 elements of ""dst"", and copy the lower 2 elements from ""a"" to the lower 2 elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movemask_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Set each bit of mask ""dst"" based on the most significant bit of the corresponding packed single-precision (32-bit) floating-point element in ""a"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mul_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Multiply packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mul_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Multiply the lower single-precision (32-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_or_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_rcp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_rcp_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_rsqrt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_rsqrt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_shuffle_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Shuffle single-precision (32-bit) floating-point elements in ""a"" using the control in ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"unsigned int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sqrt_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sqrt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the square root of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Subtract packed single-precision (32-bit) floating-point elements in ""b"" from packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sub_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Subtract the lower single-precision (32-bit) floating-point element in ""b"" from the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomieq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomige_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomigt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomile_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomilt_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomineq_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point element in ""a"" and ""b"" for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_unpackhi_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the high half ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_unpacklo_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the low half of ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_xor_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse2IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_add_epi8", (Func<object, object, object>)mm_add_epi8);
            RegisterFunction("mm_add_sd", (Func<object, object, object>)mm_add_sd);
            RegisterFunction("mm_adds_epi8", (Func<object, object, object>)mm_adds_epi8);
            RegisterFunction("mm_and_si128", (Func<object, object, object>)mm_and_si128);
            RegisterFunction("mm_andnot_si128", (Func<object, object, object>)mm_andnot_si128);
            RegisterFunction("mm_avg_epu8", (Func<object, object, object>)mm_avg_epu8);
            RegisterFunction("mm_bslli_si128", (Func<object, byte, object>)mm_bslli_si128);
            RegisterFunction("mm_bsrli_si128", (Func<object, byte, object>)mm_bsrli_si128);
            RegisterFunction("mm_cmpeq_epi8", (Func<object, object, object>)mm_cmpeq_epi8);
            RegisterFunction("mm_cmpeq_sd", (Func<object, object, object>)mm_cmpeq_sd);
            RegisterFunction("mm_cmpge_pd", (Func<object, object, object>)mm_cmpge_pd);
            RegisterFunction("mm_cmpge_sd", (Func<object, object, object>)mm_cmpge_sd);
            RegisterFunction("mm_cmpgt_epi8", (Func<object, object, object>)mm_cmpgt_epi8);
            RegisterFunction("mm_cmpgt_sd", (Func<object, object, object>)mm_cmpgt_sd);
            RegisterFunction("mm_cmple_pd", (Func<object, object, object>)mm_cmple_pd);
            RegisterFunction("mm_cmple_sd", (Func<object, object, object>)mm_cmple_sd);
            RegisterFunction("mm_cmplt_epi8", (Func<object, object, object>)mm_cmplt_epi8);
            RegisterFunction("mm_cmplt_sd", (Func<object, object, object>)mm_cmplt_sd);
            RegisterFunction("mm_cmpneq_pd", (Func<object, object, object>)mm_cmpneq_pd);
            RegisterFunction("mm_cmpneq_sd", (Func<object, object, object>)mm_cmpneq_sd);
            RegisterFunction("mm_cmpnge_pd", (Func<object, object, object>)mm_cmpnge_pd);
            RegisterFunction("mm_cmpnge_sd", (Func<object, object, object>)mm_cmpnge_sd);
            RegisterFunction("mm_cmpngt_pd", (Func<object, object, object>)mm_cmpngt_pd);
            RegisterFunction("mm_cmpngt_sd", (Func<object, object, object>)mm_cmpngt_sd);
            RegisterFunction("mm_cmpnle_pd", (Func<object, object, object>)mm_cmpnle_pd);
            RegisterFunction("mm_cmpnle_sd", (Func<object, object, object>)mm_cmpnle_sd);
            RegisterFunction("mm_cmpnlt_pd", (Func<object, object, object>)mm_cmpnlt_pd);
            RegisterFunction("mm_cmpnlt_sd", (Func<object, object, object>)mm_cmpnlt_sd);
            RegisterFunction("mm_cmpord_pd", (Func<object, object, object>)mm_cmpord_pd);
            RegisterFunction("mm_cmpord_sd", (Func<object, object, object>)mm_cmpord_sd);
            RegisterFunction("mm_cmpunord_pd", (Func<object, object, object>)mm_cmpunord_pd);
            RegisterFunction("mm_cmpunord_sd", (Func<object, object, object>)mm_cmpunord_sd);
            RegisterFunction("mm_comieq_sd", (Func<object, object, bool>)mm_comieq_sd);
            RegisterFunction("mm_comige_sd", (Func<object, object, bool>)mm_comige_sd);
            RegisterFunction("mm_comigt_sd", (Func<object, object, bool>)mm_comigt_sd);
            RegisterFunction("mm_comile_sd", (Func<object, object, bool>)mm_comile_sd);
            RegisterFunction("mm_comilt_sd", (Func<object, object, bool>)mm_comilt_sd);
            RegisterFunction("mm_comineq_sd", (Func<object, object, bool>)mm_comineq_sd);
            RegisterFunction("mm_cvtepi32_pd", (Func<object, object>)mm_cvtepi32_pd);
            RegisterFunction("mm_cvtepi32_ps", (Func<object, object>)mm_cvtepi32_ps);
            RegisterFunction("mm_cvtps_epi32", (Func<object, object>)mm_cvtps_epi32);
            RegisterFunction("mm_cvtsd_si32", (Func<object, int>)mm_cvtsd_si32);
            RegisterFunction("mm_cvtsd_ss", (Func<object, object, object>)mm_cvtsd_ss);
            RegisterFunction("mm_cvtsi128_si32", (Func<object, uint>)mm_cvtsi128_si32);
            RegisterFunction("mm_cvtsi32_sd", (Func<object, int, object>)mm_cvtsi32_sd);
            RegisterFunction("mm_cvtsi32_si128", (Func<int, object>)mm_cvtsi32_si128);
            RegisterFunction("mm_cvttps_epi32", (Func<object, object>)mm_cvttps_epi32);
            RegisterFunction("mm_cvttsd_si32", (Func<object, int>)mm_cvttsd_si32);
            RegisterFunction("mm_div_pd", (Func<object, object, object>)mm_div_pd);
            RegisterFunction("mm_div_sd", (Func<object, object, object>)mm_div_sd);
            RegisterFunction("mm_extract_epi16", (Func<object, byte, ushort>)mm_extract_epi16);
            RegisterFunction("mm_insert_epi16", (Func<object, short, byte, object>)mm_insert_epi16);
            RegisterFunction("mm_madd_epi16", (Func<object, object, object>)mm_madd_epi16);
            RegisterFunction("mm_max_epu8", (Func<object, object, object>)mm_max_epu8);
            RegisterFunction("mm_max_sd", (Func<object, object, object>)mm_max_sd);
            RegisterFunction("mm_min_epu8", (Func<object, object, object>)mm_min_epu8);
            RegisterFunction("mm_min_sd", (Func<object, object, object>)mm_min_sd);
            RegisterFunction("mm_move_epi64", (Func<object, object>)mm_move_epi64);
            RegisterFunction("mm_move_sd", (Func<object, object, object>)mm_move_sd);
            RegisterFunction("mm_movemask_epi8", (Func<object, int>)mm_movemask_epi8);
            RegisterFunction("mm_mul_epu32", (Func<object, object, object>)mm_mul_epu32);
            RegisterFunction("mm_mul_sd", (Func<object, object, object>)mm_mul_sd);
            RegisterFunction("mm_mulhi_epi16", (Func<object, object, object>)mm_mulhi_epi16);
            RegisterFunction("mm_mullo_epi16", (Func<object, object, object>)mm_mullo_epi16);
            RegisterFunction("mm_or_si128", (Func<object, object, object>)mm_or_si128);
            RegisterFunction("mm_packs_epi16", (Func<object, object, object>)mm_packs_epi16);
            RegisterFunction("mm_packus_epi16", (Func<object, object, object>)mm_packus_epi16);
            RegisterFunction("mm_sad_epu8", (Func<object, object, object>)mm_sad_epu8);
            RegisterFunction("mm_shuffle_epi32", (Func<object, byte, object>)mm_shuffle_epi32);
            RegisterFunction("mm_shuffle_pd", (Func<object, object, byte, object>)mm_shuffle_pd);
            RegisterFunction("mm_shufflehi_epi16", (Func<object, byte, object>)mm_shufflehi_epi16);
            RegisterFunction("mm_shufflelo_epi16", (Func<object, byte, object>)mm_shufflelo_epi16);
            RegisterFunction("mm_sll_epi16", (Func<object, object, object>)mm_sll_epi16);
            RegisterFunction("mm_sqrt_pd", (Func<object, object>)mm_sqrt_pd);
            RegisterFunction("mm_sqrt_sd", (Func<object, object>)mm_sqrt_sd);
            RegisterFunction("mm_sra_epi16", (Func<object, object, object>)mm_sra_epi16);
            RegisterFunction("mm_srl_epi16", (Func<object, object, object>)mm_srl_epi16);
            RegisterFunction("mm_sub_epi8", (Func<object, object, object>)mm_sub_epi8);
            RegisterFunction("mm_sub_sd", (Func<object, object, object>)mm_sub_sd);
            RegisterFunction("mm_subs_epi8", (Func<object, object, object>)mm_subs_epi8);
            RegisterFunction("mm_ucomieq_sd", (Func<object, object, bool>)mm_ucomieq_sd);
            RegisterFunction("mm_ucomige_sd", (Func<object, object, bool>)mm_ucomige_sd);
            RegisterFunction("mm_ucomigt_sd", (Func<object, object, bool>)mm_ucomigt_sd);
            RegisterFunction("mm_ucomile_sd", (Func<object, object, bool>)mm_ucomile_sd);
            RegisterFunction("mm_ucomilt_sd", (Func<object, object, bool>)mm_ucomilt_sd);
            RegisterFunction("mm_ucomineq_sd", (Func<object, object, bool>)mm_ucomineq_sd);
            RegisterFunction("mm_unpackhi_epi8", (Func<object, object, object>)mm_unpackhi_epi8);
            RegisterFunction("mm_unpacklo_epi8", (Func<object, object, object>)mm_unpacklo_epi8);
            RegisterFunction("mm_xor_si128", (Func<object, object, object>)mm_xor_si128);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_add_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_add_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add the lower double-precision (64-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_adds_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_and_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_andnot_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise NOT of 128 bits (representing integer data) in ""a"" and then AND with ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_avg_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Average packed unsigned 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_bslli_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift ""a"" left by ""imm8"" bytes while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_bsrli_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift ""a"" right by ""imm8"" bytes while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for equality, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpge_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpge_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpgt_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpgt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmple_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmple_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmplt_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for less-than, and store the results in ""dst"". Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmplt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpneq_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpneq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnge_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnge_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpngt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpngt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnle_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnle_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpord_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpord_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpunord_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpunord_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comieq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for equality, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comige_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for greater-than-or-equal, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comigt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for greater-than, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comile_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for less-than-or-equal, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comilt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for less-than, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_comineq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for not-equal, and return the boolean result (0 or 1).";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtepi32_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 32-bit integers in ""a"" to packed double-precision (64-bit) floating-point elements, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtepi32_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 32-bit integers in ""a"" to packed single-precision (32-bit) floating-point elements, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtps_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed 32-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsd_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""a"" to a 32-bit integer, and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsd_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""b"" to a single-precision (32-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsi128_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy the lower 32-bit integer in ""a"" to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsi32_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the 32-bit integer ""b"" to a double-precision (64-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsi32_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy 32-bit integer ""a"" to the lower elements of ""dst"", and zero the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvttps_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed single-precision (32-bit) floating-point elements in ""a"" to packed 32-bit integers with truncation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvttsd_si32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""a"" to a 32-bit integer with truncation, and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_div_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Divide packed double-precision (64-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_div_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Divide the lower double-precision (64-bit) floating-point element in ""a"" by the lower double-precision (64-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_extract_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Extract a 16-bit integer from ""a"", selected with ""imm8"", and store the result in the lower element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_insert_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy ""a"" to ""dst"", and insert the 16-bit integer ""i"" into ""dst"" at the location specified by ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("i", @"int")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_madd_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply packed signed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed unsigned 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"", store the maximum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare packed unsigned 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"", store the minimum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_move_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy the lower 64-bit integer in ""a"" to the lower element of ""dst"", and zero the upper element.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_move_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Move the lower double-precision (64-bit) floating-point element from ""b"" to the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movemask_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Create mask from the most significant bit of each 8-bit element in ""a"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mul_epu32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the low unsigned 32-bit integers from each packed 64-bit element in ""a"" and ""b"", and store the unsigned 64-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mul_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the lower double-precision (64-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mulhi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mullo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_or_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise OR of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_packs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 16-bit integers from ""a"" and ""b"" to packed 8-bit integers using signed saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_packus_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert packed 16-bit integers from ""a"" and ""b"" to packed 8-bit integers using unsigned saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sad_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the absolute differences of packed unsigned 8-bit integers in ""a"" and ""b"", then horizontally sum each consecutive 8 differences to produce two unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_shuffle_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shuffle 32-bit integers in ""a"" using the control in ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_shuffle_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shuffle double-precision (64-bit) floating-point elements using the control in ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_shufflehi_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shuffle 16-bit integers in the high 64 bits of ""a"" using the control in ""imm8"". Store the results in the high 64 bits of ""dst"", with the low 64 bits being copied from from ""a"" to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_shufflelo_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shuffle 16-bit integers in the low 64 bits of ""a"" using the control in ""imm8"". Store the results in the low 64 bits of ""dst"", with the high 64 bits being copied from from ""a"" to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sll_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sqrt_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the square root of packed double-precision (64-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sqrt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the square root of the lower double-precision (64-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sra_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""count"" while shifting in sign bits, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_srl_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sub_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sub_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract the lower double-precision (64-bit) floating-point element in ""b"" from the lower double-precision (64-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_subs_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"" using saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomieq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for equality, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomige_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for greater-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomigt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for greater-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomile_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for less-than-or-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomilt_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for less-than, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ucomineq_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point element in ""a"" and ""b"" for not-equal, and return the boolean result (0 or 1). This instruction will not signal an exception for QNaNs.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_unpackhi_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the high half of ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_unpacklo_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the low half of ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_xor_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Compute the bitwise XOR of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse2X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_cvtsd_si64", (Func<object, long>)mm_cvtsd_si64);
            RegisterFunction("mm_cvtsi128_si64", (Func<object, ulong>)mm_cvtsi128_si64);
            RegisterFunction("mm_cvtsi64_sd", (Func<object, long, object>)mm_cvtsi64_sd);
            RegisterFunction("mm_cvtsi64_si128", (Func<long, object>)mm_cvtsi64_si128);
            RegisterFunction("mm_cvttsd_si64", (Func<object, long>)mm_cvttsd_si64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_cvtsd_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""a"" to a 64-bit integer, and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsi128_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy the lower 64-bit integer in ""a"" to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsi64_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the 64-bit integer ""b"" to a double-precision (64-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__int64")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtsi64_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Copy 64-bit integer ""a"" to the lower element of ""dst"", and zero the upper element.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__int64")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvttsd_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE2";
                descriptor.Description = @"Convert the lower double-precision (64-bit) floating-point element in ""a"" to a 64-bit integer with truncation, and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse3IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_addsub_ps", (Func<object, object, object>)mm_addsub_ps);
            RegisterFunction("mm_hadd_ps", (Func<object, object, object>)mm_hadd_ps);
            RegisterFunction("mm_hsub_ps", (Func<object, object, object>)mm_hsub_ps);
            RegisterFunction("mm_movedup_pd", (Func<object, object>)mm_movedup_pd);
            RegisterFunction("mm_movehdup_ps", (Func<object, object>)mm_movehdup_ps);
            RegisterFunction("mm_moveldup_ps", (Func<object, object>)mm_moveldup_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_addsub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Alternatively add and subtract packed single-precision (32-bit) floating-point elements in ""a"" to/from packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hadd_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hsub_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movedup_pd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Duplicate the low double-precision (64-bit) floating-point element from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movehdup_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Duplicate odd-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_moveldup_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE3";
                descriptor.Description = @"Duplicate even-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse41IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_blend_epi16", (Func<object, object, byte, object>)mm_blend_epi16);
            RegisterFunction("mm_blendv_epi8", (Func<object, object, object, object>)mm_blendv_epi8);
            RegisterFunction("mm_ceil_ps", (Func<object, object>)mm_ceil_ps);
            RegisterFunction("mm_ceil_sd", (Func<object, object>)mm_ceil_sd);
            RegisterFunction("mm_cmpeq_epi64", (Func<object, object, object>)mm_cmpeq_epi64);
            RegisterFunction("mm_cvtepi8_epi16", (Func<object, object>)mm_cvtepi8_epi16);
            RegisterFunction("mm_cvtepi8_epi32", (Func<object, object>)mm_cvtepi8_epi32);
            RegisterFunction("mm_cvtepi8_epi64", (Func<object, object>)mm_cvtepi8_epi64);
            RegisterFunction("mm_dp_ps", (Func<object, object, byte, object>)mm_dp_ps);
            RegisterFunction("mm_extract_epi8", (Func<object, byte, byte>)mm_extract_epi8);
            RegisterFunction("mm_floor_ps", (Func<object, object>)mm_floor_ps);
            RegisterFunction("mm_floor_sd", (Func<object, object>)mm_floor_sd);
            RegisterFunction("mm_insert_epi8", (Func<object, sbyte, byte, object>)mm_insert_epi8);
            RegisterFunction("mm_max_epi8", (Func<object, object, object>)mm_max_epi8);
            RegisterFunction("mm_min_epi8", (Func<object, object, object>)mm_min_epi8);
            RegisterFunction("mm_minpos_epu16", (Func<object, object>)mm_minpos_epu16);
            RegisterFunction("mm_mpsadbw_epu8", (Func<object, object, byte, object>)mm_mpsadbw_epu8);
            RegisterFunction("mm_mul_epi32", (Func<object, object, object>)mm_mul_epi32);
            RegisterFunction("mm_mullo_epi32", (Func<object, object, object>)mm_mullo_epi32);
            RegisterFunction("mm_packus_epi32", (Func<object, object, object>)mm_packus_epi32);
            RegisterFunction("mm_round_ps", (Func<object, object>)mm_round_ps);
            RegisterFunction("mm_round_sd", (Func<object, object>)mm_round_sd);
            RegisterFunction("mm_testc_si128", (Func<object, object, bool>)mm_testc_si128);
            RegisterFunction("mm_testnzc_si128", (Func<object, object, bool>)mm_testnzc_si128);
            RegisterFunction("mm_testz_si128", (Func<object, object, bool>)mm_testz_si128);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_blend_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Blend packed 16-bit integers from ""a"" and ""b"" using control mask ""imm8"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_blendv_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Blend packed 8-bit integers from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("mask", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ceil_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" up to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ceil_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" up to an integer value, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed 64-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtepi8_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 8-bit integers in ""a"" to packed 16-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtepi8_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 8-bit integers in ""a"" to packed 32-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtepi8_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Sign extend packed 8-bit integers in the low 8 bytes of ""a"" to packed 64-bit integers, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_dp_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Conditionally multiply the packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" using the high 4 bits in ""imm8"", sum the four products, and conditionally store the sum in ""dst"" using the low 4 bits of ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_extract_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Extract an 8-bit integer from ""a"", selected with ""imm8"", and store the result in the lower element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_floor_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" down to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_floor_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" down to an integer value, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_insert_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Copy ""a"" to ""dst"", and insert the lower 8-bit integer from ""i"" into ""dst"" at the location specified by ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("i", @"int")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_minpos_epu16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Horizontally compute the minimum amongst the packed unsigned 16-bit integers in ""a"", store the minimum and index in ""dst"", and zero the remaining bits in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mpsadbw_epu8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in ""a"" compared to those in ""b"", and store the 16-bit results in ""dst"". 	Eight SADs are performed using one quadruplet from ""b"" and eight quadruplets from ""a"". One quadruplet is selected from ""b"" starting at on the offset specified in ""imm8"". Eight quadruplets are formed from sequential 8-bit integers selected from ""a"" starting at the offset specified in ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mul_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Multiply the low 32-bit integers from each packed 64-bit element in ""a"" and ""b"", and store the signed 64-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mullo_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Multiply the packed 32-bit integers in ""a"" and ""b"", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_packus_epi32"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Convert packed 32-bit integers from ""a"" and ""b"" to packed 16-bit integers using unsigned saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_round_ps"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("rounding", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_round_sd"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("rounding", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_testc_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return the ""CF"" value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_testnzc_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return 1 if both the ""ZF"" and ""CF"" values are zero, otherwise return 0.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_testz_si128"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and set ""ZF"" to 1 if the result is zero, otherwise set ""ZF"" to 0. Compute the bitwise NOT of ""a"" and then AND with ""b"", and set ""CF"" to 1 if the result is zero, otherwise set ""CF"" to 0. Return the ""ZF"" value.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse41X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_extract_epi64", (Func<object, byte, long>)mm_extract_epi64);
            RegisterFunction("mm_insert_epi64", (Func<object, long, byte, object>)mm_insert_epi64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_extract_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Extract a 64-bit integer from ""a"", selected with ""imm8"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_insert_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE41";
                descriptor.Description = @"Copy ""a"" to ""dst"", and insert the 64-bit integer ""i"" into ""dst"" at the location specified by ""imm8"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("i", @"__int64")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("imm8", @"const int")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse42IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_cmpgt_epi64", (Func<object, object, object>)mm_cmpgt_epi64);
            RegisterFunction("mm_crc32_u8", (Func<uint, byte, uint>)mm_crc32_u8);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_cmpgt_epi64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE42";
                descriptor.Description = @"Compare packed 64-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_crc32_u8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE42";
                descriptor.Description = @"Starting with the initial value in ""crc"", accumulates a CRC32 value for unsigned 8-bit integer ""v"", and stores the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("crc", @"unsigned int")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("v", @"unsigned char")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse42X64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_crc32_u64", (Func<ulong, ulong, ulong>)mm_crc32_u64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_crc32_u64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE42";
                descriptor.Description = @"Starting with the initial value in ""crc"", accumulates a CRC32 value for unsigned 64-bit integer ""v"", and stores the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("crc", @"unsigned __int64")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("v", @"unsigned __int64")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class SseX64IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_cvtsi64_ss", (Func<object, long, object>)mm_cvtsi64_ss);
            RegisterFunction("mm_cvtss_si64", (Func<object, long>)mm_cvtss_si64);
            RegisterFunction("mm_cvttss_si64", (Func<object, long>)mm_cvttss_si64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_cvtsi64_ss"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the 64-bit integer ""b"" to a single-precision (32-bit) floating-point element, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__int64")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvtss_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""a"" to a 64-bit integer, and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cvttss_si64"];
                descriptor.Category = "Vector Hardware Intrinsics / SSE";
                descriptor.Description = @"Convert the lower single-precision (32-bit) floating-point element in ""a"" to a 64-bit integer with truncation, and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Ssse3IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_abs_epi8", (Func<object, object>)mm_abs_epi8);
            RegisterFunction("mm_alignr_epi8", (Func<object, object, byte, object>)mm_alignr_epi8);
            RegisterFunction("mm_hadd_epi16", (Func<object, object, object>)mm_hadd_epi16);
            RegisterFunction("mm_hadds_epi16", (Func<object, object, object>)mm_hadds_epi16);
            RegisterFunction("mm_hsub_epi16", (Func<object, object, object>)mm_hsub_epi16);
            RegisterFunction("mm_hsubs_epi16", (Func<object, object, object>)mm_hsubs_epi16);
            RegisterFunction("mm_maddubs_epi16", (Func<object, object, object>)mm_maddubs_epi16);
            RegisterFunction("mm_mulhrs_epi16", (Func<object, object, object>)mm_mulhrs_epi16);
            RegisterFunction("mm_shuffle_epi8", (Func<object, object, object>)mm_shuffle_epi8);
            RegisterFunction("mm_sign_epi8", (Func<object, object, object>)mm_sign_epi8);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_abs_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Compute the absolute value of packed 8-bit integers in ""a"", and store the unsigned results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_alignr_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Concatenate 16-byte blocks in ""a"" and ""b"" into a 32-byte temporary result, shift the result right by ""count"" bytes, and store the low 16 bytes in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hadd_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hadds_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hsub_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hsubs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_maddubs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Vertically multiply each unsigned 8-bit integer from ""a"" with the corresponding signed 8-bit integer from ""b"", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mulhrs_epi16"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Multiply packed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_shuffle_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Shuffle packed 8-bit integers in ""a"" according to shuffle control mask in the corresponding 8-bit element of ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sign_epi8"];
                descriptor.Category = "Vector Hardware Intrinsics / SSSE3";
                descriptor.Description = @"Negate packed 8-bit integers in ""a"" when the corresponding signed 8-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
        }        
    }
}
