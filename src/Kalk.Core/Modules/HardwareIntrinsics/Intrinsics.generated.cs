//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Date: 24 May 2020
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AesIntrinsicsModule
    {
        /// <summary>
        /// __m128i _mm_aesdec_si128 (__m128i a, __m128i RoundKey) AESDEC xmm, xmm/m128
        /// </summary>
        public object mm_aesdec_si128(object value, object roundKey) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, roundKey, System.Runtime.Intrinsics.X86.Aes.Decrypt);

        /// <summary>
        /// __m128i _mm_aesdeclast_si128 (__m128i a, __m128i RoundKey) AESDECLAST xmm, xmm/m128
        /// </summary>
        public object mm_aesdeclast_si128(object value, object roundKey) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, roundKey, System.Runtime.Intrinsics.X86.Aes.DecryptLast);

        /// <summary>
        /// __m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey) AESENC xmm, xmm/m128
        /// </summary>
        public object mm_aesenc_si128(object value, object roundKey) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, roundKey, System.Runtime.Intrinsics.X86.Aes.Encrypt);

        /// <summary>
        /// __m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey) AESENCLAST xmm, xmm/m128
        /// </summary>
        public object mm_aesenclast_si128(object value, object roundKey) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, roundKey, System.Runtime.Intrinsics.X86.Aes.EncryptLast);

        /// <summary>
        /// __m128i _mm_aesimc_si128 (__m128i a) AESIMC xmm, xmm/m128
        /// </summary>
        public object mm_aesimc_si128(object value) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(value, System.Runtime.Intrinsics.X86.Aes.InverseMixColumns);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AvxIntrinsicsModule
    {
        /// <summary>
        /// Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_add_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Add);

        /// <summary>
        /// Alternatively add and subtract packed single-precision (32-bit) floating-point elements in "a" to/from packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm256_addsub_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.AddSubtract);

        /// <summary>
        /// Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_and_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.And);

        /// <summary>
        /// Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in "a" and then AND with "b", and store the results in "dst".
        /// </summary>
        public object mm256_andnot_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.AndNot);

        /// <summary>
        /// Blend packed single-precision (32-bit) floating-point elements from "a" and "b" using "mask", and store the results in "dst".
        /// </summary>
        public object mm256_blendv_ps(object a, object b, object mask) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, mask, System.Runtime.Intrinsics.X86.Avx.BlendVariable);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" up to an integer value, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm256_ceil_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.Ceiling);

        /// <summary>
        /// Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm256_div_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Divide);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" down to an integer value, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm256_floor_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.Floor);

        /// <summary>
        /// Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in "a" and "b", and pack the results in "dst".
        /// </summary>
        public object mm256_hadd_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.HorizontalAdd);

        /// <summary>
        /// Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in "a" and "b", and pack the results in "dst".
        /// </summary>
        public object mm256_hsub_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.HorizontalSubtract);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm256_max_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Max);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm256_min_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Min);

        /// <summary>
        /// Duplicate odd-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
        /// </summary>
        public object mm256_movehdup_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.DuplicateOddIndexed);

        /// <summary>
        /// Duplicate even-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
        /// </summary>
        public object mm256_moveldup_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.DuplicateEvenIndexed);

        /// <summary>
        /// Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_mul_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Multiply);

        /// <summary>
        /// Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_or_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Or);

        /// <summary>
        /// Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm256_rcp_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.Reciprocal);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" using the "rounding" parameter, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm256_round_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.RoundCurrentDirection);

        /// <summary>
        /// Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm256_rsqrt_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.ReciprocalSqrt);

        /// <summary>
        /// Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm256_sqrt_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, System.Runtime.Intrinsics.X86.Avx.Sqrt);

        /// <summary>
        /// Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm256_sub_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Subtract);

        /// <summary>
        /// Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_unpackhi_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.UnpackHigh);

        /// <summary>
        /// Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_unpacklo_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.UnpackLow);

        /// <summary>
        /// Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_xor_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>, float, System.Runtime.Intrinsics.Vector256<float>>(a, b, System.Runtime.Intrinsics.X86.Avx.Xor);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Avx2IntrinsicsModule
    {
        /// <summary>
        /// Broadcast the low packed 8-bit integer from "a" to all elements of "dst".
        /// </summary>
        public object mm_broadcastb_epi8(object a) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, System.Runtime.Intrinsics.X86.Avx2.BroadcastScalarToVector128);

        /// <summary>
        /// Add packed 8-bit integers in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_add_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Add);

        /// <summary>
        /// Add packed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".
        /// </summary>
        public object mm256_adds_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.AddSaturate);

        /// <summary>
        /// Compute the bitwise AND of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm256_and_si256(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.And);

        /// <summary>
        /// Compute the bitwise NOT of 256 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".
        /// </summary>
        public object mm256_andnot_si256(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.AndNot);

        /// <summary>
        /// Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_avg_epu8(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector256<byte>, byte, System.Runtime.Intrinsics.Vector256<byte>, byte, System.Runtime.Intrinsics.Vector256<byte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Average);

        /// <summary>
        /// Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".
        /// </summary>
        public object mm256_blendv_epi8(object a, object b, object mask) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, mask, System.Runtime.Intrinsics.X86.Avx2.BlendVariable);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".
        /// </summary>
        public object mm256_cmpeq_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.CompareEqual);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".
        /// </summary>
        public object mm256_cmpgt_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.CompareGreaterThan);

        /// <summary>
        /// Horizontally add adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm256_hadd_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.HorizontalAdd);

        /// <summary>
        /// Horizontally add adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm256_hadds_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.HorizontalAddSaturate);

        /// <summary>
        /// Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm256_hsub_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.HorizontalSubtract);

        /// <summary>
        /// Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm256_hsubs_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.HorizontalSubtractSaturate);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm256_max_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Max);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm256_min_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Min);

        /// <summary>
        /// Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm256_mulhi_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.MultiplyHigh);

        /// <summary>
        /// Multiply packed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst".
        /// </summary>
        public object mm256_mulhrs_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.MultiplyHighRoundScale);

        /// <summary>
        /// Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm256_mullo_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>, short, System.Runtime.Intrinsics.Vector256<short>>(a, b, System.Runtime.Intrinsics.X86.Avx2.MultiplyLow);

        /// <summary>
        /// Compute the bitwise OR of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm256_or_si256(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Or);

        /// <summary>
        /// Shuffle 32-bit integers in "a" across lanes using the corresponding index in "idx", and store the results in "dst".
        /// </summary>
        public object mm256_permutevar8x32_epi32(object a, object idx) => ProcessArgs<int, System.Runtime.Intrinsics.Vector256<int>, int, System.Runtime.Intrinsics.Vector256<int>, int, System.Runtime.Intrinsics.Vector256<int>>(a, idx, System.Runtime.Intrinsics.X86.Avx2.PermuteVar8x32);

        /// <summary>
        /// Shuffle 8-bit integers in "a" within 128-bit lanes according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".
        /// </summary>
        public object mm256_shuffle_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Shuffle);

        /// <summary>
        /// Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.
        /// </summary>
        public object mm256_sign_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Sign);

        /// <summary>
        /// Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".
        /// </summary>
        public object mm256_sub_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Subtract);

        /// <summary>
        /// Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".
        /// </summary>
        public object mm256_subs_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.SubtractSaturate);

        /// <summary>
        /// Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_unpackhi_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.UnpackHigh);

        /// <summary>
        /// Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm256_unpacklo_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.UnpackLow);

        /// <summary>
        /// Compute the bitwise XOR of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm256_xor_si256(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>, sbyte, System.Runtime.Intrinsics.Vector256<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Avx2.Xor);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class SseIntrinsicsModule
    {
        /// <summary>
        /// Add packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_add_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Add);

        /// <summary>
        /// Add the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_add_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.AddScalar);

        /// <summary>
        /// Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_and_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.And);

        /// <summary>
        /// Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in "a" and then AND with "b", and store the results in "dst".
        /// </summary>
        public object mm_andnot_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.AndNot);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for equality, and store the results in "dst".
        /// </summary>
        public object mm_cmpeq_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for equality, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpeq_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for greater-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpge_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for greater-than-or-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpge_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarGreaterThanOrEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpgt_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareGreaterThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for greater-than, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpgt_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarGreaterThan);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for less-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmple_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareLessThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for less-than-or-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmple_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarLessThanOrEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for less-than, and store the results in "dst".
        /// </summary>
        public object mm_cmplt_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareLessThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for less-than, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmplt_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarLessThan);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpneq_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpneq_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-greater-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpnge_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-greater-than-or-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpnge_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotGreaterThanOrEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpngt_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotGreaterThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-greater-than, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpngt_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotGreaterThan);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpnle_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotLessThanOrEqual);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpnle_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotLessThanOrEqual);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpnlt_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareNotLessThan);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" for not-less-than, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpnlt_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarNotLessThan);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" to see if neither is NaN, and store the results in "dst".
        /// </summary>
        public object mm_cmpord_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareOrdered);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" to see if neither is NaN, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpord_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarOrdered);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b" to see if either is NaN, and store the results in "dst".
        /// </summary>
        public object mm_cmpunord_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareUnordered);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b" to see if either is NaN, store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_cmpunord_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.CompareScalarUnordered);

        /// <summary>
        /// Divide packed single-precision (32-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm_div_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Divide);

        /// <summary>
        /// Divide the lower single-precision (32-bit) floating-point element in "a" by the lower single-precision (32-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_div_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.DivideScalar);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm_max_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Max);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_max_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MaxScalar);

        /// <summary>
        /// Compare packed single-precision (32-bit) floating-point elements in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm_min_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Min);

        /// <summary>
        /// Compare the lower single-precision (32-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_min_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MinScalar);

        /// <summary>
        /// Move the lower single-precision (32-bit) floating-point element from "b" to the lower element of "dst", and copy the upper 3 elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_move_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MoveScalar);

        /// <summary>
        /// Move the upper 2 single-precision (32-bit) floating-point elements from "b" to the lower 2 elements of "dst", and copy the upper 2 elements from "a" to the upper 2 elements of "dst".
        /// </summary>
        public object mm_movehl_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MoveHighToLow);

        /// <summary>
        /// Move the lower 2 single-precision (32-bit) floating-point elements from "b" to the upper 2 elements of "dst", and copy the lower 2 elements from "a" to the lower 2 elements of "dst".
        /// </summary>
        public object mm_movelh_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MoveLowToHigh);

        /// <summary>
        /// Multiply packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_mul_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Multiply);

        /// <summary>
        /// Multiply the lower single-precision (32-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_mul_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.MultiplyScalar);

        /// <summary>
        /// Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_or_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Or);

        /// <summary>
        /// Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm_rcp_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.Reciprocal);

        /// <summary>
        /// Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm_rcp_ss(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.ReciprocalScalar);

        /// <summary>
        /// Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm_rsqrt_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.ReciprocalSqrt);

        /// <summary>
        /// Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst". The maximum relative error for this approximation is less than 1.5*2^-12.
        /// </summary>
        public object mm_rsqrt_ss(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.ReciprocalSqrtScalar);

        /// <summary>
        /// Compute the square root of packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm_sqrt_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.Sqrt);

        /// <summary>
        /// Compute the square root of the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_sqrt_ss(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse.SqrtScalar);

        /// <summary>
        /// Subtract packed single-precision (32-bit) floating-point elements in "b" from packed single-precision (32-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm_sub_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Subtract);

        /// <summary>
        /// Subtract the lower single-precision (32-bit) floating-point element in "b" from the lower single-precision (32-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper 3 packed elements from "a" to the upper elements of "dst".
        /// </summary>
        public object mm_sub_ss(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.SubtractScalar);

        /// <summary>
        /// Unpack and interleave single-precision (32-bit) floating-point elements from the high half "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_unpackhi_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.UnpackHigh);

        /// <summary>
        /// Unpack and interleave single-precision (32-bit) floating-point elements from the low half of "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_unpacklo_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.UnpackLow);

        /// <summary>
        /// Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_xor_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse.Xor);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse2IntrinsicsModule
    {
        /// <summary>
        /// Add packed 8-bit integers in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_add_epi8(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Add);

        /// <summary>
        /// Add the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_add_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.AddScalar);

        /// <summary>
        /// Add packed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".
        /// </summary>
        public object mm_adds_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.AddSaturate);

        /// <summary>
        /// Compute the bitwise AND of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm_and_si128(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.And);

        /// <summary>
        /// Compute the bitwise NOT of 128 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".
        /// </summary>
        public object mm_andnot_si128(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.AndNot);

        /// <summary>
        /// Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_avg_epu8(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Average);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".
        /// </summary>
        public object mm_cmpeq_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for equality, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpeq_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarEqual);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for greater-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpge_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for greater-than-or-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpge_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarGreaterThanOrEqual);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpgt_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareGreaterThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for greater-than, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpgt_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarGreaterThan);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for less-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmple_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareLessThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for less-than-or-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmple_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarLessThanOrEqual);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b" for less-than, and store the results in "dst". Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.
        /// </summary>
        public object mm_cmplt_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareLessThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for less-than, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmplt_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarLessThan);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpneq_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpneq_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotEqual);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-greater-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpnge_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotGreaterThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-greater-than-or-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpnge_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotGreaterThanOrEqual);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpngt_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotGreaterThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-greater-than, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpngt_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotGreaterThan);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, and store the results in "dst".
        /// </summary>
        public object mm_cmpnle_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotLessThanOrEqual);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than-or-equal, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpnle_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotLessThanOrEqual);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpnlt_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareNotLessThan);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" for not-less-than, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpnlt_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarNotLessThan);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" to see if neither is NaN, and store the results in "dst".
        /// </summary>
        public object mm_cmpord_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareOrdered);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" to see if neither is NaN, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpord_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarOrdered);

        /// <summary>
        /// Compare packed double-precision (64-bit) floating-point elements in "a" and "b" to see if either is NaN, and store the results in "dst".
        /// </summary>
        public object mm_cmpunord_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareUnordered);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b" to see if either is NaN, store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_cmpunord_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.CompareScalarUnordered);

        /// <summary>
        /// Divide packed double-precision (64-bit) floating-point elements in "a" by packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm_div_pd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Divide);

        /// <summary>
        /// Divide the lower double-precision (64-bit) floating-point element in "a" by the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_div_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.DivideScalar);

        /// <summary>
        /// Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm_max_epu8(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Max);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the maximum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_max_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MaxScalar);

        /// <summary>
        /// Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm_min_epu8(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Min);

        /// <summary>
        /// Compare the lower double-precision (64-bit) floating-point elements in "a" and "b", store the minimum value in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_min_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MinScalar);

        /// <summary>
        /// Move the lower double-precision (64-bit) floating-point element from "b" to the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_move_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MoveScalar);

        /// <summary>
        /// Multiply the lower double-precision (64-bit) floating-point element in "a" and "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_mul_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MultiplyScalar);

        /// <summary>
        /// Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm_mulhi_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MultiplyHigh);

        /// <summary>
        /// Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm_mullo_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Sse2.MultiplyLow);

        /// <summary>
        /// Compute the bitwise OR of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm_or_si128(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Or);

        /// <summary>
        /// Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm_sll_epi16(object a, object count) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, count, System.Runtime.Intrinsics.X86.Sse2.ShiftLeftLogical);

        /// <summary>
        /// Compute the square root of packed double-precision (64-bit) floating-point elements in "a", and store the results in "dst".
        /// </summary>
        public object mm_sqrt_pd(object a) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse2.Sqrt);

        /// <summary>
        /// Compute the square root of the lower double-precision (64-bit) floating-point element in "b", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_sqrt_sd(object a) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse2.SqrtScalar);

        /// <summary>
        /// Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".
        /// </summary>
        public object mm_sra_epi16(object a, object count) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, count, System.Runtime.Intrinsics.X86.Sse2.ShiftRightArithmetic);

        /// <summary>
        /// Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".
        /// </summary>
        public object mm_srl_epi16(object a, object count) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, count, System.Runtime.Intrinsics.X86.Sse2.ShiftRightLogical);

        /// <summary>
        /// Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".
        /// </summary>
        public object mm_sub_epi8(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Subtract);

        /// <summary>
        /// Subtract the lower double-precision (64-bit) floating-point element in "b" from the lower double-precision (64-bit) floating-point element in "a", store the result in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_sub_sd(object a, object b) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, b, System.Runtime.Intrinsics.X86.Sse2.SubtractScalar);

        /// <summary>
        /// Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".
        /// </summary>
        public object mm_subs_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.SubtractSaturate);

        /// <summary>
        /// Unpack and interleave 8-bit integers from the high half of "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_unpackhi_epi8(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.UnpackHigh);

        /// <summary>
        /// Unpack and interleave 8-bit integers from the low half of "a" and "b", and store the results in "dst".
        /// </summary>
        public object mm_unpacklo_epi8(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.UnpackLow);

        /// <summary>
        /// Compute the bitwise XOR of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".
        /// </summary>
        public object mm_xor_si128(object a, object b) => ProcessArgs<byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>, byte, System.Runtime.Intrinsics.Vector128<byte>>(a, b, System.Runtime.Intrinsics.X86.Sse2.Xor);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse3IntrinsicsModule
    {
        /// <summary>
        /// Alternatively add and subtract packed single-precision (32-bit) floating-point elements in "a" to/from packed elements in "b", and store the results in "dst".
        /// </summary>
        public object mm_addsub_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse3.AddSubtract);

        /// <summary>
        /// Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in "a" and "b", and pack the results in "dst".
        /// </summary>
        public object mm_hadd_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse3.HorizontalAdd);

        /// <summary>
        /// Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in "a" and "b", and pack the results in "dst".
        /// </summary>
        public object mm_hsub_ps(object a, object b) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, b, System.Runtime.Intrinsics.X86.Sse3.HorizontalSubtract);

        /// <summary>
        /// Duplicate the low double-precision (64-bit) floating-point element from "a", and store the results in "dst".
        /// </summary>
        public object mm_movedup_pd(object a) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse3.MoveAndDuplicate);

        /// <summary>
        /// Duplicate odd-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
        /// </summary>
        public object mm_movehdup_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse3.MoveHighAndDuplicate);

        /// <summary>
        /// Duplicate even-indexed single-precision (32-bit) floating-point elements from "a", and store the results in "dst".
        /// </summary>
        public object mm_moveldup_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse3.MoveLowAndDuplicate);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse41IntrinsicsModule
    {
        /// <summary>
        /// Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".
        /// </summary>
        public object mm_blendv_epi8(object a, object b, object mask) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, mask, System.Runtime.Intrinsics.X86.Sse41.BlendVariable);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" up to an integer value, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm_ceil_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse41.Ceiling);

        /// <summary>
        /// Round the lower double-precision (64-bit) floating-point element in "b" up to an integer value, store the result as a double-precision floating-point element in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_ceil_sd(object a) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse41.CeilingScalar);

        /// <summary>
        /// Compare packed 64-bit integers in "a" and "b" for equality, and store the results in "dst".
        /// </summary>
        public object mm_cmpeq_epi64(object a, object b) => ProcessArgs<long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>>(a, b, System.Runtime.Intrinsics.X86.Sse41.CompareEqual);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" down to an integer value, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm_floor_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse41.Floor);

        /// <summary>
        /// Round the lower double-precision (64-bit) floating-point element in "b" down to an integer value, store the result as a double-precision floating-point element in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_floor_sd(object a) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse41.FloorScalar);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b", and store packed maximum values in "dst".
        /// </summary>
        public object mm_max_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse41.Max);

        /// <summary>
        /// Compare packed 8-bit integers in "a" and "b", and store packed minimum values in "dst".
        /// </summary>
        public object mm_min_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Sse41.Min);

        /// <summary>
        /// Horizontally compute the minimum amongst the packed unsigned 16-bit integers in "a", store the minimum and index in "dst", and zero the remaining bits in "dst".
        /// </summary>
        public object mm_minpos_epu16(object a) => ProcessArgs<ushort, System.Runtime.Intrinsics.Vector128<ushort>, ushort, System.Runtime.Intrinsics.Vector128<ushort>>(a, System.Runtime.Intrinsics.X86.Sse41.MinHorizontal);

        /// <summary>
        /// Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst".
        /// </summary>
        public object mm_mullo_epi32(object a, object b) => ProcessArgs<int, System.Runtime.Intrinsics.Vector128<int>, int, System.Runtime.Intrinsics.Vector128<int>, int, System.Runtime.Intrinsics.Vector128<int>>(a, b, System.Runtime.Intrinsics.X86.Sse41.MultiplyLow);

        /// <summary>
        /// Round the packed single-precision (32-bit) floating-point elements in "a" using the "rounding" parameter, and store the results as packed single-precision floating-point elements in "dst".
        /// </summary>
        public object mm_round_ps(object a) => ProcessArgs<float, System.Runtime.Intrinsics.Vector128<float>, float, System.Runtime.Intrinsics.Vector128<float>>(a, System.Runtime.Intrinsics.X86.Sse41.RoundToNearestInteger);

        /// <summary>
        /// Round the lower double-precision (64-bit) floating-point element in "b" using the "rounding" parameter, store the result as a double-precision floating-point element in the lower element of "dst", and copy the upper element from "a" to the upper element of "dst".
        /// </summary>
        public object mm_round_sd(object a) => ProcessArgs<double, System.Runtime.Intrinsics.Vector128<double>, double, System.Runtime.Intrinsics.Vector128<double>>(a, System.Runtime.Intrinsics.X86.Sse41.RoundCurrentDirectionScalar);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse42IntrinsicsModule
    {
        /// <summary>
        /// Compare packed 64-bit integers in "a" and "b" for greater-than, and store the results in "dst".
        /// </summary>
        public object mm_cmpgt_epi64(object a, object b) => ProcessArgs<long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>, long, System.Runtime.Intrinsics.Vector128<long>>(a, b, System.Runtime.Intrinsics.X86.Sse42.CompareGreaterThan);

    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Ssse3IntrinsicsModule
    {
        /// <summary>
        /// Horizontally add adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm_hadd_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.HorizontalAdd);

        /// <summary>
        /// Horizontally add adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm_hadds_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.HorizontalAddSaturate);

        /// <summary>
        /// Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm_hsub_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.HorizontalSubtract);

        /// <summary>
        /// Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".
        /// </summary>
        public object mm_hsubs_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.HorizontalSubtractSaturate);

        /// <summary>
        /// Multiply packed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst".
        /// </summary>
        public object mm_mulhrs_epi16(object a, object b) => ProcessArgs<short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>, short, System.Runtime.Intrinsics.Vector128<short>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.MultiplyHighRoundScale);

        /// <summary>
        /// Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".
        /// </summary>
        public object mm_shuffle_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.Shuffle);

        /// <summary>
        /// Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.
        /// </summary>
        public object mm_sign_epi8(object a, object b) => ProcessArgs<sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>, sbyte, System.Runtime.Intrinsics.Vector128<sbyte>>(a, b, System.Runtime.Intrinsics.X86.Ssse3.Sign);

    }
}

namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AesIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_aesdec_si128", (Func<object, object, object>)mm_aesdec_si128);
            RegisterFunction("mm_aesdeclast_si128", (Func<object, object, object>)mm_aesdeclast_si128);
            RegisterFunction("mm_aesenc_si128", (Func<object, object, object>)mm_aesenc_si128);
            RegisterFunction("mm_aesenclast_si128", (Func<object, object, object>)mm_aesenclast_si128);
            RegisterFunction("mm_aesimc_si128", (Func<object, object>)mm_aesimc_si128);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_aesdec_si128"];
                descriptor.Category = "";
                descriptor.Description = @"__m128i _mm_aesdec_si128 (__m128i a, __m128i RoundKey) AESDEC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesdeclast_si128"];
                descriptor.Category = "";
                descriptor.Description = @"__m128i _mm_aesdeclast_si128 (__m128i a, __m128i RoundKey) AESDECLAST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesenc_si128"];
                descriptor.Category = "";
                descriptor.Description = @"__m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey) AESENC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesenclast_si128"];
                descriptor.Category = "";
                descriptor.Description = @"__m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey) AESENCLAST xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
            {
                var descriptor = Descriptors["mm_aesimc_si128"];
                descriptor.Category = "";
                descriptor.Description = @"__m128i _mm_aesimc_si128 (__m128i a) AESIMC xmm, xmm/m128";
                descriptor.IsCommand = false;
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class AvxIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm256_add_ps", (Func<object, object, object>)mm256_add_ps);
            RegisterFunction("mm256_addsub_ps", (Func<object, object, object>)mm256_addsub_ps);
            RegisterFunction("mm256_and_ps", (Func<object, object, object>)mm256_and_ps);
            RegisterFunction("mm256_andnot_ps", (Func<object, object, object>)mm256_andnot_ps);
            RegisterFunction("mm256_blendv_ps", (Func<object, object, object, object>)mm256_blendv_ps);
            RegisterFunction("mm256_ceil_ps", (Func<object, object>)mm256_ceil_ps);
            RegisterFunction("mm256_div_ps", (Func<object, object, object>)mm256_div_ps);
            RegisterFunction("mm256_floor_ps", (Func<object, object>)mm256_floor_ps);
            RegisterFunction("mm256_hadd_ps", (Func<object, object, object>)mm256_hadd_ps);
            RegisterFunction("mm256_hsub_ps", (Func<object, object, object>)mm256_hsub_ps);
            RegisterFunction("mm256_max_ps", (Func<object, object, object>)mm256_max_ps);
            RegisterFunction("mm256_min_ps", (Func<object, object, object>)mm256_min_ps);
            RegisterFunction("mm256_movehdup_ps", (Func<object, object>)mm256_movehdup_ps);
            RegisterFunction("mm256_moveldup_ps", (Func<object, object>)mm256_moveldup_ps);
            RegisterFunction("mm256_mul_ps", (Func<object, object, object>)mm256_mul_ps);
            RegisterFunction("mm256_or_ps", (Func<object, object, object>)mm256_or_ps);
            RegisterFunction("mm256_rcp_ps", (Func<object, object>)mm256_rcp_ps);
            RegisterFunction("mm256_round_ps", (Func<object, object>)mm256_round_ps);
            RegisterFunction("mm256_rsqrt_ps", (Func<object, object>)mm256_rsqrt_ps);
            RegisterFunction("mm256_sqrt_ps", (Func<object, object>)mm256_sqrt_ps);
            RegisterFunction("mm256_sub_ps", (Func<object, object, object>)mm256_sub_ps);
            RegisterFunction("mm256_unpackhi_ps", (Func<object, object, object>)mm256_unpackhi_ps);
            RegisterFunction("mm256_unpacklo_ps", (Func<object, object, object>)mm256_unpacklo_ps);
            RegisterFunction("mm256_xor_ps", (Func<object, object, object>)mm256_xor_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm256_add_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Add packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_addsub_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Alternatively add and subtract packed single-precision (32-bit) floating-point elements in ""a"" to/from packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_and_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_andnot_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in ""a"" and then AND with ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_blendv_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Blend packed single-precision (32-bit) floating-point elements from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("mask", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_ceil_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" up to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_div_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Divide packed single-precision (32-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_floor_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" down to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hadd_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hsub_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_max_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_min_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_movehdup_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Duplicate odd-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_moveldup_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Duplicate even-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mul_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_or_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_rcp_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_round_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("rounding", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_rsqrt_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sqrt_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sub_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Subtract packed single-precision (32-bit) floating-point elements in ""b"" from packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_xor_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Avx2IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_broadcastb_epi8", (Func<object, object>)mm_broadcastb_epi8);
            RegisterFunction("mm256_add_epi8", (Func<object, object, object>)mm256_add_epi8);
            RegisterFunction("mm256_adds_epi8", (Func<object, object, object>)mm256_adds_epi8);
            RegisterFunction("mm256_and_si256", (Func<object, object, object>)mm256_and_si256);
            RegisterFunction("mm256_andnot_si256", (Func<object, object, object>)mm256_andnot_si256);
            RegisterFunction("mm256_avg_epu8", (Func<object, object, object>)mm256_avg_epu8);
            RegisterFunction("mm256_blendv_epi8", (Func<object, object, object, object>)mm256_blendv_epi8);
            RegisterFunction("mm256_cmpeq_epi8", (Func<object, object, object>)mm256_cmpeq_epi8);
            RegisterFunction("mm256_cmpgt_epi8", (Func<object, object, object>)mm256_cmpgt_epi8);
            RegisterFunction("mm256_hadd_epi16", (Func<object, object, object>)mm256_hadd_epi16);
            RegisterFunction("mm256_hadds_epi16", (Func<object, object, object>)mm256_hadds_epi16);
            RegisterFunction("mm256_hsub_epi16", (Func<object, object, object>)mm256_hsub_epi16);
            RegisterFunction("mm256_hsubs_epi16", (Func<object, object, object>)mm256_hsubs_epi16);
            RegisterFunction("mm256_max_epi8", (Func<object, object, object>)mm256_max_epi8);
            RegisterFunction("mm256_min_epi8", (Func<object, object, object>)mm256_min_epi8);
            RegisterFunction("mm256_mulhi_epi16", (Func<object, object, object>)mm256_mulhi_epi16);
            RegisterFunction("mm256_mulhrs_epi16", (Func<object, object, object>)mm256_mulhrs_epi16);
            RegisterFunction("mm256_mullo_epi16", (Func<object, object, object>)mm256_mullo_epi16);
            RegisterFunction("mm256_or_si256", (Func<object, object, object>)mm256_or_si256);
            RegisterFunction("mm256_permutevar8x32_epi32", (Func<object, object, object>)mm256_permutevar8x32_epi32);
            RegisterFunction("mm256_shuffle_epi8", (Func<object, object, object>)mm256_shuffle_epi8);
            RegisterFunction("mm256_sign_epi8", (Func<object, object, object>)mm256_sign_epi8);
            RegisterFunction("mm256_sub_epi8", (Func<object, object, object>)mm256_sub_epi8);
            RegisterFunction("mm256_subs_epi8", (Func<object, object, object>)mm256_subs_epi8);
            RegisterFunction("mm256_unpackhi_epi8", (Func<object, object, object>)mm256_unpackhi_epi8);
            RegisterFunction("mm256_unpacklo_epi8", (Func<object, object, object>)mm256_unpacklo_epi8);
            RegisterFunction("mm256_xor_si256", (Func<object, object, object>)mm256_xor_si256);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_broadcastb_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Broadcast the low packed 8-bit integer from ""a"" to all elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_add_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_adds_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_and_si256"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise AND of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_andnot_si256"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise NOT of 256 bits (representing integer data) in ""a"" and then AND with ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_avg_epu8"];
                descriptor.Category = "";
                descriptor.Description = @"Average packed unsigned 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_blendv_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Blend packed 8-bit integers from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("mask", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cmpeq_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_cmpgt_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hadd_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hadds_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hsub_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_hsubs_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_max_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_min_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mulhi_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mulhrs_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply packed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_mullo_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_or_si256"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise OR of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_permutevar8x32_epi32"];
                descriptor.Category = "";
                descriptor.Description = @"Shuffle 32-bit integers in ""a"" across lanes using the corresponding index in ""idx"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("idx", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_shuffle_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Shuffle 8-bit integers in ""a"" within 128-bit lanes according to shuffle control mask in the corresponding 8-bit element of ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sign_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Negate packed 8-bit integers in ""a"" when the corresponding signed 8-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_sub_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_subs_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"" using saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_unpackhi_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the high half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_unpacklo_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the low half of each 128-bit lane in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm256_xor_si256"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise XOR of 256 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m256i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m256i")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class SseIntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_add_ps", (Func<object, object, object>)mm_add_ps);
            RegisterFunction("mm_add_ss", (Func<object, object, object>)mm_add_ss);
            RegisterFunction("mm_and_ps", (Func<object, object, object>)mm_and_ps);
            RegisterFunction("mm_andnot_ps", (Func<object, object, object>)mm_andnot_ps);
            RegisterFunction("mm_cmpeq_ps", (Func<object, object, object>)mm_cmpeq_ps);
            RegisterFunction("mm_cmpeq_ss", (Func<object, object, object>)mm_cmpeq_ss);
            RegisterFunction("mm_cmpge_ps", (Func<object, object, object>)mm_cmpge_ps);
            RegisterFunction("mm_cmpge_ss", (Func<object, object, object>)mm_cmpge_ss);
            RegisterFunction("mm_cmpgt_ps", (Func<object, object, object>)mm_cmpgt_ps);
            RegisterFunction("mm_cmpgt_ss", (Func<object, object, object>)mm_cmpgt_ss);
            RegisterFunction("mm_cmple_ps", (Func<object, object, object>)mm_cmple_ps);
            RegisterFunction("mm_cmple_ss", (Func<object, object, object>)mm_cmple_ss);
            RegisterFunction("mm_cmplt_ps", (Func<object, object, object>)mm_cmplt_ps);
            RegisterFunction("mm_cmplt_ss", (Func<object, object, object>)mm_cmplt_ss);
            RegisterFunction("mm_cmpneq_ps", (Func<object, object, object>)mm_cmpneq_ps);
            RegisterFunction("mm_cmpneq_ss", (Func<object, object, object>)mm_cmpneq_ss);
            RegisterFunction("mm_cmpnge_ps", (Func<object, object, object>)mm_cmpnge_ps);
            RegisterFunction("mm_cmpnge_ss", (Func<object, object, object>)mm_cmpnge_ss);
            RegisterFunction("mm_cmpngt_ps", (Func<object, object, object>)mm_cmpngt_ps);
            RegisterFunction("mm_cmpngt_ss", (Func<object, object, object>)mm_cmpngt_ss);
            RegisterFunction("mm_cmpnle_ps", (Func<object, object, object>)mm_cmpnle_ps);
            RegisterFunction("mm_cmpnle_ss", (Func<object, object, object>)mm_cmpnle_ss);
            RegisterFunction("mm_cmpnlt_ps", (Func<object, object, object>)mm_cmpnlt_ps);
            RegisterFunction("mm_cmpnlt_ss", (Func<object, object, object>)mm_cmpnlt_ss);
            RegisterFunction("mm_cmpord_ps", (Func<object, object, object>)mm_cmpord_ps);
            RegisterFunction("mm_cmpord_ss", (Func<object, object, object>)mm_cmpord_ss);
            RegisterFunction("mm_cmpunord_ps", (Func<object, object, object>)mm_cmpunord_ps);
            RegisterFunction("mm_cmpunord_ss", (Func<object, object, object>)mm_cmpunord_ss);
            RegisterFunction("mm_div_ps", (Func<object, object, object>)mm_div_ps);
            RegisterFunction("mm_div_ss", (Func<object, object, object>)mm_div_ss);
            RegisterFunction("mm_max_ps", (Func<object, object, object>)mm_max_ps);
            RegisterFunction("mm_max_ss", (Func<object, object, object>)mm_max_ss);
            RegisterFunction("mm_min_ps", (Func<object, object, object>)mm_min_ps);
            RegisterFunction("mm_min_ss", (Func<object, object, object>)mm_min_ss);
            RegisterFunction("mm_move_ss", (Func<object, object, object>)mm_move_ss);
            RegisterFunction("mm_movehl_ps", (Func<object, object, object>)mm_movehl_ps);
            RegisterFunction("mm_movelh_ps", (Func<object, object, object>)mm_movelh_ps);
            RegisterFunction("mm_mul_ps", (Func<object, object, object>)mm_mul_ps);
            RegisterFunction("mm_mul_ss", (Func<object, object, object>)mm_mul_ss);
            RegisterFunction("mm_or_ps", (Func<object, object, object>)mm_or_ps);
            RegisterFunction("mm_rcp_ps", (Func<object, object>)mm_rcp_ps);
            RegisterFunction("mm_rcp_ss", (Func<object, object>)mm_rcp_ss);
            RegisterFunction("mm_rsqrt_ps", (Func<object, object>)mm_rsqrt_ps);
            RegisterFunction("mm_rsqrt_ss", (Func<object, object>)mm_rsqrt_ss);
            RegisterFunction("mm_sqrt_ps", (Func<object, object>)mm_sqrt_ps);
            RegisterFunction("mm_sqrt_ss", (Func<object, object>)mm_sqrt_ss);
            RegisterFunction("mm_sub_ps", (Func<object, object, object>)mm_sub_ps);
            RegisterFunction("mm_sub_ss", (Func<object, object, object>)mm_sub_ss);
            RegisterFunction("mm_unpackhi_ps", (Func<object, object, object>)mm_unpackhi_ps);
            RegisterFunction("mm_unpacklo_ps", (Func<object, object, object>)mm_unpacklo_ps);
            RegisterFunction("mm_xor_ps", (Func<object, object, object>)mm_xor_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_add_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Add packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_add_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Add the lower single-precision (32-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_and_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise AND of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_andnot_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise NOT of packed single-precision (32-bit) floating-point elements in ""a"" and then AND with ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for equality, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for equality, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpge_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpge_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpgt_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpgt_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for greater-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmple_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmple_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmplt_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmplt_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for less-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpneq_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpneq_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnge_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnge_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpngt_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpngt_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnle_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnle_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" for not-less-than, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpord_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpord_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpunord_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpunord_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_div_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Divide packed single-precision (32-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_div_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Divide the lower single-precision (32-bit) floating-point element in ""a"" by the lower single-precision (32-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"", store the maximum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower single-precision (32-bit) floating-point elements in ""a"" and ""b"", store the minimum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_move_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Move the lower single-precision (32-bit) floating-point element from ""b"" to the lower element of ""dst"", and copy the upper 3 elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movehl_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Move the upper 2 single-precision (32-bit) floating-point elements from ""b"" to the lower 2 elements of ""dst"", and copy the upper 2 elements from ""a"" to the upper 2 elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movelh_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Move the lower 2 single-precision (32-bit) floating-point elements from ""b"" to the upper 2 elements of ""dst"", and copy the lower 2 elements from ""a"" to the lower 2 elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mul_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mul_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply the lower single-precision (32-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_or_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise OR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_rcp_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the approximate reciprocal of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_rcp_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the approximate reciprocal of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_rsqrt_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the approximate reciprocal square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_rsqrt_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the approximate reciprocal square root of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"". The maximum relative error for this approximation is less than 1.5*2^-12.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sqrt_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the square root of packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sqrt_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the square root of the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sub_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Subtract packed single-precision (32-bit) floating-point elements in ""b"" from packed single-precision (32-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sub_ss"];
                descriptor.Category = "";
                descriptor.Description = @"Subtract the lower single-precision (32-bit) floating-point element in ""b"" from the lower single-precision (32-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper 3 packed elements from ""a"" to the upper elements of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_unpackhi_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the high half ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_unpacklo_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Unpack and interleave single-precision (32-bit) floating-point elements from the low half of ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_xor_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise XOR of packed single-precision (32-bit) floating-point elements in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse2IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_add_epi8", (Func<object, object, object>)mm_add_epi8);
            RegisterFunction("mm_add_sd", (Func<object, object, object>)mm_add_sd);
            RegisterFunction("mm_adds_epi8", (Func<object, object, object>)mm_adds_epi8);
            RegisterFunction("mm_and_si128", (Func<object, object, object>)mm_and_si128);
            RegisterFunction("mm_andnot_si128", (Func<object, object, object>)mm_andnot_si128);
            RegisterFunction("mm_avg_epu8", (Func<object, object, object>)mm_avg_epu8);
            RegisterFunction("mm_cmpeq_epi8", (Func<object, object, object>)mm_cmpeq_epi8);
            RegisterFunction("mm_cmpeq_sd", (Func<object, object, object>)mm_cmpeq_sd);
            RegisterFunction("mm_cmpge_pd", (Func<object, object, object>)mm_cmpge_pd);
            RegisterFunction("mm_cmpge_sd", (Func<object, object, object>)mm_cmpge_sd);
            RegisterFunction("mm_cmpgt_epi8", (Func<object, object, object>)mm_cmpgt_epi8);
            RegisterFunction("mm_cmpgt_sd", (Func<object, object, object>)mm_cmpgt_sd);
            RegisterFunction("mm_cmple_pd", (Func<object, object, object>)mm_cmple_pd);
            RegisterFunction("mm_cmple_sd", (Func<object, object, object>)mm_cmple_sd);
            RegisterFunction("mm_cmplt_epi8", (Func<object, object, object>)mm_cmplt_epi8);
            RegisterFunction("mm_cmplt_sd", (Func<object, object, object>)mm_cmplt_sd);
            RegisterFunction("mm_cmpneq_pd", (Func<object, object, object>)mm_cmpneq_pd);
            RegisterFunction("mm_cmpneq_sd", (Func<object, object, object>)mm_cmpneq_sd);
            RegisterFunction("mm_cmpnge_pd", (Func<object, object, object>)mm_cmpnge_pd);
            RegisterFunction("mm_cmpnge_sd", (Func<object, object, object>)mm_cmpnge_sd);
            RegisterFunction("mm_cmpngt_pd", (Func<object, object, object>)mm_cmpngt_pd);
            RegisterFunction("mm_cmpngt_sd", (Func<object, object, object>)mm_cmpngt_sd);
            RegisterFunction("mm_cmpnle_pd", (Func<object, object, object>)mm_cmpnle_pd);
            RegisterFunction("mm_cmpnle_sd", (Func<object, object, object>)mm_cmpnle_sd);
            RegisterFunction("mm_cmpnlt_pd", (Func<object, object, object>)mm_cmpnlt_pd);
            RegisterFunction("mm_cmpnlt_sd", (Func<object, object, object>)mm_cmpnlt_sd);
            RegisterFunction("mm_cmpord_pd", (Func<object, object, object>)mm_cmpord_pd);
            RegisterFunction("mm_cmpord_sd", (Func<object, object, object>)mm_cmpord_sd);
            RegisterFunction("mm_cmpunord_pd", (Func<object, object, object>)mm_cmpunord_pd);
            RegisterFunction("mm_cmpunord_sd", (Func<object, object, object>)mm_cmpunord_sd);
            RegisterFunction("mm_div_pd", (Func<object, object, object>)mm_div_pd);
            RegisterFunction("mm_div_sd", (Func<object, object, object>)mm_div_sd);
            RegisterFunction("mm_max_epu8", (Func<object, object, object>)mm_max_epu8);
            RegisterFunction("mm_max_sd", (Func<object, object, object>)mm_max_sd);
            RegisterFunction("mm_min_epu8", (Func<object, object, object>)mm_min_epu8);
            RegisterFunction("mm_min_sd", (Func<object, object, object>)mm_min_sd);
            RegisterFunction("mm_move_sd", (Func<object, object, object>)mm_move_sd);
            RegisterFunction("mm_mul_sd", (Func<object, object, object>)mm_mul_sd);
            RegisterFunction("mm_mulhi_epi16", (Func<object, object, object>)mm_mulhi_epi16);
            RegisterFunction("mm_mullo_epi16", (Func<object, object, object>)mm_mullo_epi16);
            RegisterFunction("mm_or_si128", (Func<object, object, object>)mm_or_si128);
            RegisterFunction("mm_sll_epi16", (Func<object, object, object>)mm_sll_epi16);
            RegisterFunction("mm_sqrt_pd", (Func<object, object>)mm_sqrt_pd);
            RegisterFunction("mm_sqrt_sd", (Func<object, object>)mm_sqrt_sd);
            RegisterFunction("mm_sra_epi16", (Func<object, object, object>)mm_sra_epi16);
            RegisterFunction("mm_srl_epi16", (Func<object, object, object>)mm_srl_epi16);
            RegisterFunction("mm_sub_epi8", (Func<object, object, object>)mm_sub_epi8);
            RegisterFunction("mm_sub_sd", (Func<object, object, object>)mm_sub_sd);
            RegisterFunction("mm_subs_epi8", (Func<object, object, object>)mm_subs_epi8);
            RegisterFunction("mm_unpackhi_epi8", (Func<object, object, object>)mm_unpackhi_epi8);
            RegisterFunction("mm_unpacklo_epi8", (Func<object, object, object>)mm_unpacklo_epi8);
            RegisterFunction("mm_xor_si128", (Func<object, object, object>)mm_xor_si128);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_add_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_add_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Add the lower double-precision (64-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_adds_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Add packed 8-bit integers in ""a"" and ""b"" using saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_and_si128"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise AND of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_andnot_si128"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise NOT of 128 bits (representing integer data) in ""a"" and then AND with ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_avg_epu8"];
                descriptor.Category = "";
                descriptor.Description = @"Average packed unsigned 8-bit integers in ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for equality, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpge_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpge_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpgt_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpgt_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for greater-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmple_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmple_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmplt_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"" for less-than, and store the results in ""dst"". Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmplt_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for less-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpneq_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpneq_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnge_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnge_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpngt_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpngt_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-greater-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnle_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnle_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than-or-equal, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpnlt_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" for not-less-than, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpord_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpord_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if neither is NaN, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpunord_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpunord_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"" to see if either is NaN, store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_div_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Divide packed double-precision (64-bit) floating-point elements in ""a"" by packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_div_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Divide the lower double-precision (64-bit) floating-point element in ""a"" by the lower double-precision (64-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_epu8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed unsigned 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"", store the maximum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_epu8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed unsigned 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compare the lower double-precision (64-bit) floating-point elements in ""a"" and ""b"", store the minimum value in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_move_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Move the lower double-precision (64-bit) floating-point element from ""b"" to the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mul_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply the lower double-precision (64-bit) floating-point element in ""a"" and ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mulhi_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mullo_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply the packed 16-bit integers in ""a"" and ""b"", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_or_si128"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise OR of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sll_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" left by ""count"" while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sqrt_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the square root of packed double-precision (64-bit) floating-point elements in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sqrt_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the square root of the lower double-precision (64-bit) floating-point element in ""b"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sra_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""count"" while shifting in sign bits, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_srl_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Shift packed 16-bit integers in ""a"" right by ""count"" while shifting in zeros, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("count", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sub_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sub_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Subtract the lower double-precision (64-bit) floating-point element in ""b"" from the lower double-precision (64-bit) floating-point element in ""a"", store the result in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_subs_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Subtract packed 8-bit integers in ""b"" from packed 8-bit integers in ""a"" using saturation, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_unpackhi_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the high half of ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_unpacklo_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Unpack and interleave 8-bit integers from the low half of ""a"" and ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_xor_si128"];
                descriptor.Category = "";
                descriptor.Description = @"Compute the bitwise XOR of 128 bits (representing integer data) in ""a"" and ""b"", and store the result in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse3IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_addsub_ps", (Func<object, object, object>)mm_addsub_ps);
            RegisterFunction("mm_hadd_ps", (Func<object, object, object>)mm_hadd_ps);
            RegisterFunction("mm_hsub_ps", (Func<object, object, object>)mm_hsub_ps);
            RegisterFunction("mm_movedup_pd", (Func<object, object>)mm_movedup_pd);
            RegisterFunction("mm_movehdup_ps", (Func<object, object>)mm_movehdup_ps);
            RegisterFunction("mm_moveldup_ps", (Func<object, object>)mm_moveldup_ps);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_addsub_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Alternatively add and subtract packed single-precision (32-bit) floating-point elements in ""a"" to/from packed elements in ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hadd_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hsub_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally add adjacent pairs of single-precision (32-bit) floating-point elements in ""a"" and ""b"", and pack the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movedup_pd"];
                descriptor.Category = "";
                descriptor.Description = @"Duplicate the low double-precision (64-bit) floating-point element from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_movehdup_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Duplicate odd-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_moveldup_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Duplicate even-indexed single-precision (32-bit) floating-point elements from ""a"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse41IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_blendv_epi8", (Func<object, object, object, object>)mm_blendv_epi8);
            RegisterFunction("mm_ceil_ps", (Func<object, object>)mm_ceil_ps);
            RegisterFunction("mm_ceil_sd", (Func<object, object>)mm_ceil_sd);
            RegisterFunction("mm_cmpeq_epi64", (Func<object, object, object>)mm_cmpeq_epi64);
            RegisterFunction("mm_floor_ps", (Func<object, object>)mm_floor_ps);
            RegisterFunction("mm_floor_sd", (Func<object, object>)mm_floor_sd);
            RegisterFunction("mm_max_epi8", (Func<object, object, object>)mm_max_epi8);
            RegisterFunction("mm_min_epi8", (Func<object, object, object>)mm_min_epi8);
            RegisterFunction("mm_minpos_epu16", (Func<object, object>)mm_minpos_epu16);
            RegisterFunction("mm_mullo_epi32", (Func<object, object, object>)mm_mullo_epi32);
            RegisterFunction("mm_round_ps", (Func<object, object>)mm_round_ps);
            RegisterFunction("mm_round_sd", (Func<object, object>)mm_round_sd);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_blendv_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Blend packed 8-bit integers from ""a"" and ""b"" using ""mask"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("mask", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ceil_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" up to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_ceil_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" up to an integer value, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_cmpeq_epi64"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 64-bit integers in ""a"" and ""b"" for equality, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_floor_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" down to an integer value, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_floor_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" down to an integer value, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_max_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed maximum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_min_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 8-bit integers in ""a"" and ""b"", and store packed minimum values in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_minpos_epu16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally compute the minimum amongst the packed unsigned 16-bit integers in ""a"", store the minimum and index in ""dst"", and zero the remaining bits in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mullo_epi32"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply the packed 32-bit integers in ""a"" and ""b"", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_round_ps"];
                descriptor.Category = "";
                descriptor.Description = @"Round the packed single-precision (32-bit) floating-point elements in ""a"" using the ""rounding"" parameter, and store the results as packed single-precision floating-point elements in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("rounding", @"int")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_round_sd"];
                descriptor.Category = "";
                descriptor.Description = @"Round the lower double-precision (64-bit) floating-point element in ""b"" using the ""rounding"" parameter, store the result as a double-precision floating-point element in the lower element of ""dst"", and copy the upper element from ""a"" to the upper element of ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128d")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("rounding", @"int")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Sse42IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_cmpgt_epi64", (Func<object, object, object>)mm_cmpgt_epi64);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_cmpgt_epi64"];
                descriptor.Category = "";
                descriptor.Description = @"Compare packed 64-bit integers in ""a"" and ""b"" for greater-than, and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
        }        
    }
}
namespace Kalk.Core.Modules.HardwareIntrinsics
{
    public partial class Ssse3IntrinsicsModule
    {
        protected override void RegisterFunctionsAuto()
        {
            RegisterFunction("mm_hadd_epi16", (Func<object, object, object>)mm_hadd_epi16);
            RegisterFunction("mm_hadds_epi16", (Func<object, object, object>)mm_hadds_epi16);
            RegisterFunction("mm_hsub_epi16", (Func<object, object, object>)mm_hsub_epi16);
            RegisterFunction("mm_hsubs_epi16", (Func<object, object, object>)mm_hsubs_epi16);
            RegisterFunction("mm_mulhrs_epi16", (Func<object, object, object>)mm_mulhrs_epi16);
            RegisterFunction("mm_shuffle_epi8", (Func<object, object, object>)mm_shuffle_epi8);
            RegisterFunction("mm_sign_epi8", (Func<object, object, object>)mm_sign_epi8);
            RegisterDocumentationAuto();
        }

        private void RegisterDocumentationAuto()
        {
            {
                var descriptor = Descriptors["mm_hadd_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hadds_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally add adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hsub_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"", and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_hsubs_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Horizontally subtract adjacent pairs of 16-bit integers in ""a"" and ""b"" using saturation, and pack the signed 16-bit results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_mulhrs_epi16"];
                descriptor.Category = "";
                descriptor.Description = @"Multiply packed 16-bit integers in ""a"" and ""b"", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_shuffle_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Shuffle packed 8-bit integers in ""a"" according to shuffle control mask in the corresponding 8-bit element of ""b"", and store the results in ""dst"".";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
            {
                var descriptor = Descriptors["mm_sign_epi8"];
                descriptor.Category = "";
                descriptor.Description = @"Negate packed 8-bit integers in ""a"" when the corresponding signed 8-bit integer in ""b"" is negative, and store the results in ""dst"". Element in ""dst"" are zeroed out when the corresponding element in ""b"" is zero.";
                descriptor.IsCommand = false;
                descriptor.Params.Add(new KalkParamDescriptor("a", @"__m128i")  { IsOptional = false });
                descriptor.Params.Add(new KalkParamDescriptor("b", @"__m128i")  { IsOptional = false });
            }
        }        
    }
}
